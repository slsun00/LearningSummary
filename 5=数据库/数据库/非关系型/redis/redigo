## redigo

*   github地址： [https://github.com/garyburd/redigo](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgaryburd%2Fredigo) 
*   文档地址：  http://godoc.org/github.com/garyburd/redigo/redis

## 获取

```go
go get github.com/garyburd/redigo/redis
```

## 导入 

```go
import (
    "fmt"
    "github.com/garyburd/redigo/redis"
)
```

## 链接 redis

```go
import (
    "fmt"
    "github.com/garyburd/redigo/redis"
)

func main() {
    c, err := redis.Dial("tcp", "127.0.0.1:6379")
    if err != nil {
        fmt.Println("Connect to redis error", err)
        return
    }
    defer c.Close()
}
```



## 读写

*   不过期读写

    ```go
        _, err = c.Do("SET", "mykey", "superWang")
        if err != nil {
            fmt.Println("redis set failed:", err)
        }
    
        username, err := redis.String(c.Do("GET", "mykey"))
        if err != nil {
            fmt.Println("redis get failed:", err)
        } else {
            fmt.Printf("Get mykey: %v \n", username)
        }
    }
    ```

*   过期读写

    ```go
        _, err = c.Do("SET", "mykey", "superWang", "EX", "5")
        if err != nil {
            fmt.Println("redis set failed:", err)
        }
    
    	// 常用 time.Sleep(8 * time.Second) 前后设置取 key,来检验是否过期
         // 读和前面是一样的
    ```
    
*   批量读取写

    ```go
    MGET key [key …]
    MSET key value [key value …]
    
    // M 可以理解为 many
    ```

    

## 检测值是否存在

```go
// redis源码： EXISTS key

    is_key_exit, err := redis.Bool(c.Do("EXISTS", "mykey1"))
    if err != nil {
        fmt.Println("error:", err)
    } else {
        fmt.Printf("exists or not: %v \n", is_key_exit)
    }
```



## 删除

```go
// DEL key [key …]

    _, err = c.Do("DEL", "mykey")
    if err != nil {
        fmt.Println("redis delelte failed:", err)
    }
```

##  **读写json到redis** 

```go
    // json 序列化
	key := "profile"
    imap := map[string]string{"username": "666", "phonenumber": "888"}
    value, _ := json.Marshal(imap)
	// 序列化以后再写入到 redis
    n, err := c.Do("SETNX", key, value)
    if err != nil {
        fmt.Println(err)
    }
	if n == int64(1) {  // c.do()返回的值
        fmt.Println("success")
    }
//----------------------------------------------------
	// json 反序列化
	// 
    var imapGet map[string]string
	// 取到序列化的值
    valueGet, err := redis.Bytes(c.Do("GET", key))
    if err != nil {
        fmt.Println(err)
    }
	// 反序列化的值放在一个 imapGet map 中，通过这个 map 可进行深入查询
    errShal := json.Unmarshal(valueGet, &imapGet)
    if errShal != nil {
        fmt.Println(err)
    }
    fmt.Println(imapGet["username"])
    fmt.Println(imapGet["phonenumber"])
```

##  **设置过期时间** 

```go
// EXPIRE key seconds

// 设置过期时间为24小时  
n, _ := rs.Do("EXPIRE", key, 24*3600)  
if n == int64(1) {  
    fmt.Println("success")  
}  

```

## 列表操作

```go
// LPUSH runoobkey redis
(integer) 1


    _, err = c.Do("lpush", "runoobkey", "redis")
    if err != nil {
        fmt.Println("redis set failed:", err)
    }


    values, _ := redis.Values(c.Do("lrange", "runoobkey", "0", "100"))
    for _, v := range values {
        fmt.Println(string(v.([]byte)))
    }
```

## 管道

*    求/响应服务可以实现持续处理新请求，即使客户端没有准备好读取旧响应。这样客户端可以发送多个命令到服务器而无需等待响应，最后在一次读取多个响应。这就是管道化(pipelining) 

*    连接支持使用Send()，Flush()，Receive()方法支持管道化操作 

    ```go
    Send(commandName string, args ...interface{}) error  // Send向连接的输出缓冲中写入命令
    Flush() error								      // Flush将连接的输出缓冲清空并写入服务器端
    Receive() (reply interface{}, err error)             // Recevie按照FIFO顺序依次读取服务器的响应
    
    c.Send("SET", "foo", "bar")
    c.Send("GET", "foo")
    c.Flush()
    c.Receive() // reply from SET
    v, err = c.Receive() // reply from GET
    
    // Do方法组合了Send,Flush和 Receive方法。
    // Do方法先写入命令，然后清空输出buffer，最后接收全部挂起响应包括Do方发出的命令的结果。
    // 如果任何响应中包含一个错误，Do返回错误。如果没有错误，Do方法返回最后一个响应。
    
    ```

    







## 连接池

```go
 // 最好定义成全局变量，这样方便使用
var pool *redis.pool

// 当程序启动时就可以用，就初始化连接池
// 将下面代码封装到一个函数中  func init(){ 代码 }
func init{
    pool = &redis.pool{
        MaxIdle : 8,  //最大空闲数  idle ：空闲，项目大，性能不够，可以调大
        MaxActive :0,  // 和数据库最大连接数，0表示无限制
        IdleTimeout :100, // 最大空闲时间
        Dial:func()(redis.Conn,error){  // 初始化连接池的代码 
            return redis.Dial("tcp","localhost:6397")  // 链接哪个 ip 的 redis
        },
}

conn := pool.Get() // 从连接池取出一个链接,返回的是conn
defer connn.Close()  // 关闭链接池，一旦关闭就不能从连接池中再取出链接

//操作,读取和之前的一样
_,err := conn.Do("set","name","lili")
```



## 参考

*   https://www.jianshu.com/p/aeb27a6aa42d