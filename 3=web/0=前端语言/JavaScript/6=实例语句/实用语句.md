## 死链接

```html
href = "#"
	包含一个位置信息，默认猫是 #top , 当连续点击此链接会导致浏览器巨慢甚至崩溃

href ="###"
	一般用 三个 

JavaScript:void(0)
	仅仅表示一个死链接

javascript:;
	表示一个死链接
```



## 单机响应函数

```js
// idstr  要绑定单机哈数的对象的 id 属性值
// func   事件回调的函数，单机元素，该函数会被触发
function myClick(isStr,func){
    var btn = document.getElementById(idStr);
    btn.onclick = func;
}

myclick("bt07",function(){
    var bj = document.getElementById("bj")
    var pn = bj.parentNode
})
```

## 选择

```js
// 全选
var checkedAllBtn = document.getElementById("checkAllBtn")
checkedAllBtn.onclick = function(){
	// 获取四个多选框 的name=item
    var items = document.getElementByName("item")
    // 遍历
    for (var i=0;i<items.lenght;i++){
		// 设置选中状态
        items[i].checked = true
    }
    // 设置多选框选中
    
}

// 全不选

var checkNoBtn = document.getElementById("checkedNoBtn");
checkedNoBtn.onclock = function(){
   	// 获取四个多选框 的name=item
    var items = document.getElementByName("item");
    for(var i=0;i<items.length;i++){
        items[i].checked = false;
    };
}

// 反选

var checkRevBut = document.getElementById("checkedRevBtn");
checkedRevBtn.onclock = function(){
    // 获取四个多选框 的name=item
    var items = document.getElementByName("item");
    for(var i=0;i<items.length;i++){
        items[i].checked = !items[i].checked;
	   //if (items[i].checked){
        //     items[i].checked = false;
        //} else {
        //     items[i].checked = true;
       // }
       
    };
};


// 提交

var sendBtn = document.getElementById("send")
```



## 兼容选择样式

```js
// 定义一个函数获取指定元素当前的样式， obj 要获取样式的元素， name 要获取的样式名
function getStyle(obj,name){
    // 加window变成一个对象的属性，变量没找到报错，属性没有找到返回 undefined
    if (window.getcomputedStyle){
            // 正常浏览器的方式 ,IE8 会出错
		return getcomputedStyle(obj,null)[name];
    } else {
            // IE8 的
    	return obj.currentStyle[name];
    }
}
```

## 拖拽功能

```js
window.onload = function(){
    // 1. 鼠标在被拖拽元素上下时候，开始拖拽
    // 2. 当鼠标移动时，被拖拽元素跟着鼠标移动
    // 3. 当鼠标松开时，被拖拽元素固定在当前位置
    
    // 获取 box1
    var box1 = document.gerElementById("box1")
	drag(box1);
}
// 当调用 一个元素 的 capture() 方法后，这个元素将会把下一次所有的鼠标按下的相关事件捕获到自身上
btn01.setCapture();


// 对上面函数进行封装  
function drag(obj){
    
   // 为 box1 绑定一个鼠标按下事件，当鼠标在拖拽元素上按下时，开始拖拽
    obj.onmousedown = function(event){
        alert("开始拖拽")
        
        // 这个只能移动这个 box1,只进行 box1 的操作
        // 只支持  IE8 
        // box1.setCpture && box1.setCaputre();
        if (obj.setCapture) {
			obj.setCapture();
        }
        
        
        // div 的偏移量 鼠标.clientX - 元素.offsetLeft
        // div 的偏移量 鼠标.clientX - 元素.offsetTop
        event = event || window.event
        var ol = event.clientX - obj.offsetLeft;
        var ot = event.clientY - obj.offsetRight;
        
        
        
        
        // 给 body 绑定
        document.onmousemove = function(event){
            event = event || window.event
            // 鼠标拖拽元素跟着鼠标移动
            // 获取鼠标的坐标
            var left = event.clientX - ol;
            var top = event.clientY - ot;
            // 修改 box1 的位置
            obj.style.left = left+'px';
            obj.style.right = right+'px';
        };
        
        
        // 为 document 绑定一个鼠标松开事件
        document.onmouseup = function(){
            // 鼠标松开时候，被拖拽元素固定在当前位置
            // 取消 document 的onmousemove 事件
            document.onmousemove = null;
            
            // 取消 document 的 onmouseup 事件
            document.onmouseup = null;
            
            // 取消单一捕获
            // 只支持  IE8 
            // box1.releaseCpture && box1.releaseCaputre();
            if (obj.releaseCapture) {
                obj.releaseCapture();
       		 }
            
        };
        
        // 目标貌似没有了
        // 拖拽一个网页的内容，浏览器会默认去搜索内容，此时会导致功能异常，这个是浏览器默认型行为
        // 如果不希望出现这个行为，可以取消
        return false;  // 就默认取消了

    }
}

```

## 鼠标滚轮

```js
window.onload = function(){
    // 向下滚动时候，box1 边长
    // 向上滚动 ，box1 变短
    var box1 = document.getElementById("box1")

    // 鼠标滚轮滚动触发事件
    // 这个已经全部支持了
    box1.onmousewheel = function(){
        alter(盾冬了)
    }
}

// 兼容性的东西，理解思路即可
window.onload = function(){
    // 向下滚动时候，box1 边长
    // 向上滚动 ，box1 变短
    var box1 = document.getElementById("box1")
    

    // 鼠标滚轮滚动触发事件
    // 这个已经全部支持了
    box1.onmousewheel = function(event){
        alter("滚动")
        event = event || window.event
        // 判断鼠标滚轮的方向 
        // event.wheelDelta ,上滚为正，下滚为负，
        // 火狐不太支持 , 火狐使用 event.detail 上 负，下正
		if  (event.wheelDelta > 0 || event.detail < 0) {
            // alert("向上滚") ,box1 变短
            box1.style.height = box1.clientHeight - 10 + 'px'
        } else {
            // alert("向下滚"),box 变长
             box1.style.height = box1.clientHeight + 10 + 'px'
        }；
        
        // 使用 addEventListener() 方法绑定响应函数，取消默认不是 retuen false
        // 这个IE8 不支持
        event.preventDefault || event.preventDefault();
        
        // 滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，这是默认行为。取消如下
        return false;

    }；
    // 为火狐绑定
    // 需要使用 DOMMouseScroll 绑定事件，该事件需要使用 addEventListener() 函数绑定
    bind(box1,"DOMMouseScroll",box.onmousewheel);
    
    
    
};

//--------------------------------------------------------------
// obj 要打绑定的时间
// eventStr 事件的字符串（不加 on）
// callback  回调函数
function bid(obj,evenStr,callback){
   if (obj.addEventListener){
       	// 大部分浏览器
        obj.addEventListener(eventStr,callback,false)
   } else {
       
     // IE8 及其以下
        obj.attchEvent("on"+eventStr,function(){
            // 匿名函数中调用回调函数
            callback().call(obj);
        });
   };
}

```

## 键盘移动 div

```js
// 会卡一下，结合定时可以改变现在的情况

window.onload = function(){
     // 定义一个变量，来表示移动的速度
    	var speed = 10;
    // 创建一个变量表示方向
    	var dir = 0;
    
    
    // 开启一个定时器，来控制 div 的移动
    setInterval(function(){
             
        // 这样设置，没有克顿
         switch(dir){
            case 37:
                // alert("向左");left 值变小
                box1.style.left = box1.offsetLeft - speed + "px";
                break;
            case 38:
                // alert("向右");
                box1.style.left = box1.offsetleft + speed + "px";
                break;
            case 39:
                //alert("向上");
                box1.style.top = box1.offsetTop - speed + "px";
                break;
             case 40:
                // alert("向下");
                box1.style.top = box1.offsetTop + speed + "px";
         }
    },30);
    
	document.onkeydown = function(event){
    event = event || window.event;
        


    // 当用户按了 ctrl 以后，速度加快
    if (event.ctrlkey) {
       speed = 50;
    } else {
        speed = 10;
    };
    // 使 dir 等于按键的值
    dir = event.keycode;

        
    };
    documet.onkeyup = function(){
      //设置方向
        dir = 0;
    };
}
```



## 判断浏览器

```js
var ua = navigator.userAgent;
if (/firefox/i.test(ua)) {
    alert("火狐浏览器")
} else if (/chrome/i.test(ua)){
    alert("谷歌浏览器")
} else if (/msie/i.test(us)) {
    alert("IE10 以下")
}

// 注意 IE 也使用 chrome 内核的版本 
if  ("window.ActiveObject" in window) {
    alert("IE11(及所有) 浏览器")
} else {
    
}
    
```

## 图片切换

```js
<body>
	<image id = "img1" src="img/q.jpg">
    <br/>
    <button id="btn01"> 开始 </button>
	<button id="btn02"> 停止 </button>
</body>




// 获取 img 标签
var img1 = document.getElementById("img1");
// 创建一个数组保存图片的路径
var imgArr = ["img/1.jpg","img/2.jpg"]
// 创建图片索引
var index = 0

// 定义一个变量，用来保存定时器
var tiemr ;
// 开启定时器，来自动切换图片
// 要解决每点击一次就开启一次函数，你开启多次，开启多个只能结束最后一个
timer = setInterval(function){
    
    // 防止开启多次导致速度过快
    // 在开启定时器之前，需要将当前元素上的其他定时器关闭
    clearInterval(timer);
    // 使索引自增
    index++;
    
    // index = index % imgArr.length
    if (index>=imgArr.length){
        index = 0
    };
    src1.src = imgArr[index];   
}


// 增加开始停止的按钮
// 为 02 绑定一个单机响应函数，单击就停止
var btn02 = document.getElemnentById("btn02");
btn02.onclick = function(){
    //点击后 ，停止自动切换，关闭定时器
    clearInterval(timer);
}

```

## 轮播图

```js
<body>   
    // 创建一个外包部的大容器
	<div id="outer">
		<ul id = "imglist">
         	<li><img src = "img/1.jpg" /></li>
         </ul> 	 
    </div>  
</body>
```

