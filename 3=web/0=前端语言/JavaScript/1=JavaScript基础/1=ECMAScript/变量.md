

## 介绍

* 变量相当于容器

    * 变量名 ： 容器上的标签
    * 变量值 ： 容器内的内容
    * 通过标签可以找到变量，以便读写它存储的值
* 命名
    * 标识符命名

## 类型

```js
参看 js 数据结构
	变量类型
    	值类型 引用类型
	数据类型
    	基本类型 对象类型
```

## 变量声明

### 声明标识符

```js
var

// 推荐使用 let 
let
	介绍
    	es6 中 let 代替 var 声明变量，就可以吧变量限制在当前的代码块中
     例子
     	let a = 111;
	使用和 var 一样，只是 let 有新的作用域规则
```

### 声明方式

```js
基础类型
	// 声明 赋值
    先声明后赋值   ：声明
    声明时赋值     ：初始化
对象类型
	// 声明 定义 赋值

声明建议
    1. 尽量不要声明变量就赋值， 要先声明，后赋值
    2. 解释器能够自动隐式声明，作为全局变量使用
    3. 数值不用引号，使用了，会默认为文本
    4. 变量声明如果不使用 var 关键字，即使在函数内部定义，他也是局部变量

    使用
        先声明 后读写
        先赋值 后运算
```



### var 声明

```js
声明
	非对象
        var variable;
   	对象
    	var variable = new Type()
先声明后赋值		
	标准形式 , 显示声明
	//指定变量类型，声明后不赋值，使用默认值
    var a 
    a = 22

声明的时赋值
	显式地标明变量的类型，在多变量同时声明时可以用到
     var a = "lili";


// -----------------------
索引类型
	1. 根据省略长度，进行推倒(见数组)
	2. 赋值填充
		1. 键值对填充(根据索引键值对确定)
        2. 值列表
        3. 访问字段名填充
```

### let 声明

```js
使用
	和 var 一样，把 var 换成 let 即可 ，只是两者的规则不同
作用
	声明一个作用域被限制在 块级中的本地变量、语句或者表达式 ，并且可选的将其初始化为一个值
    let不会在全局声明时（在最顶部的范围）创建window 对象的属性


初始化
	通过 let 声明的变量直到它们的定义被执行时才初始化 
        function do_something() {
            //  该变量处在一个自块顶部到初始化处理的“暂存死区”中。
              console.log(foo); // ReferenceError
	          console.log(typeof i); // ReferenceError
              let foo = 2;
        }
重复声明
	在相同的作用域、在相同的块中，通过 let 重新声明一个 let 变量是不允许的：
    不同的作用域或者块中可以
    // 不能在同一个作用域声明多个相同的变量
        if (x) {
          let foo;
          let foo; // SyntaxError thrown.
        }
注意
	switch 语句是一个块 ，不同 case 语句需要添加 {} 创建一个新的块作用域的词法环境 
        switch(x) {
          case 0: {
            let foo;
            break;
          }
          case 1: {
            let foo;
            break;
          }
        }

例子分析
	
```



### 类型推倒

```js
介绍
	可以不声明， 直接赋值
语法例子
	num = 10 ;
	console.log(num)  // 10

```





### 多量声明

#### 单变量声明

```js
// 先声明后赋值
	var userName;
    var userName = "lili";
```



#### 批量声明

```js
var person , carName;
var person="lili" , carName="meidi";
注意
	var a=b=c=9 ===》 var a=9; b=9;c=9
```

### 变量重复

```js
一个变量声明后，再次声明为没有赋值的，值不会丢
var carName = "233";
var carName ;    // carName 的值仍旧是 233

一个变量声明多次，并赋值不同的值，值会更新， 以最后一次的值为准
var a = 1 ;
var a = 2 ;  // 变量 a 就是 2
```

## 默认值

```js
声明但是未赋值
    // 基础类型
        Number 0
        Boolean false
        String	""
        Undefined undefined
        Null	null
未声明的变量
	会报错 undefined
```

## 变量操作

### 交换

```js
// 两个变量交换值
var s1 = "苹果1";
var s2 = "苹果2";
var temp;
temp = s1;
s1 = s2;
s2 = temp;
```



### 销毁

```js
介绍
	对于对象类的临时变量， 使用完记得销毁
语法例子
	var str = new String();
	var temp = str;
	var st = temp;
	temp = null
```



## 作用域(scop)

### 介绍

```js
变量名字起作用的范围
```



### 分类

```js
* 全局变量 local variable
* 局部变量 global variable
```

####  全局作用域

```js
介绍
	// 全局变量
	整个 script 标签、整个 js 文件

特点
	//  全局作用域中有一个全局对象 window ,表示一个浏览器窗口，由浏览器创建，可以直接使用
    创建的变量都会作为 window 对象的属性保存   ：全局变量
    创建的函数都会作为 window 对象的方法保存   ： 全局函数
    <script>
    	f = "value";
		window.f = "value"   // web 浏览器中，全局作用域对象为 window
    </script>

类型
// 全局变量
1. 函数体外 	    ： var 的变量   <script> 标签中使用 var 声明的
2. 函数体内  		： 没有使用 var 声明的变量，隐式全局变量

// 调用
    在任何位置进行调用
    在整个页面中课件，可以被自由访问
    
// 声明周期
    在网页打开时创建，除非被显示删除，否则一直存在，直到页面被关闭
    比较占用内存资源
```

#### 局部作用域

```js
介绍
	// 函数作用域
	调用函数时创建函数作用域，函数执行完毕，函数作用域销毁
    每调用一个函数就会创建一个函数作用域，他们之间相互独立

类型
    函数体内  ： var 指定的变量
    函数的    ： 参数
调用
    函数体内调用
   1. 函数作用域中的可以访问全局作用域的变量 ， 不能反过来
    	在函数内部调用一个变量，会逐级向上
   2. 调用全局变量。可以使用  window.变量名

生命周期
    自变量声明起到函数运行完毕，运行完毕就会删除

特性
    是调用对象的属性
    在函数体内使用全局变量是一种危险行为，因为优先级不同被覆盖
    
// 注意
1. 函数内没有声明变量（没有使用 var ）,该变量被设置为全局变量
  	function f(){
          carName = "222";  // 全局变量
      }
```



#### HTML作用域

```js
在 HTML 中。全局变量是 window 对象，所有数据变量都属于 window 对象
通过 var 关键词定义的全局变量属于 window 对象：
    var carName = "porsche";
    // 此处的代码可使用 window.carName
```

#### 块级作用域( let )

```js
介绍
	// es6 新增
	{} 内就是块级作用域
块状作用域
	let声明的变量只在其声明的块或子块中可用 , 作用域也是如此		
        { 
          // 在块 {} 内声明的变量无法从块外访问：
          let x = 10;
        }
循环作用域
	let i = 7;
    for (let i = 0; i < 10; i++) {
      // 循环中使用的变量使用 let 并没有重新声明循环外的变量
     // 在循环中用 let 声明了变量 i，那么只有在循环内，变量 i 才是可见的。
      // 一些语句
    }
	console.log(i)  // 7
函数作用域
	函数中声明也差不多
全局作用域
	如果在块外声明声明，那么 var 和 let 也很相似
html 的作用域
	let 关键词定义的全局变量不属于 window 对象：
        let carName = "porsche";
        // 此处的代码不可使用 window.carName
```

### 作用域链

```js
内部函数访问外部函数的变量， 采取的是链式查找的方式决定取哪个值，这种结构成为作用域链，就近原则
var num = 10;
function fn(){
    var num = 20;
    function func(){
        console.log(num) // 20
    }
}
```



### 优先级

```js
同名的参数
    局部变量  > 参数变量 > 全局变量 > window 对象的变量或函数
    
// 形参相当于声明变量
1. 函数内部定义的变量，会在该作用域会覆盖同名全局变量
```

###  变量污染 - 原型对象

```js
变量污染 
	全局变量在全局作用域内可见，有污染性

避免
1. 脚本中创建一个全局变量，作为当前应用的唯一接口，
	然后通过对象直接量的形式包含所有应用程序变量
var MApp = {}				// 定义App访问接口
MyApp.name = {"id":"应用程序"} // App 配置信息
MyApp.worker={				 // App 配置信息
	num:123, // 计数器属性
    sub:{name:"sub_id"}      // App应用分支
}





2. 使用函数体封装应用程序，
(function(window) {
    var MApp = {}				// 定义App访问接口
    MyApp.name = {"id":"应用程序"}; // App 配置信息
    MyApp.worker={				 // App 配置信息
        num:123, // 计数器属性
        sub:{name:"sub_id"}      // App应用分支
	};
    window.MyApp;  // 对外开发应用程序接口
})(window)	
```

## 预解析

### 介绍

```js
注意
	js 代码是由浏览器的 js 解释器来执行的
    js 解析器运行的时候，分为两步： 预解析、 执行
    
过程
	// js 中是先声明后赋值，即先编译后操作 ， 即 只提升声明，而非初始化。
    1. 预编译期  ： 
    	js 引擎会把 js 里面所有 var function .声明的变量，提升到当前作用域的最前面
    		变量预解析（变量提升）：变量声明提升，不提升赋值操作
             函数预解析（函数提升）：
    2.  执行期   ： 
    	按照从上到下顺序，执行代码
        	




变量提升 Hoisting
	// （提升到当前脚本或当前函数的顶部
	JavaScript 将所有声明提升到当前作用域顶部的默认行为
原理




函数声明提前
	函数声明形式创建的函数 function 函数(){} 会在所有的代码执行在被创建，但是没有赋值
    
函数内部 var 函数内部 var 声明的变量
	不管在什么位置，变量声明都会被提升到函数体头部
    

```



### 变量提升( var )

```js
介绍
	使用 var 关键字声明的变量，会在所有代码之前被声明 ，在声明变量之前使用它    
        console.log(a) // a :undefined
        var a = 123;
        // 等价于
        var a;
        console.log(a)
        a= 123
 


2.局部变量提升
	函数内部 var 声明的变量，不管在什么位置，变量声明都会被提升到函数体头部
    function f(x) {
        if(x>10){
            var a = x - 1;
        };
    };

	等价于
    function f(x) {
        var a;
        if (x>10) {
            a = x - 1
        }
    }


注意
	没有用 var 的则不被提前
    
    
    
```



### 函数提升

```js
介绍
	只有 function .关键字声明的函数，才会被提前，其他使用均未被提前
提升
	函数声明语句会被提前到外部脚本或外部函数作用域的顶部
    这种方式声明函数，可以被在他定义之前的代码所调用
例子

1. 函数声明提前
	sum(1, 2)
	function sum(a,b){ // 在所有的代码执行在被创建，但是没有定义函数体
        return a+b;
    }

    var f = function(){}; // 匿名函数，不存在函数提升，存在变量提升
```

## 内存管理

*   内存声明周期
    *   分配小内存空间，得到它的使用权
    *   存储数据，可以反复进行操作
    *   释放小内存空间
*   释放内存
    *   对象     ： 设置 null 释放 ，随后由垃圾回收器回收
    *   局部变量  ： 在函数结束自动释放

### 回收机制(GC)

```js
垃圾
	当一个对象没有任何的对象或属性进行引用，我们将无法操作该对象
    	var obj = new Object();
    	obj = null;   //  obj 无法使用，占用内存
回收机制
	js 中有在自动回收机制，会自动从内存中销毁，也不需要进行垃圾回收操作
    我们要做的就是把对象设置为 null 即可，一段时间即可自动清理

1. 标记清除

2. 引用计数
```



### this 指向

```js
// 函数本质上都是通过某个对象来进行调用的，没有指定默认就是 window
函数内部都有一个变量 this
	this 为调用函数的当前对象
// 一般情况下， this 的最终指向的是那个调用它的对象
1. 全局作用域、普通函数中 this 指向全局对象 window 
// 定时器 {} 里面的 this 指向 window

2. 方法调用中谁调用 this 指向谁
btn.addEventListener('click', function(){ console.log(this)}) // btn
o.say() //对象 o
3. 构造函数中 this 指向构造函数的实例
function fun() { console.log(this) }
var f = new fun();   // 实例 f
```






## Null

```js
可以将变量的值设置为 null 来清空变量
person = null;
```

