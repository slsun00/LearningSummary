# 模块化

### 概述

```js
node 模块化
	node应用由模块组成，采用的commonjs模块规范

es5
	没有原生支持模块化，我们只能通过script标签引入js文件来实现模块化
     <script src="jquery.js"></script>

commonJS 规范
	//  require/exports，让javascript可以实现模块化,
	每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见
es6
	改进了模块化标准为用 import/export (require/exports 被替换)

// 模块加载器
amd
cmd
```

### 区别

```java
CommonJS起初为了解决，服务端的代码，把代码全都挤在一个文件内，从而导致文件复杂臃肿的，浏览器加载
该JS文件，产生卡死；全局作用域污染等问题，而应运而生的模块化开发理念。而且其加载模块的方式属于同步的，
需要遵循“先加载，停顿，再执行“的顺序来执行代码，因此很受网速限制。

AMD规范，虽然延续了CommonJS的理念，模块化开发，但不同的是，AMD遵循的是异步加载模块的规范。其加载依赖模块方式是属于依赖前置，即先加载需要的依赖模块，再执行回调函数，大大提高了效率。

CMD规范，是由国内前端大神，玉伯，编写的一个js库 --- sea.js，在推过过程，提出的一个基于CommonJS的新
规范---CMD。该规范与AMD类似，写法也类似。但不同的是，CMD遵循着依赖后置的理念。即AMD是一次性加载完

```



# commonJS

### 介绍

```java
历史
    模块化标准规范，即 require/exports，让javascript可以实现模块化,
	2014年已经被终止的项目
概述
	 在node中一个js文件就是一个模块       
特点
	1. 所有代码都运行在模块作用域，不会污染全局作用域。
         默认情况下在js文件中编写的代码，都是运行在一个独立的函数中，而不是全局作用域
        所以模块中的变量和函数，外部的模块无法访问
	2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了
        要想让模块再次运行，必须清除缓存
	3. 模块加载的顺序，按照其在代码中出现的顺序。        
```

### 导出 -- exports

```java
介绍
    module
    	有一个重要属性： exports
    exports
    	exports 是对 module.exports 的引用
    	可以认为，在每个模块顶部有代码： var exports = module.exports
    关系
    	// 这两个不好区分，那就放弃 exports，只用 module.exports 就好
    	一个模块的对外接口，就是一个单一的值，不能使用exports输出，必须使用 module.exports输出
     注意
    	不能直接给exports赋值,否则就相当于切断了 exports 和module.exports 的关系

    
    
module： {
含义： {
    module变量代表当前模块。这个变量是一个对象}
属性： {
    exports属性 ： 对外的接口，其他文件加载该模块，实际上就是读取module.exports变量 }  
语法： {
    // 使用 . 或者直接赋值， （地址引用）
        module.exports.属性 = 属性值;
        module.exports.方法 = 函数;
        module.exports = {}/[] 等;  // 直接使用
例子：{

    参看使用例子

}   

exports{
语法： {
	只能使用 . 的方式来向外部暴露内部变量， （值引用）
    例子：
        exports.属性 = 属性值;
        exports.方法 = 函数;
}

     
     
// 源文件导出变量和函数
// 在被调用的源文件中应该设置如下(a 调用 b 中的函数或者方法)

```

### 导入 - require

```js
require方法 {
含义： {
    用于加载模块文件，相当于读入并执行一个js文件，然后返回该模块的exports对象
    没有发现指定模块，则就会报错。 
语法： {
    const 变量 = require("模块的标识"); 
    // 变量就表示引入的模块的 module.exports 对象，该对象是一个 map 值，
    console.log(变量.x)              // 调用模块中的变量、函数  
机制： {
    加载机制，输入的是被输出值的拷贝。
    也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。
}


模块的标识 {
含义：{
    模块(要加载的 js 文件) 的路径
作用：{
    node通过模块的标识来寻找模块的
分类： {
	预置模块(全局模块)
    	由 node 引擎提供的模块 , 直接使用模块的名字对其进行引入
            var fs = require("fs");
    自定义模块(文件模块)
    	用户自定义的模块， 标识就是文件路径 ：绝对路径、相对路径(必须以./或 ../开头)
 		 require("./route.js")
// =============================================================    
加载规则： {
 “/”开头： 加载的是一个位于绝对路径的模块文件
 	require('/home/marco/foo.js')将加载/home/marco/foo.js
“./”开头： 加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件
	require('./circle')将加载当前脚本同一目录的circle.js。
其他：
	1. 加载的是一个默认提供的核心模块（位于Node的系统安装目录中）
    2. 一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。
精确加载
	如果想得到require命令加载的确切文件名，使用require.resolve()方法。
未找到
	Node会尝试为文件名添加.js、.json、.node后，再去搜索
    .js件会以文本格式的JavaScript脚本文件解析，
    .json文件会以JSON格式的文本文件解析，
    .node文件会以编译后的二进制文件解析
}   
    
    
加载例子
/home/user/projects/foo.js执行了require('bar.js')
    // node 的执行路径
    /usr/local/lib/node/bar.js

    /home/user/projects/node_modules/bar.js

    /home/user/node_modules/bar.js

    /home/node_modules/bar.js

    /node_modules/bar.js


```

### 使用例子

```JS
// 概述
	// 操作的对象，是一个 map , 是一个键值对对象
	exports 导出的是一个对象
    require 导入的也是一个对象

// 普通
example.js
	exports.name = 'tom';
	exports.age = 50;
demo.js
	var test1 = require('./example.js')
分析
	test1 就是 example.js 导出的 exports 对象，该对象有两个属性 name age
    
// 简写
example.js
	let name = 'tom';
	let age = 50;
	// exports 有选择导出
	module.exports = {name:name, age:age}
	// es6的对象简写，key 和 value 一致，可以只写一个
	module.exports = {name, age}
// es6
	module.exports = app => {} // function(app) {}

注意
	module.exports = {}   // a{}
	let a = require('...')
	====================================
	module.exports = []  // a[]
	let a = require('...') 
```





### 原理

```js
node 在执行模块中的代码的时候，它会添加
最顶部 ： function (exports,require,module,__filename,__dirname){
最底部 ： }
实质   ： 模块中的代码都是包装在一个函数中执行，并在在函数执行的时候，同时传递了5个实参

exports     该对象用来将变量或函数宝楼道外部
require	    函数 ，用来引入外部的模块
module		
	- module  代表当前模板本身
    - exports  其实就是 module 的属性
__filename
	当前模块的路径
__dirname
	当前模块所以在文件夹的路径
```











# es6模块化

## 模块化文件

```js
.mjs 模块化文件
	1. V8推荐了这样的做法
好处
    比较清晰，这可以指出哪些文件是模块，哪些是常规的 JavaScript。
    这能保证你的模块可以被运行时环境和构建工具识别，比如  Node.js 和 Babel。

.js
	目前仍旧使用 .js 后缀的文件，方便移植
    
```



## 模块文件注意

*   模块自动使用严格模式
*   加载一个模块脚本时不需要使用 `defer` 属性 (see [`` attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#Attributes)) 模块会自动延迟加载
*   模块功能导入到单独的脚本文件的范围 — 他们无法在全局获得。因此，你只能在导入这些功能的脚本文件中使用他们，你也无法通过Javascript console 中获取到他们

## expert - 导出

### 介绍

*   用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 [`import`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import) 语句使用它们

*   无论您是否声明，导出的模块都处于[`严格模式`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)。
*    export语句不能用在嵌入式脚本中

### 导出

#### 方式介绍

```js
// 方式
    1. 命名导出 (每个模块包含任意数量)  --- 多接口导出
		导出文件中是什么名字 ，导入文件中也要使用什么名字
    2. 默认导出 (每个模块只能导出(使用)一个)  --- 默认导出
		模块中的功能我们不希望命名，可以让导入者自己命名
//注意
	在每一个模块中定义多个命名导出，但是只允许有一个默认导出
    多接口导出中也有只导出一个接口
   
```



#### 默认导出

```js
// 导出单个特性作为默认值
// nameN 要导出的标识符（以便其他脚本通过 import 语句进行导入）
export default expression;
export default function (…) { … } // also class, function*
export default function name1(…) { … } // also class, function*

// 导出事先定义的特性作为默认值
export { name1 as default, … };

```

#### 模块集合导出

```js
// 创建单个模块，集中多个模块的多个导出
// 为了使模块导入变得可用，在一个父模块中“导入/导出”这些不同模块也是可行的

export * from …; // does not set the default export
export * as name1 from …; // Draft ECMAScript® 2O21
export { name1, name2, …, nameN } from …;
export { import1 as name1, import2 as name2, …, nameN } from …;

-------------------------------------------------------------
export { default as DefaultExport } from 'bar.js'; // 有效
	import DefaultExport from 'bar.js'; 
export DefaultExport from 'bar.js'; // 无效的


// 例子
	模块重定向
```

#### 多接口导出  -- 命名导出

```js
// 导出单个特性（可以导出var，let，const,function,class）
// 没有大括号，因为每个模块只允许有一个默认导出 （说的是default）
export let name1, name2, …, nameN; // also var, const
export let name1 = …, name2 = …, …, nameN; // also var, const
export function FunctionName(){...}
export class ClassName {...}
// 导出列表
export { name1, name2, …, nameN };
// 导出事先定义的特性
 export { myfunction }
 
 
 // 注意
	在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称
```

#### 重命名导出

```js
// 重命名导出
export { 
	variable1 as name1, 
    variable2 as name2, 
    …, 
    nameN 
};
```



#### 解构导出

```js
// 解构导出并重命名
export const { name1, name2: bar } = o;
```

### 例子

*   模块重定向

    ```js
    // 层次结构	
        childModule1.js: 导出 myFunction 和 myVariable
        childModule2.js: 导出 myClass
        parentModule.js: 作为聚合器（不做其他事情）
        顶层模块：调用 parentModule.js 的导出项
    // childModule1.js 中
        let myFunction = ...; // assign something useful to myFunction
        let myVariable = ...; // assign something useful to myVariable
        export {myFunction, myVariable};
    // childModule2.js 中
        let myClass = ...; // assign something useful to myClass
        export myClass;
    // parentModule.js 中
    // 仅仅聚合 childModule1 和 childModule2 中的导出, 以重新导出他们
        export { myFunction, myVariable } from 'childModule1.js';
        export { myClass } from 'childModule2.js'
    
    // 顶层模块中
    // 我们可以从单个模块调用所有导出，因为 parentModule 事先已经将他们“收集”/“打包”到一起
    	import { myFunction, myVariable, myClass } from 'parentModule.js'
    
    ```

### 注意

```js

    在你的 HTML 中需要包含 type="module" 的 <script> 元素这样的脚本，以便它被识别为模块并正确处理
    不能通过 file:// URL 运行 JS 模块 — 这将导致 CORS 错误。你需要通过 HTTP 服务器运行。

```

## import - 导入

### 介绍

*   静态的 import 语句用于导入另一个模块导出的绑定
    *   初始化加载依赖项的最优选择
    *   容易从代码静态分析工具和 [tree shaking](https://developer.mozilla.org/zh-CN/docs/Glossary/Tree_shaking) 中受益。
    *   标准用法的import导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）
*   动态的 inport() 类似函数
    *   照一定的条件或者按需加载模块的时候

### 注意

*   import 的模块都是运行在严格模式下的
*   浏览器中， import 语句只能在声明了 type="moudule" 的 script标签总使用 ，动态的 import() 不需要 依赖 moudule 的 script 标签
*   script 标签中使用 bomodule 属性，可以确保向后兼容

### 导入

#### 描述

```js



export, exportN  
	被导入模块的导出接口的名称。
    就是导入模块中，接口的 nameN
alias, aliasN    
	将引用指定的导入的名称

<script type="module" src="main.mjs"></script>
import ...    
```



#### 导入默认值

```js

/* 
 defaultExport  
 	导入模块的默认导出接口的引用名
  module-name  
	包含目标模块的.js文件的相对或绝对路径名 ,
	只允许单引号和双引号的字符串
  
*/

import defaultExport from "module-name";
import defaultExport, { export [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";



1. 可以使用任何名称导入默认导出
    let k;
     export default k = 12; 
    // 由于 k 是默认导出，所以可以自由使用 import m 替代 import k
	//  等价于 import {default as m} from './test';
    import m from './test'; 

2. 和命名空间导入或命名导入一起使用
	// default导入必须首先声明。
	import myDefault, * as myModule from '/modules/my-module.js   // 命名空间导入
	import myDefault, {foo, bar} from '/modules/my-module.js';  // 命名导入
	
```



#### 导入整个模块的内容

```js
// 使用 * 
// 获取module.mjs中所有可用的导出，并使它们可以作为对象模块（name）的成员使用，
// 从而有效地为其提供自己的命名空间
	import * as name from '/modules/module.mjs';
	// 调用 ,访问导出接口意味着使用模块名称（在本例为“name”）作为命名空间
	name.sum()
```



#### 导入多个接口 - 命名空间导入

```js
// {} 中至少有一个接口，接口可以使用别名，也可以不使用别名
import { export1 as name1 ,export2 as name2, ... } from "module-name";

// 给定一个名为 foo 的对象或值，它已经从模块my-module导出, foo 插入当前作用域。
import {foo, bar} from '/modules/my-module.js';
```

#### 导入带别名( 重命名 )的接口 - 命名导入

```js
// 使用关键字 as  ，取别名即重命名
import {
    reallyReallyLongModuleExportName as shortName ,
     anotherLongModuleName as short
}
  from '/modules/my-module.js';
```

#### 副作用导入

```js
介绍
	不导入模块中的任何内容(接口) , 运行模块中的全局变量
代码
	import '/modules/my-module.js';
注意
	原则上来说，模块不能有副作用，但是很多时候，无法控制你所依赖的模块内容
```

### 动态 import

*   注意

    ```js
    不要滥用动态导入 , 只有在必要情况下采用
    ```

*   使用场景

    ```js
    1. 当静态导入的模块很明显降低了代码的加载速度且被使用的可能性很低
    2. 当静态导入的模块很明显占用大量系统内存且被使用的可能性比较低
    3. 当被导入的模块 ， 在加载的时候，并不存在，需要异步获取
    4.当导入模块的说明符，需要动态构建，（静态导入只能使用静态说明符）
    5. 当被导入的模块使用副作用，这些作用只有在触发某些条件需要时
    ```

*   语法

    ```js
    // 像调用函数一样来动态导入模块，这样将会返回一个 promise
    import('/modules/my-module.js')
    	.then((module)=>{
        // do something with module
    })
    
    // 支持 await 关键字
    let module = await import('module/my-modules.js')
    ```

    

## 故障

```js
1. 在前面已经提到了，在这里再重申一次： .mjs 后缀的文件需要以 MIME-type 为 javascript/esm 来加载(或者其他的JavaScript 兼容的 MIME-type ，比如 application/javascript), 否则，你会一个严格的 MIME 类型检查错误，像是这样的 "The server responded with a non-JavaScript MIME type".
2. 如果你尝试用本地文件加载HTML 文件 (i.e. with a file:// URL), 由于JavaScript 模块的安全性要求，你会遇到CORS 错误。你需要通过服务器来做你的测试。GitHub pages is ideal as it also serves .mjs files with the correct MIME type.
3. 因为.mjs 是一个相当新的文件后缀, 一些操作系统可能无法识别，或者尝试把它替换成别的。比如，我们发现macOS悄悄地该我们的 .mjs 后缀的文件后面添加上 .js  然后自动隐藏这个后缀。所以我们的文件实际上都是 x.mjs.js. 当我们关闭自动隐藏文件后缀名，让它去接受认可 .mjs。问题解决。

```

# @import

```css
/* 这个是css 的语句，不是 js 的，但是有用，就写到这里了*/
格式
	<style> @import语法 </style>
语法
      // 当使用url(url)的方式时，包住路径的引号可有可无；
      // 当直接使用url时，包住路径的引号必须保留。
      @import url("global.css");
	  @import url(global.css);
	  @import "global.css";

作用
	指定导入的外部样式表及目标媒体。 
```



# 总结文章

```java
commonjs
    https://www.jianshu.com/p/dd08f4095a49
```

