## 函数

*   什么是函数
    
    ```js
    代码复用，封装一个功能 ， 当函数被调用时被执行时可重复使用的代码块
    js 函数由事件驱动的
    ```
    
*   为什么使用

    ```js
    提高代码复用
    便于阅读交流
    ```
    
*   函数即对象
    
    *   对象就有属性和方法，所以函数也有属性
    
*   命名

    ```js
    标识符命名
    
    1. 通常是动词或者以动词为前缀的词组
    2. 首字母小写，采用小驼峰或者下划线
    ```

## 相关名词

```js
函数
	包括在花括号内的代码块
关键词
	function  必须要小写
花括号
	{} 必须的
    
形参
	函数定义的时候使用的参数，接收调用该函数时传递的参数
实参
	调用函数时传递给函数的实际参数
    
函数

方法
	函数被挂载在一个对象上，作为对象的一个属性，就成该函数是对象的方法
    
注意
	函数不是一个可执行语句，所以不以分号结束
    函数内部可以调用全局变量，但是外部不能调用函数内部的变量
```



## 声明

### 构造函数

```js
动态匿名方法 ， 这种方式很少使用
// 将要封装的代码以字符串的形式 传递给构造函数
// 在函数调用的时候执行
var 函数名 = new Function([虚参列表]，"函数体")；
var myfunction = new Function("a","b","return a + b ");
```

### 关键字声明

```js
// 静态方法 function 命令
function 函数名 ([形参列表]){
    函数体
}
```

### 函数表达式 - 匿名函数

```js
// 函数表达式存在一个变量中 ，变量也可以作为一个函数适用
// 实际上就是匿名函数
// 这个是一个执行语句 ， 所以要分号结尾
var 函数名 = function(x){
    函数体；
}；
```

### 注意

```js
1. 多次定义同一个函数，后面的定义声明会覆盖前面的
2. 不能在调条件语句中声明函数
```

## 参数

### 概述

```js
形参
实参

1. 函数中指定一个或者多个形参，多个形参之间需要用 ， 隔开，
2. 声明形参就相当于在函数内部声明了对应的变量 ，但不赋值
3. 实参可以是任何类型的数值：对象、函数、
4. 函数每次调用的时候，会传递两个隐含的数组
```


### 参数规则

```js
// JavaScript 函数不对参数的值进行任何的检查，它不关注到底有多少个参数、参数的类型是什么
1. 调用函数时，解析器也不会检查实参的数量
	实参 < 形参 : 剩余的形参           默认参数：undefined
	实参 > 形参 : 多余的实参被忽略      通过 argumenrts 调用

2. 函数定义时，没有指定数据类型
3. 调用函数时，解析器不会检查实参的数量、参数的类型，所以有可能需要对参数类型检查


3. 通过 arguments 对象访问参数数组
4. 参数始终按值传递
	基本类型 传值  值
    引用类型  传址  对象
```

### 显式参数

```js 
函数显式参数在函数定义的时候给出
function Name (parameter1,parameter2){
    // code to be executed
}
```

### arguments 

*   功能

    *   存放实参的参数列表 ：实参都被放在这个类数组类型，通过索引获取操作数据

    *   调用函数，所传递的实参都会存在 arguments 中保存

    *   补定义形参，可以通过 arguments 来使用实参

        ```js
        arguments[0]  // 表示第一个实参
        arguments[1]  // 表示第二个实参
        ....
        ```

    *   可变的实参类表：实参对象

*   特性

    *   仅能在函数体内使用
    *   带有下标属性，并不是真正的数组，是一个实参对象，  
    *   函数声明时自动初始化

*   属性

    ```js
    length   获取函数实参的长度
    callee   返回当前正在指向的函数
    caler    返回调用当前正在执行函数的函数名
    ```

*   使用

    ```go
    function go(x) {
        // 通过数字下标来访问传入函数的实际参数值
        // 不用非要通过名字得到实参
        console.log(arguments[0]);   // 1
        console.log(arguments[1]); 	// 2
        
        // 包含元素的个数
        console.log(arguments.length)  // 2
        
        // 通过 arguments[] 修改 实参的值
        // 当下面的调用改成 go(1) :console.log(x)  1
        arguments[0] = null;
        console.log(x);    // null
    }
    
    go(1,2)
    // 1
    // 2
    
    
    ```

### 对象属性做实参

```js
当一个函数包含超过三个形参时，记住参数的顺序比较难，可以通过 （名/值）对的形式传入参数，这样就不用管参数的顺序了


var obj = {
    name: "zhagnsan",
    age:18,
    gender: "男"
    
}
function person(obj) {
    console.log("我是"+o.name+",年芳"+obj.age+",性别是"+obj.gender)
}
```



### 参数传递

*   概述

    ```js
    js 在调用函数的时候，传递变量参数时
    	理解1 ：都是值（基本/地址值）传递
    	理解2 ：可能是值传递，也可能是引用传递（地址值）
    ```

    

*   通过值传递参数

    ```js
    // 如果函数修改参数的值（整体），将不会修改参数的初始值(在函数外定义)
    总结： 函数传值只是将参数的值传入函数，函数会另外配置内保存参数值，并不会改变原参数的值
    
    var x = 1;
    function myFunction(x) {
        x++;
        console.log(x)  
    }
    
    myFunction(x); //2
    console.log(x); // 1
    ```

*   通过对象传递参数

    ```js
    // 函数内部修改对象的属性就会修改其初始值(修改的是引用对象的值)
        修改对象属性可作用域函数外部(全局变量)
    
    var obj = {x:1}
    function myFunction(obj) {
        obj.x++;     // 函数外部定义的 obj 也会被修改
        console.log(obj.x)  
    }
    
    myfunction(x)		// 2
    console.log(obj.x)   // 2
    ```
    

## 返回值

```js
// 使用 return 来设置函数的返回值, return 后的值作为函数的执行结果返回
// 返回值的类型是任意数据类型。对象、函数、等等
语法
	return 值；
例子
	function sum(a,b){
        var res = a + b;
        return res;
        console.log(res)
    }
	var res = sum(1, 3)
1. return 后面的语句不会执行 ： 上面的 console 语句不会执行 ，相当于跳出当前函数
2. return 后没有值或者不写 ， 函数都是返回 undefined
```



## 调用形式

### 介绍

```js
函数调用  test()
方法调用  obj.test()
new调用	   new test()
 

绑定事件函数  btn.onclick = function(){};
定时器函数	setInterval(function() {},1000)  // 每隔一秒自动调用一次

临时调用      test.call/apply(obj)  临时让 test 成为 obj 的方法进行调用
	var obj = {}
    var function test2(){}
	// 调用 ，实现 obj.test2() 
	test2.call(obj)

// this 指向 , 一般指向调用者 ，参看 函数高级 this 指向
```

### 作为函数

```js
函数名（参数列表）{
    函数体
};

// 调用
函数名（实参列表）;
```

### 作为方法

```js
函数定义为对象的方法

var myObj = {
    Name: "lili",
    age: function() {   // 方法有一个函数，函数属于对象，myObj 就是函数持有者
        return 18
    }
}
myObj.age(); // 返回18

函数作为方法调用，会使 this 的值称为对象本身
```

### 作为对象调用

```js
介绍
	js 中有函数也是一个对象
    tyoeOf  类型为 function, 有属性和方法
语法例子
	JavaScript 中，函数时对象，对象有自己的方法和属性
	call() 、  apply()  是预定义的函数方法，用于调用函数，第一个参数必须是对象本身
    
    function myFunction(a,b) {
        return a + b;
    }
	myFunction.call(myObject,10,2)  // 返回 12  myObject是什么 ???????
```



## 调用位置

### 作为值

```js
函数可作为一个值，赋值给变量
function f() {};
var a = f;
```



### 函数内

```js
函数体内调用函数体

function 函数名() {
    代码
    函数名();
}

语法例子
function f1() {
    f2();  // f2
}
function f2() {
    console.log("f2")
}
```

### html 中使用

```js
JavaScript 中有 4 中调用方式，每种方式的不同在于 this 的初始化
```

#### script 标签中

```js
<head>
    <script>
        function myFunction(a，b) {
            return a*b ;
        }
        myFunction(3,4)  // 12
    </script>
 </head>


此函数不属于任何对象，默认是全局变量，
Html  	中默认的全局对象是 html 页面本身，所以函数属于 html 页面
浏览器   中页面对象（全局变量）是浏览器窗口，
	所以上述函数会在自动变成 window 对象的函数
		即 myFunction 和 window.myFunction 是一样的
// 全局的标识符容易造成命名冲突的 bug

当函数没有被自身调用， this 的值就会变成 全局对象，
（使用 window 对象作为一个变量容易造成程序崩溃）
```

#### 在连接中调用

```js
<a href="javascript:函数名()"> 描述文字 </a>
```

#### 在事件中调用

```js
<button click= "函数名()">
<script>
btn.onclick = function(){};  ????
<script>

```





## 特殊函数

### 构造函数

```js
// 对象
```

### 匿名函数

```js
// 就是函数声明的时候没有指定函数名
var a = function(){}
```

### 立即执行函数 IIFE

*   概述
    *   Immediately-Invoked Function Express
*   适用
    *   等价于匿名函数自调用
    *   会立马调用
*   目的
    *   不必为函数命名，避免污染全局变量
    *   是 IIFE内部形成的一个单独的作用域，可以封装一些外部无法读取的私有变量
    *   隐藏实现
    *   编写 js 模块

```js
// 表达式后面跟上 （） 就会自动调用
写法
	// 最后一对 （） 表示调用
	方式一： (function(形参){...})(实参);
	方式二： (function(形参){...}(实参));
function 左边的括号是必须的，否则就被解析为函数生声明语句

(function(){
    statement
})()；

!function(){}()
~function(){}()
-function(){}()
+function(){}()

------------------------------------

function sum(a,b){
    var c = a + b;
}

sum(1,2)();  
// 等价于 
a =sum(1,2)
a()
```

### 回调函数

```js
什么是回调函数
	1. 你定义的函数
    2. 你没有调用
    3. 但是最终执行了
    
 常见的回调函数
 	dom 事件的回调函数
    定时器回调函数
    ajax 请求回调函数
    声明周期回调函数
```



### 高阶函数

### 介绍

```js
高阶函数
	对其他函数进行操作的函数，他可以接收函数作为参数或者将函数作为返回值输出
    函数是一种数据类型，所以他可以作为参数、返回值
作为参数
	// 回调函数
	function fn(callback) {
        callback&&callback() // 短路运算，有就调用
    }
作为返回值
	function fn() {
        return function(){};
    }
```

### 闭包

*   介绍

    ```js
    // *   函数可以嵌套在其他函数中定义
    // *   闭包就是一个函数
    function fn() {
        var num = 10
        function fun() {
            console.log(num)
        }
    }
    
    1. func 可以访问 fn 中的变量
    2. fn 外面的的作用域可以访问 fn 内部的局部变量
    ```

*   用处

    *   可以读取另一个函数作用域中的内部变量 , 延伸了局部变量的作用范围 
    *   可以让这些变量始终保持在内存中，可以是变量的诞生环境一直存在
    *   封装对象的私有属性和私有方法

*   缺点

    *   函数的变量都会保存在内存中，内存消耗大。
        *   解决 ： 在退出函数之前，将不使用的局部变量清除
    *   尽量不要随便改变父函数内部变量的值

```js
// 私有变量可以用到闭包
function f(a) {
    return function(){
        return a++;
    };
}
var c = f(1);
console.log(c());  // 1
console.log(c());   // 2


function add() {
    var count = 0;
    function plus() {count += 1;}
    plus();
    return counter;
}

add();   // 1
add();   // 2
add();   // 3

闭包可以访问上一层函数作用域里变量函数，即使上一层函数已经关闭
```



## 函数高级

### 原型

```js
函数属性 prototype
	1. 每一个函数都有一个 prototype 属性，他都默认指向一个 object 空对象（即：原型对象）
	2. 原型对象都有一个属性 constructor ,它指向函数对象
		// 你可以理解成原型对象是父对象 。constructor 指向子对象
给原型对象添加属性（一般都是方法）
	函数所有的实例对象自动拥有原型中的属性（方法）
 

prototype 属性

	1.创建的函数每执行一次，解析器都会向函数中添加一个属性 prototype,
     2.指向一个对象的引用，这个对象叫做 原型对象（prototype object）
	 函数调用
     	作为普通函数调用，该属性没有作用
        作为构造函数调用，创建的实例，都会有一个隐含的属性，指向该构造函数的原型对象，
        	访问 ： 实例对象.__proto__   // 所有同一个类的实例对象，拥有同一个原型对象

	原型对象就像父对象，所有的实例对象都继承它的属性（不一定继承完全：子有父必有，父有子未必有）
        1. 我们在访问 实例对象(子类)的时候，
            如果没有找不到相关属性，就到原型(父类)里面去找,找到就返回
            找不到，就找原型(父类)的原型(父类)里面去找
            ....
            一直找到 Object 类型，到这里也找不到，就返回 undefined 

        2. 通过实例对象(子类)修改原型对象(父类)属性，所有的实例对象(子类)都可以访问到这个修改后的值
        	实例.protorype.属性名 = 属性值
	    3. 创建构造函数的时候，可以将共有的属性和方法，统一添加到构造函数的原型对象中
        	只对相关的实例对象起作用  ：《相当于静态变量》
         4. 原型对象还有原型对象，
    
  function MyClass(){	  
  }
MyClass.prototype.test = "666" ;   // 给 myClass 的原型对象添加字段 test = name
```

### 提升

*   跟变量的被提前一样，函数声明语句会被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明额函数，可以被在他定义之前的代码所调用

    ```js
    1.函数声明提前
    	函数声明形式创建的函数 function 函数(){} 会在所有的代码执行在被创建，但是没有赋值，可以在函数定以前调用
        f();
        var f = function(){};
        //等价于
        var f;
        f();
        f = function(){};
    	定义的时候，f 只是被声明了，并没有被赋值，等于 undefined ,会报错
    
    2. 以表达式定义的函数并没有被提前,
        var sum2 = function(){}   // 没有提前
    
    
    3.局部变量提升
    	函数内部 var 声明的变量，不管在什么位置，变量声明都会被提升到函数体头部
        function f(x) {
            if(x>10){
                var a = x - 1;
            };
        };
    
    	等价于
        function f(x) {
            var a;
            if (x>10) {
                a = x - 1
            }
        }
    ```

### this 指向

*   介绍

    ```js
    // 每一个新函数根据它是被如何调用的来定义这个函数的this值：  
    this 执行一个对象，这个对象我们称为函数执行的上下文对象
        以函数调用，对象是 window
        以方法(对象方法)调用，对象就是调用这个方法的对象
        以构造函数调用， this 就是新创建的那个对象
        
    // 其他 ，一般直接指向调用者
    	直接调用	 window
        对象调用	 方法所属对象
        new调用	  实例对象，原型对象里面的方法也是指向实例对象
        绑定事件函数 绑定事件对象
        定时器函数	window
        立即函数	window
        
    
    // 注意
    	This被证明是令人厌烦的面向对象风格的编程
    ```

*   指向问题解决

    ```js
    1. ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题
        function Person() {
          var that = this;
          that.age = 0;
    2. 创建绑定函数，以便将预先分配的this值传递到绑定的目标函数
          setInterval(function growUp() {
            // 回调引用的是`that`变量, 其值是预期的对象.
            that.age++;
          }, 1000);
        }
    ```

    

```js

// 问题解决

    
es6
	 在严格模式下的函数调用下，this指向undefined
     箭头函数 this 指向，参看箭头函数
     
```





## 指针标识

### 介绍

```js
this		指向当前操作对象
callee		指向参数集合所属函数
protetype	 指向函数附带的原型对象
constructor	 指向创建该对象的构造函数
```

## 函数对象

*   属性
*   方法

## 零星

*   字符串转语句

    ```js
    将字符串当成语句执行，eval 没有自己的作用域，都在当前的作用域内执行
    eval("var a = 1")
    
    1.如果使用严格模式，eval 内部声明的变量，不会影响到外部作用域
    (function(){
        'use strict';
        eval('var a = 1 ')
        console.log(a) // a 没有定义
    })
    ```

    