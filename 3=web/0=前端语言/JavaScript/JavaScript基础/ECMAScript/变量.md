

## 动态语言

```js
JavaScript 是动态类型的语言
变量没有类型限制，可以随时赋予任何值
相同的变量可以用在不同的类型
    var x;				// x 为 undefined
    var x = 5;			// x 此时为 number
    var x = "ss";		// x 此时为 string

JavaScript 是一种弱类型语言，变量类型的规范比较松散
	类型分类不严谨、不明确、带来使用的随意性
	变量声明不要求指定类型
	使用过程不严格，可以根据需要自动转换变量类型
	变量的转换和类型检查没有一套统一、规范的方法，导致开发效率低
```



## 介绍

* 变量相当于容器

    * 变量名 ： 容器上的标签
    * 变量值 ： 容器内的内容
    * 通过标签可以找到变量，以便读写它存储的值

## 变量命名

```js 
标识符命名
```



## 类型

```js
参看 js 数据结构
	变量类型
    	值类型 引用类型
	数据类型
    	基本类型 对象类型
```

## 声明标识符

```js
var

// 推荐使用 let 
let
	介绍
    	es6 中 let 代替 var 声明变量，就可以吧变量限制在当前的代码块中
     例子
     	let a = 111;
	使用和 var 一样，只是 let 有新的作用域规则
```

## var 声明-赋值

### 方式

```js
声明
	非对象
        var variable;
   	对象
    	var variable = new Type()
先声明后赋值		
	标准形式 , 显示声明
	//指定变量类型，声明后不赋值，使用默认值
    var a 
    a = 22

声明的时赋值
	显式地标明变量的类型，在多变量同时声明时可以用到
     var a = "lili";


// -----------------------
索引类型
	1. 根据省略长度，进行推倒(见数组)
	2. 赋值填充
		1. 键值对填充(根据索引键值对确定)
        2. 值列表
        3. 访问字段名填充
```



### 默认值

```js
变量零值
    未赋值的变量初始化为 undefined（未定义）值
```

### 单变量声明

```js
// 先声明后赋值
	var userName;
    var userName = "lili";
```



### 批量声明

```js
    var person , carName;
    var person="lili" , carName="meidi";
```

### 重复声明

```js
一个变量声明后，再次声明为没有赋值的，值不会丢
var carName = "233";
var carName ;    // carName 的值仍旧是 233

一个变量声明多次，并赋值不同的值，值会更新
var a = 1 ;
var a = 2 ;  // 变量 a 就是 2
```

### 建议规则

```js
1. 尽量不要声明变量就赋值， 要先声明，后赋值
2. 解释器能够自动隐式声明，作为全局变量使用
3. 数值不用引号，使用了，会默认为文本
4. 变量声明如果不使用 var 关键字，即使在函数内部定义，他也是局部变量

使用
    先声明 后读写
    先赋值 后运算
```

## let 声明赋值

### 介绍

```js
使用
	和 var 一样，把 var 换成 let 即可 ，只是两者的规则不同
作用
	声明一个作用域被限制在 块级中的本地变量、语句或者表达式 ，并且可选的将其初始化为一个值
    let不会在全局声明时（在最顶部的范围）创建window 对象的属性


初始化
	通过 let 声明的变量直到它们的定义被执行时才初始化 
        function do_something() {
            //  该变量处在一个自块顶部到初始化处理的“暂存死区”中。
              console.log(foo); // ReferenceError
	          console.log(typeof i); // ReferenceError
              let foo = 2;
        }
重复声明
	在相同的作用域、在相同的块中，通过 let 重新声明一个 let 变量是不允许的：
    不同的作用域或者块中可以
    // 不能在同一个作用域声明多个相同的变量
        if (x) {
          let foo;
          let foo; // SyntaxError thrown.
        }
注意
	switch 语句是一个块 ，不同 case 语句需要添加 {} 创建一个新的块作用域的词法环境 
        switch(x) {
          case 0: {
            let foo;
            break;
          }
          case 1: {
            let foo;
            break;
          }
        }

例子分析
	
```

### 作用域

```js
块状作用域
	let声明的变量只在其声明的块或子块中可用 , 作用域也是如此		
        { 
          // 在块 {} 内声明的变量无法从块外访问：
          let x = 10;
        }
循环作用域
	let i = 7;
    for (let i = 0; i < 10; i++) {
      // 循环中使用的变量使用 let 并没有重新声明循环外的变量
     // 在循环中用 let 声明了变量 i，那么只有在循环内，变量 i 才是可见的。
      // 一些语句
    }
	console.log(i)  // 7
函数作用域
	函数中声明也差不多
全局作用域
	如果在块外声明声明，那么 var 和 let 也很相似
html 的作用域
	let 关键词定义的全局变量不属于 window 对象：
        let carName = "porsche";
        // 此处的代码不可使用 window.carName
```



## 作用域(scop)

* 分类

    * 全局变量 local variable
    * 局部变量 global variable

###  全局作用域、全局变量

```js
1. 在直接编写 script 标签的 JS 代码中，都在全局作用域
2. 全局作用域中有一个全局对象 window ,表示一个浏览器窗口，由浏览器创建，可以直接使用
	全局作用域中
    	创建的变量都会作为 window 对象的属性保存   ：全局变量
        创建的函数都会作为 window 对象的方法保存   ： 全局函数
        
// 全局变量
        
1. 函数体外 	    ： var 的变量   <script> 标签中使用 var 声明的
2. 函数体内  		： 没有使用 var 声明的变量，隐式全局变量

2. 直接在全局对象上 
	创建的变量都会作为 window 对象的属性值保存
    创建的函数都会作为 window 对象的方法存储
    
	f = "value";
	window.f = "value"   // web 浏览器中，全局作用域对象为 window

// 调用
    在任何位置进行调用
    在整个页面中课件，可以被自由访问
    
// 声明周期
    在网页打开时创建，除非被显示删除，否则一直存在，直到页面被关闭
```

### 函数作用域、局部变量

```js
函数作用域
	调用函数时创建函数作用域，函数执行完毕，函数作用域销毁
    每调用一个函数就会创建一个函数作用域，他们之间相互独立


类型
    函数体内  ： var 指定的变量
    函数的    ： 参数
调用
    函数体内调用
   1. 函数作用域中的可以访问全局作用域的变量 ， 不能反过来
    	在函数内部调用一个变量，会逐级向上
   2. 调用全局变量。可以使用  window.变量名

生命周期
    自变量声明起到函数运行完毕，运行完毕就会删除

特性
    是调用对象的属性
    在函数体内使用全局变量是一种危险行为，因为优先级不同被覆盖
    
// 注意
1. 函数内没有声明变量（没有使用 var ）,该变量被设置为全局变量
  	function f(){
          carName = "222";  // 全局变量
      }
```

### HTML 中的全局变量

```js
在 HTML 中。全局变量是 window 对象，所有数据变量都属于 window 对象
通过 var 关键词定义的全局变量属于 window 对象：
    var carName = "porsche";
    // 此处的代码可使用 window.carName
```

### 优先级

```js
同名的参数
    局部变量  > 参数变量 > 全局变量 > window 对象的变量或函数
    
// 形参相当于声明变量
1. 函数内部定义的变量，会在该作用域会覆盖同名全局变量
```

###  变量污染 - 原型对象

```js
变量污染 
	全局变量在全局作用域内可见，有污染性

避免
1. 脚本中创建一个全局变量，作为当前应用的唯一接口，
	然后通过对象直接量的形式包含所有应用程序变量
var MApp = {}				// 定义App访问接口
MyApp.name = {"id":"应用程序"} // App 配置信息
MyApp.worker={				 // App 配置信息
	num:123, // 计数器属性
    sub:{name:"sub_id"}      // App应用分支
}





2. 使用函数体封装应用程序，
(function(window) {
    var MApp = {}				// 定义App访问接口
    MyApp.name = {"id":"应用程序"}; // App 配置信息
    MyApp.worker={				 // App 配置信息
        num:123, // 计数器属性
        sub:{name:"sub_id"}      // App应用分支
	};
    window.MyApp;  // 对外开发应用程序接口
})(window)	
```





## var 变量提升

### 介绍

```js
变量提升 Hoisting
	// （提升到当前脚本或当前函数的顶部
	JavaScript 将所有声明提升到当前作用域顶部的默认行为
原理
	// js 中是先声明后赋值，即先编译后操作 ， 即 只提升声明，而非初始化。
    1. 预编译期  ： 先解析代码，获取所有被声明的变量,处理声明的变量
    2.  执行期   ： 再一行一行运行,进行赋值操作
	3.   效果    ：  var 声明的变量都会提升到代码的头部



函数声明提前
	函数声明形式创建的函数 function 函数(){} 会在所有的代码执行在被创建，但是没有赋值
    
函数内部 var 函数内部 var 声明的变量
	不管在什么位置，变量声明都会被提升到函数体头部
    

```

### 全局变量提升

```js
介绍
	使用 var 关键字声明的变量，会在所有代码之前被声明 ，在声明变量之前使用它    
        console.log(a) // a :undefined
        var a = 123;
        // 等价于
        var a;
        console.log(a)
        a= 123
    
注意
	没有用 var 的则不被提前
```



### 函数提升

```js
介绍
	跟变量的被提前一样
提升
	函数声明语句会被提前到外部脚本或外部函数作用域的顶部
    这种方式声明函数，可以被在他定义之前的代码所调用
例子

1. 函数声明提前
	// 函数声明形式创建的函数 function 函数(){} 会在所有的代码执行在被创建，但是没有赋值
	// 可以在函数定以前调用f();
	// 右侧以表达式定义的函数并没有被提前,
    var f = function(){};
    //等价于
    var f;
    f();
    f = function(){};
	定义的时候，f 只是被声明了，并没有被赋值，等于 undefined ,会报错


2.局部变量提升
	函数内部 var 声明的变量，不管在什么位置，变量声明都会被提升到函数体头部
    function f(x) {
        if(x>10){
            var a = x - 1;
        };
    };

	等价于
    function f(x) {
        var a;
        if (x>10) {
            a = x - 1
        }
    }
```

## 内存管理

*   内存声明周期
    *   分配小内存空间，得到它的使用权
    *   存储数据，可以反复进行操作
    *   释放小内存空间
*   释放内存
    *   对象     ： 设置 null 释放 ，随后由垃圾回收器回收
    *   局部变量  ： 在函数结束自动释放
    *   

### 回收机制(GC)

```js
垃圾
	当一个对象没有任何的对象或属性进行引用，我们将无法操作该对象
    	var obj = new Object();
    	obj = null;   //  obj 无法使用，占用内存
回收机制
	js 中有在自动回收机制，会自动从内存中销毁，也不需要进行垃圾回收操作
    我们要做的就是把对象设置为 null 即可，一段时间即可自动清理

1. 标记清除

2. 引用计数
```



## this

* 是什么

    ```js
    // 函数本质上都是通过某个对象来进行调用的，没有指定默认就是 window
    函数内部都有一个变量 this
    	this 为调用函数的当前对象
    ```

    




## Null

```js
可以将变量的值设置为 null 来清空变量
person = null;
```

