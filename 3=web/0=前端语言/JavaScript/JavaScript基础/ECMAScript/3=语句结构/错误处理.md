## 错误和异常

### 种类

*   语法错误

    ```js 
    解析错误，
    传统语言错误此案出现在预编译时期，JavaScript 出现在解释时期
    
    仅仅在出现错误的进程出现影响，其他进行中代码的执行不受影响
    ```

    

*   运行错误

    ```js
    异常
    通常在编译或者解释之后运行时会出现
    会影响进程创建时的正行执行，但是允许其他的金蝉则可以继续正常进行
    ```

    

*   逻辑错误

    ```js
    思路错误，难以追踪
    ```

    

## 手动抛出错误

### Error 对象

*   JavaScript 解析或者执行时，一旦发生错误，引擎会抛出一个错误对象，然后程序中断
*   所有抛出的错误都是这个错误对象的实例

```js
var err new Error("error message")   // 生成一个 err 实例

属性
    message 错误提示信息
    name     错误名称  (非标准属性)
    stack    错误的堆栈	(非标准属性)
```

### Error派生原生错误类型

```js
SyntaxError
ReferenceError
RangeError
TypeError
EvalError  (ES5不出现)
URLError   (ES5不出现)

这是 6 中派生错误，和原生 Error 一样，都是构造函数，可以手动抛出错误
	1. 都有一个 message  参数，用来显示错误
```



### syntaxError

```js
// 解析代码时，发生的语法错误
var 1a;   // 变量名错误
```

### ReferenceError

```js
1. 引用一个不存在的比那辆时发生的错误
	unknownVariable  // ReferenceError :unknownVariable is not defined
2. 将一个值分配给无法分配的对象：函数的运行结果或者this赋值
	console.log() = 1  //ReferenceError
	this = 1           //ReferenceError
```

### RangeError

```js
当一个值超出有效范围发生的错误
	1. 数组长度为负数
    2. Number 对象的方法参数超出范围
    3. 函数堆栈超过最大量
    
    new Array(-1)  // RangeError
```



### TypeError

```js
1. 变量或参数不是预期类型发生错误
2. 调用对象不存在的方法

	原始类型使用 new 命令，因为 new 是一个构造函数
	new 123; // TypeError  :number is not a func
```



### EvalError

```js
// 该类型已经不在 ES5 中存在，保持以前的兼容，保留下来
函数没有被争取执行，抛出的错误
```



### URLError

```js
// 该类型已经不在 ES5 中存在，保持以前的兼容，保留下来
URL 相关函数不正确抛出的错误
	
    
    encodeURL() 			decodeURL() 	
	encodeURLIComponent() 	 decodeURLIComponent()
	escape()				unescape()
```



## 自定义错误

```js
// 自定义一个错误对象 UserError , 继承 Error 对象，就可以自定义错误
function UserError(message) {
    this.message = message || "默认信息";
    this.name = "UserError";
}
UserError.prototype = new Error;
UserErrpr.prototype.constructor = UserError;


// 调用
new UserError("自定义的错误")
```



## 异常处理语句

```js
throw		主动抛出异常
try			指明需要处理的代码段
catch		捕获异常
fianlly		后期处理
```

### throw-catch

*   throw 用于创建或抛出异常 exception
*   中断程序，抛出一个错误或意外，可以抛出各种值
*   异常可以是 ：字符串、数字、逻辑值、对象 

```js
throw "Error!";  // 抛出一个字符串
throw 23;		 // 抛出一个数字
throw new UserError("自定义错误")；  // 抛出自定义的错误

// 和 try catch 连用可以控制陈旭流，自定义生成错误消息
throw exception

---------------------------------------------------------------------------------
try {
    var x = document.getElementById("demo").value;
    if (x==="")  throw "empty";
    if (x>10)     throw "too hight";
} catch (err) {
        
}

// throw 抛出信息规划化

function assert(expression,message) {
    if (!expression) {
        throw{name:"Assertion Exception",message:message};
    };
}
	// 使用 ：如果 expression 非真，就抛出错误的异常信息
	assert(typeOf myCar != "undefined","myCar is undefined");
	// 注意
	console.assert() 的机制和上面的一样
```

### try-catch

```js
try {
    // 执行代码
}
catch (err) {   //  err 是 Error  实例
    // 处理错误
}


// 对错误处理
try {
    throw new Error("出错了")
} catch(err) {
    console.log(e.name + ":" + e.message)
    if (e instanceof EvalError){
        console.log(e.name + ":" + e.message)
    }
}
console.log(222)

1. catch 不捕捉到错误，进行处理，处理完并不影响程序往下执行。下面的语句仍旧会执行
2. try catch 结构是对结构化变成的一种破坏，处理不好就会变成 go to , 谨慎使用 
```

### try-catch-finally

```js
try...catch  后面允许添加一个 finally 代码块，不管是否出现错误，最后都必须运行的语句

try {
    console.log(x);
    return "result";   // return 语句是 finally 之前执行，但是等 finally 执行完毕才返回
}catch (err) {
    throw err;		 // 遇到 throw 语句，是会去执行 fianlly 语句块，
    ...				//  在 throw 其 finally 剩余的代码
} finally {
    console.log("finally");
    return false;   // finally 中有return 语句，就不会去执行 catch 中剩余的语句
}
```

### onerror

*   onerror 时间句柄是 JavaScript 中添加的第一个为了方便错误处理的特性，无论何时在网页中产生异常，窗口对象就会触发 error 事件

*   特性

    ```js
    onerror 事件句柄提供了三个信息来准确表达错误
    1. 错误消息。浏览器显示给定错误的相关信息
    2. URL      错误出现的文件
    3. 行数	  在指定的 URL 中造成的错误的行数
    ```

    

































































































