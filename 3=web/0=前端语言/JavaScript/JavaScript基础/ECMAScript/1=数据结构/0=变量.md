## 数据类型

```js
首先要有一个观念，在 js 中，一切都是对象

数据类型
	基本类型
    对象类型
变量类型 （变量内存值的类型）
	基本类型 ： 保存的基本类型的数据
    引用类型 ： 保存的地址 (基本上和对象类型不区分，是一样的)    
```

## 变量

## 介绍

* 变量相当于容器
  
  * 变量名 ： 容器上的标签
  * 变量值 ： 容器内的内容
  * 通过标签可以找到变量，以便读写它存储的值

## 变量命名

```js 
标识符命名
```

## 变量类型

* JavaScript 是一种弱类型语言，变量类型的规范比较松散
  
  * 类型分类不严谨、不明确、带来使用的随意性
  
  * 变量声明不要求指定类型
  
  * 使用过程不严格，可以根据需要自动转换变量类型
  
  * 变量的转换和类型检查没有一套统一、规范的方法，导致开发效率低

## 声明-赋值

```js
变量零值
    未赋值的变量初始化为 undefined（未定义）值

显示声明    
    var 变量名；
    var 变量名 = new 变量类型；

赋值
    使用单个等号 =

一条语句
    单个变量  
            var userName;
            var userName = "lili";
    多个变量  
            var person , carName;
            var person="lili" , carName="meidi";

重复声明的变量
    一个变量声明后，再次声明为没有赋值的，值不会丢
    var carName = "233";
    var carName ;    // carName 的值仍旧是 233

   一个变量声明多次，并赋值不同的值，值会更新
    var a = 1 ;
    var a = 2 ;  // 变量 a 就是 2

注意
    1. 尽量不要声明变量就赋值， 要先声明，后赋值
    2. 解释器能够自动隐式声明，作为全局变量使用
    3. 数值不用引号，使用了，会默认为文本
    4. 变量声明如果不使用 var 关键字，即使在函数内部定义，他也是局部变量
 


使用
    先声明 后读写
    先赋值 后运算
 
// js 中是先声明后赋值，即先编译后操作
```

## 赋值变量

```js
赋值  
    变量 = 值

变量提升 Hoisting
    先解析代码，获取所有被声明的变量，再一行一行运行，这样声明的变量都会提升到代码的头部
    1. 预编译期  ：先处理声明的变量
    2.  执行期   ： 赋值操作
```

## 变量类型

* 值类型
  
  * 占用空间固定，保存在栈中
  
  * 保存和赋值的是  ： 值本身
  
  * 使用 typeof 检测类型
  
  * 基础类型数据是值类型

* 引用类型
  
  * 占用空间不固定，保存在堆中
  
  * 保存与赋值的是   ： 指向对象的一个指针
  
  * 使用 instanceof  检测类型
  
  * 使用 new() 方法构造出来的对象是 引用类型

## 作用域(scop)

* 分类
  
  * 全局变量 local variable
  * 局部变量 global variable

### 全局作用域、全局变量

```js
1. 在直接编写 script 标签的 JS 代码中，都在全局作用域
2. 全局作用域中有一个全局对象 window ,表示一个浏览器窗口，由浏览器创建，可以直接使用
	全局作用域中
    	创建的变量都会作为 window 对象的属性保存   ：全局变量
        创建的函数都会作为 window 对象的方法保存   ： 全局函数
        
// 全局变量
        
1. 函数体外 	    ： var 的变量   <script> 标签中使用 var 声明的
2. 函数体内  		： 没有使用 var 声明的变量，隐式全局变量

2. 直接在全局对象上 
	创建的变量都会作为 window 对象的属性值保存
    创建的函数都会作为 window 对象的方法存储
    
	f = "value";
	window.f = "value"   // web 浏览器中，全局作用域对象为 window

// 调用
    在任何位置进行调用
    在整个页面中课件，可以被自由访问
    
// 声明周期
    在网页打开时创建，除非被显示删除，否则一直存在，直到页面被关闭
```



```js

```

### 函数作用域、局部变量

```js
函数作用域
	调用函数时创建函数作用域，函数执行完毕，函数作用域销毁
    每调用一个函数就会创建一个函数作用域，他们之间相互独立


类型
    函数体内  ： var 指定的变量
    函数的    ： 参数
调用
    函数体内调用
   1. 函数作用域中的可以访问全局作用域的变量 ， 不能反过来
    	在函数内部调用一个变量，会逐级向上
   2. 调用全局变量。可以使用  window.变量名

生命周期
    自变量声明起到函数运行完毕，运行完毕就会删除

特性
    是调用对象的属性
    在函数体内使用全局变量是一种危险行为，因为优先级不同被覆盖
    
// 注意
1. 函数内没有声明变量（没有使用 var ）,该变量被设置为全局变量
  	function f(){
          carName = "222";  // 全局变量
      }
```

### 优先级

```js
同名的参数
    局部变量  > 参数变量 > 全局变量 > window 对象的变量或函数
    
// 形参相当于声明变量
1. 函数内部定义的变量，会在该作用域会覆盖同名全局变量
```

###  变量污染 - 原型对象

```js
变量污染 
	全局变量在全局作用域内可见，有污染性

避免
1. 脚本中创建一个全局变量，作为当前应用的唯一接口，
	然后通过对象直接量的形式包含所有应用程序变量
var MApp = {}				// 定义App访问接口
MyApp.name = {"id":"应用程序"} // App 配置信息
MyApp.worker={				 // App 配置信息
	num:123, // 计数器属性
    sub:{name:"sub_id"}      // App应用分支
}





2. 使用函数体封装应用程序，
(function(window) {
    var MApp = {}				// 定义App访问接口
    MyApp.name = {"id":"应用程序"}; // App 配置信息
    MyApp.worker={				 // App 配置信息
        num:123, // 计数器属性
        sub:{name:"sub_id"}      // App应用分支
	};
    window.MyApp;  // 对外开发应用程序接口
})(window)	
```

### 变量提升

```js
变量声明的提起
	使用 var 关键字声明的变量，会在所有代码之前被声明,没有用 var 的则不被提前
    console.log(a)
	var a = 123;
	等价于
    var a;
	console.log(a)
	a= 123



函数声明提前
	函数声明形式创建的函数 function 函数(){} 会在所有的代码执行在被创建，但是没有赋值
    
函数内部 var 函数内部 var 声明的变量
	不管在什么位置，变量声明都会被提升到函数体头部
```











## 类型转换

### 动态语言

```js
JavaScript 是动态类型的语言
变量没有类型限制，可以随时赋予任何值

```

### 类型判断

```js
typeOf 变量名；   // 检查变量类型

constructor
	1. 回当前对象的构造器（类型函数）。利用该属性，可以检测复合型数据的类型，如对象、数组和函数
    2. undefined 和 null 没有 constructor 属性，不能够直接读取，否则会抛出异常
   		可以先检测，在用 constructor
    3. 数值直接量也不能直接读取 constructor 属性，应该先把它转换为对象再调用

toString 
	是 Object 类型的原型方法，它能够返回当前对象的字符串表示

自定义类型检测    
    //强健的数据类型检测工具函数
    //参数：obj 表示待检测的值
    //返回值：返回字符串表示，格式与 typeof 运算符相同，
    //"undefined" "number" "boolean" "string" "function"
    //"regexp" "array" "date" "error" "object"或 "null"
    function typeOf(obj){
        
      // 引用 Object 的原型方法 
      // toString () //列奉所有可能的类型字符串表示
      var _toString = Object.prototype.toString; 
      //模仿typeof运算符返回值，通过映射，统一字符串表示的值 
      var _type ={
        "undefined" : "undefined",
        "number" : "number",
        "boolean" : "boolean",
        "string" : "string",
        "[object Function]" : "function0f",
        "[object RegExp]" : "regexp",
        "[object Array] " : "array",
        "[object Date]" : "date",
        "[object Error]" : "error"
        //在这里可以继续展开要检测的类型
      }
    //把值转换为字符串表示，然后匹配 _type 对象中的键值对，最后处理特殊值 null
    return _type[typeof obj] || _type[_toString.call(obj)] || (obj ? "object" :"null");
    } 

// 要检测宿主对象和自定义类型，则需要用户添加 _type 对象的键值对，以扩展类型检测的范围。
```

| 值（value）                                           | typeof value（表达式返回值） | value.constructor（构造函数的属性值） |
| ----------------------------------------------------- | ---------------------------- | ------------------------------------- |
| number                                                | "number"                     | Number                                |
| string                                                | "string"                     | String                                |
| boolean                                               | "boolean"                    | Boolean                               |
| 对象                                                  | "object"                     | Object                                |
| new 字符                                              | "object"                     | Object                                |
| 数组                                                  | "object"                     | Object                                |
| 函数                                                  | "function"                   | Function                              |
|                                                       |                              |                                       |
| function className(){};  var value = new className(); | "object"                     | Object                                |

### 强制转换

*   指一个类型强制转换成其他类型的类型数据

    ```js
    转为 ： 
    	String   （参看string）
        Number   （参看number）
        Boolean   （参看boolean）
    转换成其他的没有意义
    
    ```

### 自动转换

*   自动转换是以强制转换为基础的

*   自动转换,对用户不可见

    ```js
    1. 不同类型的数据相互运算
    	123 + "ad" //"123ad"
    2. 对非布尔值类型的数据求布尔值
    	if ("a") console.log("hello");
    3.对非数值型的数据使用一元运算符 ( + - )
        - [1,2]  // NaN
    
    // 与其某个位置是什么类型的数，就调用什么函数
    ```

*   具体转换

    ```js
    // 自动转换为 boolean
    	语句 的条件语句部分
        6 种类型转化为 false   加上 ！ 就是 true
    
    // 转换为字符串
    	 主要是加法运算 
         字符串 + 非字符串  ：会将非字符串转化为字符串 ，然后进行拼接
         
    // 自动转化为 数值
         一元运算    +"sdf"  // NaN
    	减法		true-1   // 0
        乘法		'5'*'2'   // 10
    	/
    ```

    

### HTML 中的全局变量

```js
在 HTML 中。全局变量是 window 对象，所有数据变量都属于 window 对象
```

## 补充

```js
ES6 中

let 代替 var 声明变量，就可以吧变量限制在当前的代码块中
const 声明常量
```



## 内存管理

*   内存声明周期
    *   分配小内存空间，得到它的使用权
    *   存储数据，可以反复进行操作
    *   释放小内存空间
*   释放内存
    *   对象     ： 设置 null 释放 ，随后由垃圾回收器回收
    *   局部变量  ： 在函数结束自动释放
    *   

### 回收机制(GC)

```js
垃圾
	当一个对象没有任何的对象或属性进行引用，我们将无法操作该对象
    	var obj = new Object();
    	obj = null;   //  obj 无法使用，占用内存
回收机制
	js 中有在自动回收机制，会自动从内存中销毁，也不需要进行垃圾回收操作
    我们要做的就是把对象设置为 null 即可，一段时间即可自动清理

1. 标记清除

2. 引用计数
```



## 高级

```js

数据
	存储在内存中代表特定信息的二进制数据
    特点
    	1. 可传递  // a=2,b=a  传递给 b 的数据 2 
        2. 可运算    // b = a + 3  就是 a 中的 2 和 3 相加，返回结果
     注意
     	一切皆数据  // 
        内存中所有操作的目标 ：数据==算术、逻辑、赋值、运行函数
内存
	内存条通电后产生的可存储数据的空间（临时的数据）
    内存产生和死亡：内存条（电路板）==》通电 ==》产生数据==》存储数据==》处理数据==》断电==》内存空间和数据消失
	一块小内存存储两个数据：
    	内部存储的数据
        地址值
    内存分类
    	 栈 ：全局变量、局部变量
         堆 ： 对象
变量
	可变化的量，内存的标识，由变量名和变量值组成
    每个变量对应一块小内存
    	变量名用来查找对应的内存，
        变量值就是内存只能保存的
        

// obj 的地址值就是它自身内存条的编号，而他存储的值是对象所在的内存的编号
var obj = {"name":"tom"}   // 将 {} 的内存地址，copy 一份赋值给 obj
var a = obj 		// 将 obj 保存的内容 copy 给另一个值
console.log(obj.name)     //  拿着 obj 的内存地址，去 . (访问，变量存储的是地址，就可以使用点)

var a = 2 ;  // a 中保存的就是 这个数据 2


var a = xxx , a 中保存的值：
	xxx 为基本类型，保存的就是这个数据
     xxx  为对象  ，保存的是对象的地址值
     xxx  为变量  ， 保存的是 xxx 的内存内容（数据值或者地址值）
     
     
// 引用变量赋值问题
 n 个引用变量指向同一个对象，其中一个变量修改的对象内部数据，其他变量看到的就是修改后的数据
 n 个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象，
 
 var obj1 = {"name":"lili"}
 obj1.age = 13
 var obj2 = obj1
 obj2.name = "zhangsan"
console.log(obj1.name)  // 得到的就是 zhangsan

```

## this

*   是什么

    ```js
    // 函数本质上都是通过某个对象来进行调用的，没有指定默认就是 window
    函数内部都有一个变量 this
    	this 为调用函数的当前对象
    ```

*   如何确认this

    ```js
    
    ```

    

## Undefined

```js
表示变量不含有值
```



## Null

```js
可以将变量的值设置为 null 来清空变量
person = null;
```

