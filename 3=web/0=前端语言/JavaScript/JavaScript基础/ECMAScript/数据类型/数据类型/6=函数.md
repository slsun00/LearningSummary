## 函数

*   什么是函数
    
    ```js
    代码复用，封装一个功能 ， 当函数被调用时被执行时可重复使用的代码块
    js 函数由事件驱动的
    ```
    
*   为什么使用

    ```js
    提高代码复用
    便于阅读交流
    
    ```

    

    

*   函数即对象
    
    *   对象就有属性和方法，所以函数也有属性

## 语法

```js
函数
	包括在花括号内的代码块
关键词
	function  必须要小写
花括号
	{} 必须的
    
形参
	函数定义的时候使用的参数，接收调用该函数时传递的参数
实参
	调用函数时传递给函数的实际参数
    
函数

方法
	函数被挂载在一个对象上，作为对象的一个属性，就成该函数是对象的方法
    
注意
	函数不是一个可执行语句，所以不以分号结束
    函数内部可以调用全局变量，但是外部不能调用函数内部的变量
```



## 声明

*   构造函数

    ```js
    动态匿名方法 ， 这种方式很少使用
    // 将要封装的代码以字符串的形式 传递给构造函数
    // 在函数调用的时候执行
    var 函数名 = new Functiong([虚参列表]，"函数体")；
    var myfunction = new Function("a","b","return a + b ");
    
    ```

*   函数声明

    ```js
    // 静态方法 function 命令
    function 函数名 ([形参列表]){
        函数体
    }
    ```

*   函数表达式

    ```js
    // 函数表达式存在一个变量中 ，变量也可以作为一个函数适用
    // 实际上就是匿名函数
    // 这个是一个执行语句 ， 所以要分号结尾
    var 函数名 = function(x){
        函数体；
    }；
    ```


*   注意

    ```js
    1. 多次定义同一个函数，后面的定义声明会覆盖前面的
    2. 不能在调条件语句中声明函数
    ```

## 参数

### 概述

```js
形参
实参

1. 函数中指定一个或者多个形参，多个形参之间需要用 ， 隔开，
2. 声明形参就相当于在函数内部声明了对应的变量 ，但不赋值
3. 实参可以是任何类型的数值：对象、函数、
4. 函数每次调用的时候，会传递两个隐含的数组
```


### 特性规则

```js
// JavaScript 函数不对参数的值进行任何的检查，它不关注到底有多少个参数、参数的类型是什么
1. 调用函数时，解析器也不会检查实参的数量
	实参 < 形参 : 剩余的形参           默认参数：undefined
	实参 > 形参 : 多余的实参被忽略      通过 argumenrts 调用

2. 函数定义时，没有指定数据类型
3. 调用函数时，解析器不会检查实参的数量、参数的类型，所以有可能需要对参数类型检查


3. 通过 arguments 对象访问参数数组
4. 参数始终按值传递
	基本类型 传值  值
    引用类型  传址  对象
```

### 显式参数

```js 
函数显式参数在函数定义的时候给出

function Name (parameter1,parameter2){
    code to be executed
}
```

### arguments 

*   功能

    *   存放实参的参数列表 ：实参都被放在这个类数组类型，通过索引获取操作数据

    *   调用函数，所传递的实参都会存在 arguments 中保存

    *   补定义形参，可以通过 arguments 来使用实参

        ```js
        arguments[0]  // 表示第一个实参
        arguments[1]  // 表示第二个实参
        ....
        ```

    *   可变的实参类表：实参对象

*   特性

    *   仅能在函数体内使用
    *   带有下标属性，并不是真正的数组，是一个实参对象，  
    *   函数声明时自动初始化

*   属性

    ```js
    length   获取函数实参的长度
    callee   返回当前正在指向的函数
    caler    返回调用当前正在执行函数的函数名
    ```

*   使用

    ```go
    function go(x) {
        // 通过数字下标来访问传入函数的实际参数值
        // 不用非要通过名字得到实参
        console.log(arguments[0]);   // 1
        console.log(arguments[1]); 	// 2
        
        // 包含元素的个数
        console.log(arguments.length)  // 2
        
        // 通过 arguments[] 修改 实参的值
        // 当下面的调用改成 go(1) :console.log(x)  1
        arguments[0] = null;
        console.log(x);    // null
    }
    
    go(1,2)
    // 1
    // 2
    
    
    ```

### 对象属性做实参

```js
当一个函数包含超过三个形参时，记住参数的顺序比较难，可以通过 （名/值）对的形式传入参数，这样就不用管参数的顺序了


var obj = {
    name: "zhagnsan",
    age:18,
    gender: "男"
    
}
function person(obj) {
    console.log("我是"+o.name+",年芳"+obj.age+",性别是"+obj.gender)
}
```



### 参数传递

*   概述

    ```js
    js 在调用函数的时候，传递变量参数时
    	理解1 ：都是值（基本/地址值）传递
    	理解2 ：可能是值传递，也可能是引用传递（地址值）
    ```

    

*   通过值传递参数

    ```js
    // 如果函数修改参数的值（整体），将不会修改参数的初始值(在函数外定义)
    总结： 函数传值只是将参数的值传入函数，函数会另外配置内保存参数值，并不会改变原参数的值
    
    var x = 1;
    function myFunction(x) {
        x++;
        console.log(x)  
    }
    
    myFunction(x); //2
    console.log(x); // 1
    ```

*   通过对象传递参数

    ```js
    // 函数内部修改对象的属性就会修改其初始值(修改的是引用对象的值)
        修改对象属性可作用域函数外部(全局变量)
    
    var obj = {x:1}
    function myFunction(obj) {
        obj.x++;     // 函数外部定义的 obj 也会被修改
        console.log(obj.x)  
    }
    
    myfunction(x)		// 2
    console.log(obj.x)   // 2
    ```
    
    



## 返回值

```js
// 使用 return 来设置函数的返回值, return 后的值作为函数的执行结果返回
// 返回值的类型是任意数据类型。对象、函数、等等
语法
	return 值；
例子
	function sum(a,b){
        var res = a + b;
        return res;
        console.log(res)
    }

1. return 后面的语句不会执行 ： 上面的 console 语句不会执行 ，相当于跳出当前函数
2. return 后没有值或者不写 ， 函数都是返回 undefined
```



## 函数命名

```js
标识符命名

1. 通常是动词或者以动词为前缀的词组
2. 首字母小写，采用小驼峰或者下划线
```



## 调用、执行

### 执行调用

```js
直接调用	 test()
对象调用	 obj.test()
new调用	   new test()
临时调用      test.call/apply(obj)  临时让 test 成为 obj 的方法进行调用
	var obj = {}
    var function test2(){}
	// 调用 ，实现 obj.test2() 
	test2.call(obj)
```

### html 中使用

```js
JavaScript 中有 4 中调用方式，每种方式的不同在于 this 的初始化
```

*   直接调用

    ```js
    函数名(实参列表)
    
    function myFunction(a，b) {
        return a*b ;
    }
    myFunction(3,4)  // 12
    
    此函数不属于任何对象，默认是全局变量，
    Html  	中默认的全局对象是 html 页面本身，所以函数属于 html 页面
    浏览器   中页面对象（全局变量）是浏览器窗口，
    	所以上述函数会在自动变成 window 对象的函数
    		即 myFunction 和 window.myFunction 是一样的
    // 全局的标识符容易造成命名冲突的 bug
    
    当函数没有被自身调用， this 的值就会变成 全局对象，
    （使用 window 对象作为一个变量容易造成程序崩溃）
    ```

*   在连接中调用

    ```js
    <a href="javascript:函数名()"> 描述文字 </a>
    ```

*   在事件中调用

    ```js
    事件类型 = "函数名()"
    ```

*   递归调用

    ```js
    函数体内调用函数体
    
    function 函数名() {
        代码
        函数名();
    }
    ```


### 作为方法

```js
函数定义为对象的方法

var myObj = {
    Name: "lili",
    age: function() {   // 方法有一个函数，函数属于对象，myObj 就是函数持有者
        return 18
    }
}
myObj.age(); // 返回18

函数作为方法调用，会使 this 的值称为对象本身
```



### 作为函数方法

```js
JavaScript 中，函数时对象，对象有自己的方法和属性
	call() 、  apply()  是预定义的函数方法，用于调用函数，第一个参数必须是对象本身
    
    function myFunction(a,b) {
        return a + b;
    }
	myFunction.call(myObject,10,2)  // 返回 12  myObject是什么 ???????

```

## 特殊函数

### 构造函数

```js
构造函数就是一个普通的函数，创建函数和普通函数勄区别
格式
	关键字 new 调用则构成构造函数调用 ，首字母大写  

功能
	用构造函数创建的对象，称为一类对象，也称为一个类

看起来像是创建了新的函数，实际上 JavaScript 函数时重新创建的对象
执行流程
	1. 立即创建一个新的对象
    2. 将新建的对象设置为函数中的 this
	3. 逐行执行函数中的代码
    4. 将新建的对象作为返回值返回



构造函数的调用
	会创建一个新的对象，新的对象会继承构造函数的属性和方法
    解析器在调用函数，每次都会向函数内部传递一个隐含的参数 this

this 执行一个对象，这个对象我们称为函数执行的上下文对象
	以函数调用，对象是 window
     以方法调用，对象就是调用这个方法的对象
    以构造函数调用， this 就是新创建的那个对象
    
特性
	构造函数木诶执行一次
    

function Person (name,age) {   // 
    this.name = name;
    this.age = age;
}

// 普通调用 ,类型返回是 Object
x = Person("lili",18)

// 构造函数 ，类型返回是 Person jiushi  
var x = new Person("lili",18)  // Person 类的实例
x.name;		// lili	


// 实例判断 , 判断 x 是否是 Person 的实例
// 对象 
x instanceof Person;   


// 没有形参的构造函数可以省略圆括号
var o = new Object();
var o = new Object;
```

### 匿名函数

```js
// 就是函数声明的时候没有指定函数名

var a = function(){}
```

### 立即执行函数IIFE

*   概述
    *   Immediately-Invoked Function Express
*   适用
    *   等价于匿名函数自调用
    *   会立马调用
*   目的
    *   不必为函数命名，避免污染全局变量
    *   是 IIFE内部形成的一个单独的作用域，可以封装一些外部无法读取的私有变量
    *   隐藏实现
    *   编写 js 模块

```js
// 表达式后面跟上 （） 就会自动调用

function 左边的括号是必须的，否则就被解析为函数生声明语句

(function(){
    statement
})()；

!function(){}()
~function(){}()
-function(){}()
+function(){}()

------------------------------------

function sum(a,b){
    var c = a + b;
}

sum(1,2)();  
// 等价于 
a =sum(1,2)
a()
```

### 回调函数

```js
什么是回调函数
	1. 你定义的函数
    2. 你没有调用
    3. 但是最终执行了
    
 常见的回调函数
 	dom 事件的回调函数
    定时器回调函数
    ajax 请求回调函数
    声明周期回调函数
```



## 函数使用

### 作为值

```js
函数可作为一个值，赋值给变量
function f() {};
var a = f;
```

### 表达式

### 对象

```js 
tyoeOf  类型为 function
有属性和方法
```

## 函数对象

```js
函数定义作为对象的属性，   称之为 ：对象方法
函数如果用于创建新的对象 ，称之为 ：构造函数
```



### 属性

```js
function f(x,y) {}


name 属性
	返回紧跟在 function 后面的那个函数名
	f.name // f

length 属性
	只读属性，代表函数形参的数量，在函数定义时候给出形参个数
    f.length //2

prototype 属性
	原型对象  ，参看原型对象-静态方法
```



### 方法

```js
// 函数也是对象，也有自己的方法和属性

apply（）
	将函数作为对象的方法来调用，将参数以数组形式传递给该方法
call（）
	将函数作为对象的方法来调用，将参数传递给该方法
toString（）
	返回函数的源码，以字符串输出
    
    
function myFunction(a,b) {
        return a + b;
    }
myFunction.call(myObject,10,2)  // 返回 12  将一个对象指定为第一个函数，这个对象将成为函数执行的时候的 this

myArray = [10,2]
myFunction.apply(mybject,myArray)
    
```



## 函数高级

### 原型

```js


函数属性 prototype
	1. 每一个函数都有一个 prototype 属性，他都默认指向一个 object 空对象（即：原型对象）
	2. 原型对象都有一个属性 constructor ,它指向函数对象
		// 你可以理解成原型对象是父对象 。constructor 指向子对象
给原型对象添加属性（一般都是方法）
	函数所有的实例对象自动拥有原型中的属性（方法）
 

prototype 属性

	1.创建的函数每执行一次，解析器都会向函数中添加一个属性 prototype,
     2.指向一个对象的引用，这个对象叫做 原型对象（prototype object）
	 函数调用
     	作为普通函数调用，该属性没有作用
        作为构造函数调用，创建的实例，都会有一个隐含的属性，指向该构造函数的原型对象，
        	访问 ： 实例对象.__proto__   // 所有同一个类的实例对象，拥有同一个原型对象

	原型对象就像父对象，所有的实例对象都继承它的属性（不一定继承完全：子有父必有，父有子未必有）
        1. 我们在访问 实例对象(子类)的时候，
            如果没有找不到相关属性，就到原型(父类)里面去找,找到就返回
            找不到，就找原型(父类)的原型(父类)里面去找
            ....
            一直找到 Object 类型，到这里也找不到，就返回 undefined 

        2. 通过实例对象(子类)修改原型对象(父类)属性，所有的实例对象(子类)都可以访问到这个修改后的值
        	实例.protorype.属性名 = 属性值
	    3. 创建构造函数的时候，可以将共有的属性和方法，统一添加到构造函数的原型对象中
        	只对相关的实例对象起作用  ：《相当于静态变量》
         4. 原型对象还有原型对象，
    
  function MyClass(){	  
  }
MyClass.prototype.test = "666" ;   // 给 myClass 的原型对象添加字段 test = name
```



### 闭包（没懂）

*   介绍
    *   函数可以嵌套在其他函数中定义
*   用处
    *   可以读取函数内部变量
    *   可以让这些变量始终保持在内存中，可以是变量的诞生环境一直存在
    *   封装对象的私有属性和私有方法
*   缺点
    *   函数的变量都会保存在内存中，内存消耗大。
        *   解决 ： 在退出函数之前，将不使用的局部变量清除
    *   尽量不要随便改变父函数内部变量的值

```js
// 私有变量可以用到闭包
function f(a) {
    return function(){
        return a++;
    };
}
var c = f(1);
console.log(c());  // 1
console.log(c());   // 2


function add() {
    var count = 0;
    function plus() {count += 1;}
    plus();
    return counter;
}

add();   // 1
add();   // 2
add();   // 3

闭包可以访问上一层函数作用域里变量函数，即使上一层函数已经关闭
```



## 指针标识

```js
this		指向当前操作对象
callee		指向参数集合所属函数
protetype	 指向函数附带的原型对象
constructor	 指向创建该对象的构造函数
```

## 提升

*   跟变量的被提前一样，函数声明语句会被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明额函数，可以被在他定义之前的代码所调用

    ```js
    1.函数声明提前
    	函数声明形式创建的函数 function 函数(){} 会在所有的代码执行在被创建，但是没有赋值，可以在函数定以前调用
        f();
        var f = function(){};
        //等价于
        var f;
        f();
        f = function(){};
    	定义的时候，f 只是被声明了，并没有被赋值，等于 undefined ,会报错
    
    2. 以表达式定义的函数并没有被提前,
        var sum2 = function(){}   // 没有提前
    
    
    
    
    3.局部变量提升
    	函数内部 var 声明的变量，不管在什么位置，变量声明都会被提升到函数体头部
        function f(x) {
            if(x>10){
                var a = x - 1;
            };
        };
    
    	等价于
        function f(x) {
            var a;
            if (x>10) {
                a = x - 1
            }
        }
    ```


## 零星

*   字符串转语句

    ```js
    将字符串当成语句执行，eval 没有自己的作用域，都在当前的作用域内执行
    eval("var a = 1")
    
    1.如果使用严格模式，eval 内部声明的变量，不会影响到外部作用域
    	(function(){
        'use strict';
        eval('var a = 1 ')
        console.log(a) // a 没有定义
    })
    ```

    