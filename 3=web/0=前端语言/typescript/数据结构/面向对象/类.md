## 类

### 介绍

*   跟 js 差不多一样，只是多了类型限制

### 声明

```js
声明
	class 类名 {

        // 实例属性，直接定义 ，需要通过对象实例去访问
        属性名： 属性值，
        
        // 构造函数，实例化类的时候触发的方法
        constructor(){ 进行属性赋值 }
         // readonly  只读的实例属性
        readonly name: string = "悟空"
        
        
        // 静态属性，使用类调用
        static 属性名：类型 =  值
	    readonly static  属性名：类型 =  值
	
		// 和属性是一样的 static 
        方法名(){}     // 函数
		stac
    }
例子
	class student {
        name: string
        constructor(name:string) {
            this.name = "xiaoming"
        }
		study(){
            console.log("小明在学外语")
        }
    }
```

## 属性

### 属性修饰符

```js
三种
	public		
    	公有， 在类里面、子类、类外边都可以进行访问
        什么都没写，默认表示公有
    protected	保护类型 在类里面。子类里面都可以访问。在类外边无法访问
    private		私有， 类里面可以访问，子类、类外边无法访问
    
例子
	
```

### 静态属性、静态方法

```js
// js 中的静态方法 静态属性
static 关键字
```





## 继承

```js
class a{
    say(){console.log("调用a")}
}
class b extends a{
    constructor(name) {
        super(this,)
    }
    walk(){console.log("b 跑步")}
}


```



## 多态

```js
介绍
	父类定义一个方法不去实现，让继承他的子类去实现，每一个子类有不同的表现
    多态属于继承
    
例子
	// 只是一种思想，差不多的思路
	class Animal {
        constructor(name:string) {}
        eat() {}  // 什么也不做，或者干少量的事情
    }
	class Dog extends Animal {
        construtor(name:string) {
            super(name)
        }
        eat(){ 重写eat函数}
    }
```





## 抽象类/方法

```js
介绍
	抽象类，提供其他类继承的基类，不能直接被实例化
 声明
 	abstruct 关键字
特点
	抽象类中的抽象方法不包含具体实现，必须在派生类中实现
    抽象方法只能放在抽象类中
语法
	// 抽象类是用来规范的，不能进行实例化
	abstruct class Animal {
        abstruct eat():Any;
    }
	// 抽象子类必须实现抽象类里面的方法
	class Dog extends Animal {
        constructor(){}
        // 必须要实现eat
        eat(){}
    }
```



## 装饰器

### 介绍

```js
介绍
	一种特殊类型的声明，能够到类声明、方法、属性、参数上。可以修改列的行为
    一个方法，可以注入类、方法、属性、参数上来扩展其功能
    // 将听谁就写在谁的上面
 类型
 	// 常见
 	类装饰器、属性装饰器、方法装饰器、参数装饰器
 写法
 	普通装饰器(无法传参)
	装饰器工厂(可传参数)
```

### 类装饰器

```ts
介绍
	类装饰器在类声明之前被声明(紧靠着声明)
	类装饰器用于构造函数 ， 用来监视 、修改、替换类定义
例子

	@logclass // 这个是装饰器函数
	class Help {
        constructor(){}
        get(){}
    }
------------------------------------------------------
	// 普通模式 ：装饰器
	function logclass(params:any) {
        // params 就是当前类
        // 添加属性
        params.prototype.url = 'www.222'
        // 添加方法
         params.prototype.run = function(){}
    	// 构造函数更改
    	return class extends params {
            // 构造函数更改以后，对应的属性、方法都要进行重载
            get(){}
        }
    }
	// 对应装饰器写法
	@logclass 
--------------------------------------------------------
	// 装饰器工厂 ：可传参
	function logclass(params:string) {
        return function(target:any){
            // params  就是要额外添加的参数
            // target  就是传进来的当前类
        }
    }
	// 对应装饰器写法
	@logclass('hello') // 这个是装饰器函数
--------------------------------------------------------
	let h = new Help()
    // help.url 是 'www.222'
    // help.run()  ok
    
// 装饰器工厂
    
```



### 属性装饰器

```ts
介绍
	类属性装饰器表达式会在运行时当做函数被调用，并传入下面两个参数
    	1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象
        2. 成员的名字
例子
    class Help {
        @logProperty('www') // 监视装饰 url
        url:string | undefined
        constructor(){}
        get(){}
    }
------------------------------------------------------
	function logProperty(params:string) {
        // params 传入的参数
		return function(target:any,attr:any) {
            // target  类的原型对象
            // attr	  要修改的成员
            target[attr] = params
        }
    }
	// 对应装饰器写法
	@logclass 
```

### 方法装饰器

```ts
介绍
	被应用到方法的  属性描述符上，可以用来监视、修改、替换方法定义
参数
	// 运行时需要传入是哪个参数
	1. 对于静态成员来说是类的构造器 ， 对于成员变量来说是类的原型对象
    2. 成员的名字
    3. 成员属性描述符
例子

	class Help {
        url:string | undefined
        constructor(){}
        
        @logMethod('xx')
        get(){}
    }
------------------------------------------------------
	// 普通模式 ：装饰器
	function logMethod(params:any) {
        // params 就是当前参数
		return function(target:any, methodName:any, desc:any) {
            // target  类的原型对象
            // methodName  方法名称
            // desc.value   就是方法体
            // 进行属性添加
            target.url = 'xxx'
            // 方法添加
            target.run = function() {}
           // 保存当前方法
            let oMethod = desc.value
            // 修改方法 , 将原来的方法进行重写
            desc.value = function(...any) { ... }
    }
	// 对应装饰器写法
	@logclass 
```



### 方法参数装饰器

```ts
介绍
	参数装饰器表达式会在运行时被当做函数调用，可以使用参数装饰器为类的原型增加元素数据
参数
	// 运行时需要传入是三个参数
	1. 对于静态成员来说是类的构造器 ， 对于成员变量来说是类的原型对象
    2. 参数的名字
    3. 参数在函数参数列表中的索引
例子
	
	class Help {
        url:string | undefined
        constructor(){}
        
        get(@logParams('uuid') uuid:any){}
    }
------------------------------------------------------

	function logParams(params:any) {
        // params 就是当前参数
		return function(target:any, methodName:any, paramsIndex:any) {
            // target  类的原型对象 可以进行属性、方法更改
            // methodName  方法名称
            //  paramsIndex  参数索引
            // 进行属性添加
			target.url = params
    }

```



### 执行顺序

```ts
// 
先执行类里面的装饰器（从上到下、从左到右），最后执行类装饰器
```

























