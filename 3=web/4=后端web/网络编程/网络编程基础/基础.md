## 网络编程

### 概述

* golang 设计目标就是面向大规模的后端服务程序， 网络通信是服务端程序非常重要的一部分

## 分类

* TCP socket 编程
  * 是网络编程的主流 ，底层是基于 TCP / IP 协议的
* http 编程
  * bs 结构
  * 使用浏览器访问服务器，使用的是 http 协议，其底层仍旧是 socket 编程

## 零星

* 协议是可以自定义的，可以使用自定义的协议



## 路由



## DNS



## HTTP 协议

>   参看 HTTP 协议

## WEB 应用

* 执行的任务
  
  ```go
  通过 http 协议，以 http 请求报文的形式获取客户端输入
  对 http 请求报文进行处理，执行必要的操作
  生成 html 。并以 http 响应报文的形式返回给客户端
  
  web 应用分为
      处理器 handler
      模板引擎    template engine
  
  处理器 ： 除了要接收和处理客户端发来的请求，嗨呀调用模板引擎，然后由模板引擎生成 HTML ，并把数据填充会串给客户端的响应报文中
  ```

* 请求的接收和处理
  
  ```go
  1. 客户端发送请求到服务器的一个 URL 上
  2. 服务器的多路复用器将接收到的请求重定向到正确的处理器，然后由该处理器对请求进行处理
  3. 处理器处理请求并执行必要的动作
  4. 处理器调用引擎模板，生成响应的 HTML 并将其返回给客户端
  ```

## Cookie

## 在请求表单

### 请求

```go
客户端发送 http 请求报文，这个报文信息就是 http.Requuest 结构体
    request 不是逐字逐句进行报文信息，而是经过语法分析后，提取出主要的信息
    主要是客户端发送给 / 服务器接收的请求
    主要字段
        URL        Header        Body
        Form      PostForm      MultiPartForm 
```

* URL 
  
  ```go
   URL字段用干表示请求行中包含的URL( 请求行也就是 HTTP 请求报文的第一行)
  web 通过 URL 的查询参数项服务器发送消息，
  http://www.text.com/post?id=123&password=456
      RawQuery 字段记录客户端向服务器传递的查询参数字符串：id=123&password=456
  1. 如果请求报文是由浏览器发送的，那么程序无法通过 URL 结构体的 Fragment 字段获取 URL 字段部分
  2. 浏览器向服务器发送包请求之前，会将 URL 中的片段部分剔除掉 - 因为服务端接收到的都是不包含片段部分的 URL，所以就无法通过 Fragment 字段取获取 URL 片段内容
  3. 服务器和客户端都可以吧 Request 结构图作为自己的一部分
  ```

* 请求首部
  
  ```go
  Header 用来映射表示 HTTP 首部中的多个键值对 ， 实例就是一个映射，映射的键为字符串，值为字符串切片
  header 设置操作
      给定键的值会被设置成一个空白的字符串切片，然后该切片的第一个元素会设置成给定的首部值
      在执行添加操作时，给定的首部值会被添加到字符串切片已有元素的后面
  ```

* 主体
  
  ```go
  请求和响应的主体用 request 的 body 字段表示，这个字段是一个接口，该接口可以读取和关闭主体
  ```

### html 表单

* 概念
  
  * html 的表单元素 ， 网页中的表单用于将本地数据传单服务器·
  * 用户
    * 把传递给服务器的数据输入到这些元素中，当用户按下发送按钮或者触发表单发送操作，表单中的数据就会发给服务器
    * 数据以键值对的形式记录在请求的主体中，
  * HTTP 
    * 以 POST 请求的形式发送值服务器
  * 服务器
    * 接收数据，进行语法分析，提取键值对

* 类型
  
  ```html
  <form  action="/login" methohd="post" enctype=" 设置见 content type">
          action 表单提交的服务器的地址,服务器的文件地址,相当于 URL 的 path
      
      	input 标签 ：数据提交到服务器，必须要给元素指定 name 值
      	
          autocomplete="off"   关闭自动补全
          readonly            表单项目只读，数据不会提交
          disable                表单项目设置为禁用，数据不会提交
          autofocus            设置表单项自动获取焦点
  ```
  
        文件file 
            <input type=file name="filename">
            注意这个要设置 content type
        文本框  
            <input type="text" name="">
        密码框 
            <input type="password" name="">
        选择框
            单选按钮 :name 设置一样的，才会出现单选的情况 : v
                value 属性值最终会最为用户填写的值传给服务器：下面会把你选择的 a 或者 b 发给服务器
                checked 默认选择
                <input type="radio" name= "name" value="b">
                <input type="radio" name= "name" value="a" checked>
                // 
            多选框按钮 ：
                <input type="check" name="text" value="a">
                   <input type="check"name="text" value="a">
        邮件：自动检查格式
            <input type="email">
        下拉列表 ： value 属性值最终会最为用户填写的值传给服务器
            <select name="haha">
                selected  默认选择的属性
                <option value="1" > 选项1</option>
                <option value="2">选项二</option>
            </select>
      
        提交按钮 <intput type="submit" value="哈哈">   value 设置提交按钮内的内容，默认是 提交
        重置按钮 <input type="reset" >
        普通按钮 <input type="button" value="按钮">
      
        <button type="submit" >提交</button>
        <button type="sreset" >重置</button>    
        <button type="button" >按钮</button>    
  
  

### 内容类型 content type

```go
<form  action="" methohd="post" enctype=" ">
enctype 属性 ： 决定 POST 请求在发送键值对时，要使用何种格式
    appplication/x-www-form-urlencoded
        默认属性值，格式就是 url 编码
        浏览器要支持： application/x-www-form-urlencoded 、 multipart/form-data 两种编码方式
        表单中的数据编码为一个连续的 "长查询字符串(long query string)" 
        使用 ：简单文本，
    mutipart/form-data
        表中数据转换成一条 MIME 报文，键值对都带有他们自身的内容类型、内容配置
        大量数据：上传文件

长查询字符串 long query string
    不同键值对使用 & 符号分割，值和键用等号(=)分割
method="get"
    请求不包含请求主体，表单数据将以键值对的形式包含在请求的 URL 中，而不是通过主体传递
```

## golang 操作表单

### 请求处理

![image-20201111115750021](image-20201111115750021.png)

#### 获取 Json 数据

* 注意
  
  ```go
  使用ParseForm方法
      无法获取 Json 数据
          无法从 Angular 客户端发送的POST请求中获取数据的
      可以获取
          jQuery这样的JavaScript库却不会出现这样的问题。
  ```

![image-20201111120523186](image-20201111120523186.png)

### 返回响应

* 流程
  
  * 服务器使用 ResponseWriter 接口，向客户端返回响应
    
    ```go
    处理器调用给接口   --   创建 HTTP 响应（调用 http.response）
    ```

* 方法
  
  ```go
  ResponseWriter {
      // 将数组中的字节写入 HTTP 响应主体
      // 没有设置首部对应的内容类型，响应的内容类型将通过检测被写入的前 512 字节决定
      Write([]byte)  
  
      // 接收代表响应状态那的整数作为参数，改参数作为返回状态码
      // 调用该方法后，不可以对首部进行写入操作，默认是 200 OK 作为响应码
      WriterHeader()
  
      // 取得首部组成的映射，修改次映射就可以修改首部，修改后就被包含在 HTTP 响应中，被发送出去
      Herder()
  }
  ```

## go 的 cookie

### cookie 结构体

```go
// 可以查看 cookie 的结构体
Expires
    没设置 
        ：会话 cookie  , 该种类的 cookie 会在浏览器关闭的时候被自动移除
    设置
        ：持久 cookie  , 一直存在，直到指定的过期时间来临或者被手动删除

cookie 过期时间
    expires 
        指明 cookie 在什么时候过期
    MaxAge
        cookie 在被浏览器创建出来之后能够存活多少秒
    这两个字段是因为浏览器和 HTTP 半本支持的原因，可以只使用 expires 或者两个都使用
```

### cookie 发送到浏览器

```go
w http.ResponseWriter

// 结构体序列化
cookie{}.string()
    返回一个序列化处理的 cookie 

// 设置 cookie 值
w.Header().Set("Set-Cookie", cookie{}.string())
w.Header().Add("Set-Cookie", cookie{}.string())
http.SetCookie(w,&http.cookie{})
    set-cookie 响应首部的值，就是这些序列化的值
```

### 从浏览器获取 cookie

```go
r http.Request

r.Header["Cookie"]
    返回一个 []string ,其中字符串包含额客户端发送的任意多个 cookie
    要得到单独的键值对 , 需要对字符串进行语法分析

r.Cookie("cookie字段")
    获取指定名字的 cookie ,如果不存在，则返回一个错误
r.cookies()
    返回一个包含所有 cookie 的切片，此切片和访问 Header 字段是相同的
```

### 使用 cookie 实现闪现消息

```go
闪现消息 flash message
    程序在在某个条件被满足的时候，在页面上显示一条临时出现的消息，这样在用户刷新页面之后，就不会再看到相同的消息，
    这种临时出现的消息 ，被称为闪现消息
```

* 实现
  
  ```go
  实现
      把这些消息存储在页面刷新是就会被移除的会话 cookie 里面
  
  func main(){
      server := htto.Server{
          Addr:"127.0.0.1:8080",
      }
      http.HandleFunc("/set_message",setMessage)
      http。HandleFunc("/show_message",showMessage)
  }
  
  func setMessage(w http.ResponseWriter, r *http.Rquest) {
      msg := []byte("hello world")
      c := http.Cookie {
          Name:"flash",
          // 使用 Base64URL 编码，满足响应首部对 cookie 值的影响
          // 这是为了处理闪现消息中的空格百分号，闪现消息必不可少的
          Value:base64.URLEncoding.EncodeToString(msg),
      }
      http.SetCookie(w,&c)
  }
  ```
  
    func showMessage(w http.ResponseWriter,r *http.Request) {
  
        c , err := r.Cookie("flash")
        if err != nil {
            if err == http.ErrNoCookie {
                fmt.Fprintln(w,"No message found")
            }
        } else {
            rc := http.Cookie{
                Name:"flash",
                MaxAge:-1,
                Expires:time.Unix(1,0),
            }
            http.SetCookie(w,&rc)
            val,_ := base64.URLEncoding.DecodeString(c.Value)
            fmt.Fprintln(w,string(val))
        }
  
    }
  
    // showmessage
  
  1. 获取指定的 cookie 
      找不到，就返回错误 http.ErrNoCookie 并返回 nno message found
      找到
     
          1.创建一个同名 cookie , 将 MaxAge 设置为负数，Expires 设置成一个过去的时间（设置同名的cookie,程序成功使用新的cookie代替了旧的cookie,同时新 cookie 的maxage为负值，expires是过时的时候，相当于命令浏览器删除这个 cookie ， 新设置的也没了）
          2.使用 setcookie 方法将刚才创建的同名 cookie 发送给客户端
     
     ```
     
     ```

## text_template

* 模板
* 动作

## net_http

* 请求处理
