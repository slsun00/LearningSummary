## 客户端

### 流程

```gi
1. 输入文件路径，进行路径解析
	  + 文件路径

2. 获取  文件名 + 内容
	1. 写入文件名字
	2. 读取 服务器 接收到的信息
	3. 写入文件内容
		打开文件(defer close() )  -- 循环 | 读取(read)  + 发送(write) -
		

 net.Dail   -- 准备发送信息  -- 接收信息
			获取名字 - 发送名字 - 服务端收到信息 - 读取内容 - 发送内容
```



### demo

```go
package clent

import (
	"fmt"
	"io"
	"net"
	"os"
)

func main(){
	// 提示输入文件
	fmt.Println("请输入需要传输的文件")
	var path string
	fmt.Scan(&path)


	// 获取文件名 info.Name
	info , err := os.Stat(path)
	if err != nil {
		fmt.Println("os.Stat err = ",err)
		return
	}

	// 主动连接服务器
	conn , err := net.Dial("tcp","localhost:8080")
	if err != nil {
		fmt.Println("net.Dial")
		return
	}
	defer conn.Close()


	// 给接收方 ，先给名字
	_ , err = conn.Write([]byte(info.Name()))
	if err != nil {
		fmt.Println("conn.Write err=",err)
		return
	}

	buf := make([]byte,1024)
	n , err := conn.Read(buf)
	if err != nil {
		fmt.Println("conn.Read err= ",err)
		return
	}
	if string(buf[:n]) == "ok" {
		send(path,conn)
	}

}

func send(path string,conn net.Conn) {
	// 以只读文件打开文件
	f , err := os.Open(path)
	if err != nil {
		fmt.Println("os.Open err=",err)
		return
	}
	defer f.Close()

	// 读文件内容 ，读多少，就发送多少
	buf := make([]byte,1024*4)
	for {
		n , err := f.Read(buf)
		if err != nil {
			if err == io.EOF {
				fmt.Println("文件发送完毕")
			} else {
				fmt.Println("f.Read err = ", err)
			}
			retur
		}
		// 服务器发送
		conn.Write(buf[:n])
	}

}

```



## 服务端

### 流程

```go
net.Listen - listener.Accept  -  读取内容  - 发送内容

接收名字 - 发挥收到信息 -  创建文件 - 读取内容  - 内容写入文件 
```

### demo

```go
package main

import (
	"fmt"
	"io"
	"net"
	"os"
)


func HandErr(err error,info string ) {
	if err != nil {
		errstr := fmt.Sprintf("%s err =",info ,err )
		fmt.Println(errstr)
	}
}


func main(){
	// 监听
	listener , err := net.Listen("tcp","localhost:8080")
	if err != nil {
		fmt.Println("net.Listen err=",err)
		return
	}
	defer listener.Close()


	// 阻塞等待用户连接
	conn,err := listener.Accept()
	if err != nil {
		fmt.Println("listener.Accept err",err)
		return
	}

	// 读取信息
	buf := make([]byte,1024)
	n , err := conn.Read(buf)
	if  err != nil {
		fmt.Println("conn.Read(buf) err=",err)
		return
	}

	filename := string(buf[:n])

	// 接收到名称，回复接收到的信息
	conn.Write([]byte("ok"))

	// 接收文件
	RecvFile(filename,conn)

}
func RecvFile(filename string,conn net.Conn) {
	f , err := os.Create(filename)
	if err != nil {
		fmt.Println("os.Create(filename) err=",err)
		return
	}
	buf := make([]byte,1024*4)
	for {
		n , err := conn.Read(buf)
		if err != nil {
			if err != io.EOF{
				fmt.Println("文件接收完毕")
			} else {
				fmt.Println("conn.Read(buf) err=",err)
				return
			}
		}

		if n == 0 {
			fmt.Println("文件接收完毕")
			return
		}
		// 网文件写入内容
		f.Write(buf[:n])


	}
}

```



