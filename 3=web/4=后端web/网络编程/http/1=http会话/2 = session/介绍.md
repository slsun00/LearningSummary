## 介绍

```java
英文
	// HttpSession
   Session 就是会话， 

实质
    实质就是前端保存一个id，后端根据这个id来识别会话，存取数据
    
功能
    把一个个分离的HTTP请求关联起来，只要能实现这个功能，基本上都能叫Session的一种实现。
    
例子理解
    全国用户都向百度云发起请求， 
    百度云就根据所有请求中的 session 将请求进行分类
    （比如根据 session 挑选出都属于张三的 http 请求， 去操作属于张三的资源）
       
使用原因
	Cookie 有很多，就会增加客户端和服务端的数据传输量 ， 加以浏览器限制，我们不能在 Cookie 中存储过多信息
	在服务端存储用户数据，会传递一个特殊的 Cookie , 这个 Cookie 对应服务端一个 Session ,通过这个就可以找到用户信息，进而知道是哪个用户再发送请求  
    
区别 cookie
   Session是记录在服务端的，
   Cookie是记录在客户端的。    

使用场景
    当访问服务器否个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，
    而这个内存是跟浏览器(这个浏览器指的是浏览器窗口，或者是浏览器的子窗口)关联在一起的。
    
    只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。
    而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session    

```

## session 结构

```java
设置
    // session的ID号码，session的独一无二号码
    * 服务端会给它设置一个全球唯一的 ID（可用UUID设置）
    * 存储在服务端, 经常用来保存用户登录之后的信息
    * 底层是基于 Cookie 技术实现的
值
    // 服务器里面的一块内存，内存里面能放任何东西，只要是名值对就可以了。
    session里面的名字永远都是String类型
    
场景描述
    当访问一个页面的时候给浏览器创建一个独一无二的号码，也给同时创建的session赋予同样的号码。
    这样就可以在打开同一个网站的第二个页面时获取到第一个页面中session保留下来的对应信息
    （理解：当访问第二个页面时将号码同时传递到第二个页面。找到对应的session。）。
    这个号码也叫sessionID，session的ID号码，session的独一无二号码。
```



## 应用实现

### 存储方式

```java
介绍
    服务端只是给 cookie 一个 sessionId，
    而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：
方式
	Redis（推荐）：
    	内存型数据库
    	以 key-value 的形式存，正合 sessionId-sessionData 的场景；
    	且访问快。
内存：
    直接放到变量里。一旦服务重启就没了
数据库：
    普通数据库。性能不高。
```



### 实现位置

```java
存放
    可以放在url后面，
    可以放在cookie里，
    甚至
    
实现方式有两种
    第一种：通过cookies实现
    第二种：通过URL重写来实现 
    第三种：可以放在header里
```



### cookie 实现

```java
方式
    session的id 放在cookie里面
	当允许浏览器使用cookie的时候，session就会依赖于cookies，
    当浏览器不支持cookie后，就可以通过第二种方式获取session内存中的数据资源。
原因
    临时 cookie 会在浏览器关掉的时候消失
    就是说session本来就是当浏览器关闭即消失的，所以可以用临时的cookie存放
```

### URL重写的方式

```java
介绍
    是通过硬编码的方式实现，各个语言实现的方式大同小异
    
// java 为例
通过response.encodeURL()方法
    // 作用
    1. 转码
    	转中文的编码，或者一些其他特殊的编码
    2. URL后面加入sessionID
    	// 每一次访问的时候都会将sessionID拼接在 url 后面传过来了， 没必要用 cookie 可
    	若想程序中永远支持session，那就必须加上encodeURL()，
    	当别人禁用了cookie，一样可以使用session。
```

### 规则

```java
如果浏览器支持cookie，创建session多大的时候，会被sessionID保存再cookie里。只要允许cookie，session就不会改变，如果不允许使用cookie，每刷新一次浏览器就会换一个session（因为浏览器以为这是一个新的链接）
如果不支持cookie，必须自己编程使用URL重写的方式实现session
Session不像cookie一样拥有路径访问的问题，同一个application下的servlet/jsp都可以共享同一个session，前提下是同一个客户端窗口。

    
// ===============================待整理
在Cookie里放个JSESSIONID，在服务器中存上状态，用户请求来了，根据JSESSIONID去服务器里查状态，这是Tomcat的实现方法。
    
把所有状态都存在Cookie里，服务器给个签名防止伪造，每次请求来了，直接从Cookie里提取状态，这是JWT的实现方法。

// 淘汰    
在Cookie里放个token，状态不存在中间件里，而是存在Redis里，这也是一种Session实现方法。
    
 
// 说法
<p>正确的说法是，把Session存储在Web中间件中（比如存储在Tomcat中），这种做法正在被淘汰，因为这种方案对负载均衡不友好，也不利于快速伸缩。</p>        
```

## 生命周期

### 介绍

```jav
没有设置保留时间
	窗口关闭就消失
要设置保留时间	
	
```

### session 失效

```java
	对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。
	是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。
	如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。
    恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。
```

## 执行流程

### session - cookie

```java
// 首次请求
客户端
    向服务端发送请求 
服务端
    创建 Session , 再创建一个 cookie, cookie 的 Value 值是 SessionID
    SessionID (通过 cookie )包含到HttpResponse 响应到客户端
    响应头中有 set-Cookie ,
客户端
    接收存储 Cookie，
// 其他请求
客户端
    向服务端发送请求 
    请求头中就包含 Cookie , cookie 中有  sessionID 

服务端

    接收请求，cookie 的 Value 值是 Session 的 ID,  区分不同用户    
```

### 底层流程

```java
前提
    这个是以 java 的逻辑来分析的， 其实都一样
服务端
// 写入 session 列表
    服务器对当前应用中的 Session 是以 map 的形式管理的， 这个 map 称为 Session 列表
	该 map 的 key 为一个 32 位长度的随机串， 
    	这个随机串称为 JSession, 
		value 为 Session 对象的引用
    
    当用户第一次提交请求的时候， 
        服务端 Servlet 中执行到 request.getSession() 方法后， 会自动生成一个 Map.Entry 对象， 
        key 是根据某种算法新生成的 JSessionID
        value 是为新常见的 HttpSession 对象
// 服务端生成发送 cookie
	在将 Session 信息写入到 Session 列表中， 系统还会自动
        将 JSESSIONID 作为 name, 
	    这个 32 位长度的随机串作为 value
        以 cookie 的形式存放到响应报头中， 并随着响应， 并将 Cookie 发送到客户端                                  
            
客户端
//	接收发送 cookie
    客户端接收到这个 cookie 后， 会将其存放到浏览器的缓存中 
        即：只要客户端浏览器不关闭，浏览器缓存的 cookie 就不会消失
    当用户发送第二次请求时， 会将缓存中的这个 cookie ，伴随着请求投中的头部信息，一块发送给服务端 
            
            
//  从 session 列表中查找
	服务端从请求中读取到客户端发送过来的 cookie ，并根据 cookie 的 JSSESSIONID 的值，
     从 Map 中查找响应 key 对象的 value , 即 Session 对象的域属性进行读写操作            
```

## 不同语言实现

### java

```java
// java 中的一些关于 session 的方法
    isNew()：是否是新的Session，一般在第一次访问的时候出现
    getid()：拿到session，获取ID
    getCreationTime()：当前session创建的时间
    getLastAccessedTime()：最近的一次访问这个session的时间。
    getRrquestedSessionid： 跟随上个网页cookies或者URL传过来的session
    isRequestedSessionIdFromCookie()：是否通过Cookies传过来的
    isRequestedSessionIdFromURL()：是否通过重写URL传过来的
    isRequestedSessionIdValid()：是不是有效的sessionID
```



## 有问题

### 问题一

```java

	我们一开始也是想存redis里，但有一个问题，那就是如何保证session强一致性(非最终一致性)，
     毕竟redis本身可能会性能不足开集群。考虑过通过账户或者ip哈希，但这样如果集群数量发生增加时，旧的session就会无法命中了
    
这个技术nginx有很成熟的实现        
```



## 待总结

```java
我就是session，要说这玩意过时，如果http改成有状态的我就信它会过时，否则我不信，做web也好app也罢，都是清一色session记录身份，都是个header头而已，主要便于控制，数据库登录时记录个session id，再次登录时若session id和数据库的不一样就删除旧的让原来的失效
    
用哪种方案和分布式关系不大，主要还是看需要多大的控制力，如果系统要限制用户的访问，无论如何也不可能用纯粹的token    
```



































































