

## 注意

```java
需要看下java 中 cookie session token 是如何实现的
```



## 理解

### 介绍

```java
概述
    // 都是在各自语言实现的 web 服务器上设置 的， 看各个语言的实现
    不管是 cookie session token 都是后端进行设置的，在后端设置好了，然后返回给前端
    都是通过服务器进行管理设置的， 是在 request 中设置的
    
    cookie
    session
    token

业务
    业务上主要是用于请求的时候，进行登陆验证，这个是主要的内容
    // 就是说请求之前，需要通过这三个东西，来验证它已经登陆了，可以进行访问
    所以所有的应用都是：利用登陆的模块进行解释的 
    
特例
    前端也可以进行设置，这个之后在说
    
```



### 场景理解

```java
不管是啥
    都是在服务器进行的一个设置，服务器设置了一个标识，客户端拿到这个标识， 用于自我的鉴别
例子
    // 你： 客户端   ， 银行： 服务端
    // 一手交钱一手交货、银票行 、 银行卡 、支付宝
    
    
    // 银行卡
    // 支付宝
古代
    由于银子自己放着会
    
    	
    
cookie
    服务端写的一个字符串，
```

### 使用理解

```java

```



## 前后端鉴权方案

```java
常见的前后端鉴权方式
Session-Cookie
Token 验证（包括 JWT，SSO）
OAuth2.0（开放授权）
```



## 辨析

### session & token

```java
介绍
    session 和 token 都是边界很模糊的概念，
    就像前面说的，refresh token 也可能以 session 的形式组织维护。
    
狭义上，
     session 是「种在 cookie 上、数据存在服务端」的认证方案，
     token 是「客户端存哪都行、数据存在 token 里」的认证方案。    
    
本质上是
    「客户端存 cookie / 存别地儿」
    「服务端存数据 / 不存数据」
    
// 客户端存 cookie / 存别地儿
 客户端存 cookie
    1. 便不操心，但问题也很明显
    2. 在浏览器端，可以用 cookie（实际上 token 就常用 cookie），但出了浏览器端，没有 cookie 怎么办？
    	cookie 是浏览器在域下自动携带的，这就容易引发 CSRF 攻击
存别的地方
    可以解决没有 cookie 的场景；通过参数等方式手动带，可以避免 CSRF 攻击。 
    
// 服务端存数据 / 不存数据  
存数据：
    请求只需携带 id，可以大幅缩短认证字符串长度，减小请求体积
不存数据：
    不需要服务端整套的解决方案和分布式处理，降低硬件成本；避免查库带来的验证延迟
```



## // === 待总结

```java
HTTP 是无状态的，为了维持前后请求，需要前端存储标记
cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石
session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题
token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性
token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案
在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验
session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比
单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket
    
    
    
    
    Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。
Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。
所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。
    
    
// Token 和 JWT 的区别    
相同：

都是访问资源的令牌
都可以记录用户的信息
都是使服务端无状态化
都是只有验证成功后，客户端才能访问服务端上受保护的资源
区别：

Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。    
```



* 很久以前
    * Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器，
    *  不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应，
    *  尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的
* 交互式Web应用
    * 面临网站登陆、购物信息的记录等问题，又因为 http 请求是无状态的。于是发明了 session
    * 解决 cookie 存储信息过少、被滥用的问题
* 用户爆发增长
    * 每个人只需要保存自己的session id，而服务器要保存所有人的session id ！
    *   如果访问服务器多了， 就得由成千上万，甚至几十万个。
    * 负载均衡
    *  redis 缓存
* 分布式 web 应用
    * 单点的机器也搞出集群，



## 考虑的问题

```java
// 使用 cookie 时需要考虑的问题
因为存储在客户端，容易被客户端篡改，使用前需要验证合法性
不要存储敏感数据，比如用户密码，账户余额
使用 httpOnly 在一定程度上提高安全性
尽量减少 cookie 的体积，能存储的数据量不能超过 4kb
设置正确的 domain 和 path，减少数据传输
cookie 无法跨域
一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token
使用 session 时需要考虑的问题

// session 问题
将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session
当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。
当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。
sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现
移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token
使用 token 时需要考虑的问题
如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
token 完全由应用管理，所以它可以避开同源策略
token 可以避免 CSRF 攻击(因为不需要 cookie 了)
移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token
使用 JWT 时需要考虑的问题

// jwt 问题
因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
JWT 不加密的情况下，不能将秘密数据写入 JWT。
JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

// 使用加密算法时需要考虑的问题
绝不要以明文存储密码
永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。
绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。
绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 一次性的（这点很重要）密码，然后把这个密码发送给用户。
```

## 问题一

```java
清cookie不行啊，假设一个用户遇到了某个可能泄露cookie的场景，于是选择了退出登录，即使清除了cookie，泄露的cookie还是有效的，如果更换了密钥，那么如果有其他用户正在通过网页做些实时操作（比如说在线面试/考试），这些用户会瞬间掉线，这种情况不可接受。而且session的key必须带上时间戳或者别的方法来保证自己生成的所有key不可能重复
    
另外B/S下cookie盗用要么跨站脚本，要么跨域请求伪造，要么中间人/重放，中间人和重放只能靠https来，跨站脚本用http only cookie，跨域请求伪造用严格同源。

如果你是说用户自己看token，那么这里的问题是防止用户看到敏感信息，和防止token伪造，token伪造要靠签名来防止，另外整个jwt可以再加一层加密，装作是session id。这也是为什么签名密钥和加密密钥必须定期更换的原因。
    
我目前基本不用服务端的session来保存任何东西，浪费内存，集群技术性上会有不确定性问题，相反我喜欢用算法生成特定的id，和服务端通信，确认请求有效性和安全性，性能比session更优，当然也否认答主提出的在header里面写id，认为是session的思想，因为业务上比如防止post表单验证，支付请求安全验证，批量文件上传等等不用的富应用交互不用程度都会写header，它们并不是session的概念。
    
    
可能我说的有点偏激了，并不是指只要在header里加id就是session。现在流行stateless，但有些操作必须要有状态，有会话才行，如获取短信验证码，生成验证码到验证，这两个操作必须要在同一个会话进行，前后端分离时，生成验证码放入缓存，给前台返回字符串，验证时携带在header里，在我看来这就是session。而token缺点也很明显，服务器端没有控制权，只是我觉得这点弊大于里，可能场景不同，对不同的重视程度也不同吧
    
    
// session 能做把另一个设备挤下线嘛？
如果已经在A点登录，有一个session，B新登录时只要把A的session清除就可以了。关键就在于你怎么找到A的session，这取决你的持久化方案或者session Id的生成方案。
    
    
```

