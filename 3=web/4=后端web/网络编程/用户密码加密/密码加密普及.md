## 需要总结

```java
ref:http://www.infoq.com/cn/articles/how-to-encrypt-the-user-password-correctly/
https://blog.csdn.net/zhouyan8603/article/details/80473083
这是对这篇文章的总结
```

## 写在首位

```java
// 请放弃编写自己的密码哈希加密代码的念头！
// 因为这件事太容易搞砸了。就算你在大学学过密码学的知识，也应该遵循这个警告    
所有人都要谨记这点：
	不要自己写哈希加密算法！ 存储密码的相关问题已经有了成熟的解决方案，
    就是使用 phpass，或者在 defuse/password-hashing 或 libsodium 上的 PHP 、 C# 、 Java 和 Ruby 的实    
```



## 密码使用过程

```java
1. 用户创建自己的帐号。
2. 密码经过哈希加密后存储在数据库中。密码一旦写入到磁盘，任何时候都不允许是明文形式。
3. 当用户试图登录时，系统从数据库取出已经加密的密码，和经过哈希加密的用户输入的密码进行对比。
4. 如果哈希值相同，用户将被授予访问权限。否则，告知用户他们输入的登陆凭据无效。
	//  注意
    永远不要告诉用户输错的究竟是用户名还是密码。
    就像通用的提示那样，始终显示：“无效的用户名或密码。”就行了
	防止攻击者在不知道密码的情况下枚举出有效的用户名。

5. 每当有人试图尝试登陆，就重复步骤3和4
```



## 哈希函数

### 介绍

```java
用来保护密码的哈希函数，和数据结构课学到的哈希函数是不同的。
数据结构的哈希
	目的是快速查找，而非安全性
密码保护的哈希
	只有加密哈希函数（ cryptographic hash function）才可以用来进行密码哈希加密
    像 SHA256 、 SHA512 、 RIPEMD 和 WHIRLPOOL 都是加密哈希函数。
```

### 破解

```java
md5
	网上有这种专门破解MD5的网站，只需提交一个哈希值，
    不到一秒钟就能得到破解的结果
字典攻击
	使用包含单词、短语、常用密码和其他可能用做密码的字符串的字典文件。
    对文件中的每个词都进行哈希加密，将这些哈希值和要破解的密码哈希值比较。
    如果它们相同，这个词就是密码。
    字典文件是通过大段文本中提取的单词构成，甚至还包括一些数据库中真实的密码。
    还可以对字典文件进一步处理以使其更为有效：如单词 “hello” 按网络用语写法转成 “h3110” 。
    
暴力破解
	对于给定的密码长度，尝试每一种可能的字符组合。
    这种方式会消耗大量的计算，也是破解哈希加密效率最低的办法，但最终会找出正确的密码。
    因此密码应该足够长，以至于遍历所有可能的字符组合，耗费的时间太长令人无法承受，从而放弃破解。

    
查表法（ Lookup Tables）
	破解相同类型的哈希值，查表法是一种非常高效的方式。
    主要理念是预先计算（ pre-compute）出密码字典中的每个密码的哈希值，
    然后把他们相应的密码存储到一个表里。
    一个设计良好的查询表结构，即使包含了数十亿个哈希值，仍然可以实现每秒钟查询数百次哈希。
    
反向查表法（ Reverse Lookup Tables）
	允许攻击者无需预先计算好查询表的情况下同时对多个哈希值发起字典攻击或暴力攻击。
	首先，攻击者从被黑的用户帐号数据库创建一个用户名和对应的密码哈希表，
    然后，攻击者猜测一系列哈希值并使用该查询表来查找使用此密码的用户。
    通常许多用户都会使用相同的密码，因此这种攻击方式特别有效。
    
彩虹表（ Rainbow Tables）
	是一种以空间换时间的技术。
    与查表法相似，只是它为了使查询表更小，牺牲了破解速度。
    因为彩虹表更小，所以在单位空间可以存储更多的哈希值，从而使攻击更有效。
    能够破解任何最多8位长度的 MD5 值的彩虹表已经出现。
    
总结
	// 没有办法来组织字典攻击或暴力攻击。只能想办法让它们变得低效      
```



### 哈希碰撞

```java
介绍
    指存在一个和用户密码不同的字符串，却有相同的哈希值
原因
    哈希函数将任意大小的数据转化为定长的字符串，因此，必定有一些不同的输入经过哈希计算后得到了相同的字符串的情况
    加密哈希函数（ Cryptographic hash function）的设计初衷就是使这些碰撞尽量难以被找到
缺点
    密码学家发现攻击哈希函数越来越容易找到碰撞了。
    最近的例子是MD5算法，它的碰撞已经实现了。
现状
    即使是像MD5这样的脆弱的哈希函数找到碰撞也需要大量的专门算力（ dedicated computing power），
    所以在实际中“意外地”出现哈希碰撞的情况不太可能
实用性
    加盐 MD5 和加盐 SHA256 的安全性一样。
    尽管如此，可能的话，要使用更安全的哈希函数，比如 SHA256 、 SHA512 、 RipeMD 或 WHIRLPOOL 。
```



## 加盐加密

### 加盐哈希

```java
// 加盐哈希（ Hashing with Salt）
盐值
    使用加密的安全伪随机数生成器产生。
    
  
加盐（ salting）
	// 让查表法和彩虹表都失效。
    通过在密码中加入一段随机字符串再进行哈希加密，这个被加的字符串称之为盐值
    这使得相同的密码每次都被加密为完全不同的字符串。我们需要盐值来校验密码是否正确。
    通常和密码哈希值一同存储在帐号数据库中，或者作为哈希字符串的一部分。
    盐值无需加密。
    	由于随机化了哈希值，查表法、反向查表法和彩虹表都会失效
        因为攻击者无法事先知道盐值，所以他们就没有办法预先计算查询表或彩虹表
        如果每个用户的密码用不同的盐再进行哈希加密，那么反向查表法攻击也将不能奏效
```

### 安全伪随机数生成器

```java
// Cryptographically Secure Pseudo-Random Number Generator，CSPRNG 
介绍   
    CSPRNG和普通的伪随机数生成器有很大不同，如“ C ”语言的rand()函数
     CSPRNG 被设计成用于加密安全，这意味着它能提供高度随机、完全不可预测的随机数
    
下表列出了一些当前主流编程平台的 CSPRNG 方法    
```



| Platform                          | CSPRNG                                                |
| --------------------------------- | ----------------------------------------------------- |
| PHP                               | mcrypt_create_iv, openssl_random_pseudo_bytes         |
| Java                              | java.security.SecureRandom                            |
| Dot NET (C#, VB)                  | System.Security.Cryptography.RNGCryptoServiceProvider |
| Ruby                              | SecureRandom                                          |
| Python                            | os.urandom                                            |
| Perl                              | Math::Random::Secure                                  |
| C/C++ (Windows API)               | CryptGenRandom                                        |
| Any language on GNU/Linux or Unix | Read from /dev/random or /dev/urandom                 |

### 错误加盐

#### 盐值复用

```java
// 盐值复用（ Salt Reuse）
介绍
    每次都使用相同的盐值进行哈希加密，这个盐值要么被硬编码到程序里，要么只在第一次使用时随机获得
处理
    用户创建帐号或者更改密码时，都应该用新的随机盐值进行加密
缺点
    如果两个用户有相同的密码，他们仍然会有相同的哈希值。
    攻击者仍然可以使用反向查表法对每个哈希值进行字典攻击。
    他们只是在哈希密码之前，将固定的盐值应用到每个猜测的密码就可以了。
    如果盐值被硬编码到一个流行的软件里，那么查询表和彩虹表可以内置该盐值，以使其更容易破解它产生的哈希值。
```

#### 短盐值

```java
// 短盐值（ Short Slat）
介绍
    
缺点
    盐值太短，攻击者可以预先制作针对所有可能的盐值的查询表
例子
    如果盐值只有三个 ASCII 字符，那么只有 95x95x95=857,375种可能性。
    这看起来很多，但如果每个查询表包含常见的密码只有 1MB，857,375个盐值总共只需 837GB，一块时下不到100美元的 			1TB硬盘就能解决问题了。
```

#### 用户名用作盐值

```java
对每一个服务来说，用户名是唯一的，但它们是可预测的，并且经常重复应用于其他服务。
攻击者可以用常见用户名作为盐值来建立查询表和彩虹表来破解密码哈希。
```

#### 古怪哈希的算法组合

```java
介绍
    尝试不同的哈希函数相结合一起使用，希望让数据会更安全
做法    
    永远不要试图去创造你自己的哈希加密算法，要使用专家设计好的标准算法    
    
缺点
    1. 并没有什么好处。它带来了函数之间互通性的问题，而且甚至可能会使哈希变得更不安全。
    2. 创造新的哈希函数，可能会带来风险，构造希函数的组合又会导致函数互通性的问题。
    	它们带来一点的好处和这些比起来微不足道
原因
    要考虑到柯克霍夫原则，攻击者通常会获得源代码（尤其是免费或者开源软件）。
    通过系统中找出密码-哈希值对应关系，很容易反向推导出加密算法。
错误例子
    // 不要使用其中任何一种。
    md5(sha1(password))
	md5(md5(salt) + md5(password))
```



### 正确加盐

#### 概述

```java
1. 盐值必须足够长。一个好的经验是使用和哈希函数输出的字符串等长的盐值
    攻击者无法构造包含所有可能盐值的查询表
     SHA256 的输出为256位（32字节），所以该盐也应该是32个随机字节。
//========== 概述 ===========
1. 每个用户的每一个密码都要使用独一无二的盐值。
2. 用户每次创建帐号或更改密码时，密码应采用一个新的随机盐值。
3. 永远不要重复使用某个盐值。
4. 这个盐值也应该足够长，以使有足够多的盐值能用于哈希加密。
    一个经验规则是，盐值至少要跟哈希函数的输出一样长。该盐应和密码哈希一起存储在用户帐号表中。    
5. 在 Web 应用中，永远在服务端上进行哈希加密     
```

#### 加密位置

```java
浏览器
    JavaScript哈希加密
服务端
    将得到的密码哈希值再进行一次哈希加密
原因
    如果一个攻击者得到了用户的哈希值，他们可以用它来通过认证，而不必知道用户的明文密码！
    所以，如果攻击者使用某种手段拖了网站的数据库，他们就可以随意使用每个人的帐号直接访问，而无需猜测任何密码。
    
浏览器中进行哈希加密
1. 客户端密码哈希加密不是 HTTPS（SSL/TLS）的替代品。
    如果浏览器和服务端之间的连接是不安全的，那么中间人攻击可以修改 JavaScript 代码，删除加密函数，
    从而获取用户的密码。
2. 某些浏览器不支持 JavaScript ，还有一些用户在浏览器中禁用 JavaScript 功能。
    因此，为了更好的兼容性，您的应用应该检测浏览器是否支持 JavaScript ，
    如果不支持，就需要在服务端模拟客户端进行哈希加密。
3. 客户端的哈希加密同样需要加盐。
    显而易见的解决方案是使客户端脚本向服务端请求用户的盐值。
    // 但是不提倡这样做，因为它可以让攻击者能够在不知道密码的情况下检测用户名是否有效。
    既然你已经在服务端上对密码进行了加盐哈希（使用合格的盐值），
    那么在客户端，将用户名（或邮箱）加上网站特有的字符串（如域名）作为客户端的盐值也是可行的。
```

#### 其他注意

```java
// 盐值应该加到密码之前还是之后？
无所谓，选择一个并保持风格一致即可，以免出现互操作方面的问题。
盐值加到密码之前较为普遍
    
// 为何本文的哈希代码都以固定时间比较哈希值？
    使用固定的时间来比较哈希值可以防止攻击者在在线系统使用基于时间差的攻击，
    以此获取密码的哈希值，然后进行本地破解。
    
// 场景补充
    假设攻击者试图入侵一个在线系统，这个系统限制了每秒只能尝试一次用户认证。还假设攻击者已经知道密码哈希所有的参数（盐值、哈希函数的类型等），除了密码的哈希值和密码本身。如果攻击者能精确测量在线系统耗时多久去比较他猜测的密码和真实密码，那么他就能使用时序攻击获取密码的哈希值，然后进行离线破解，从而绕过系统对认证频率的限制。
    首先攻击者准备256个字符串，它们的哈希值的第一字节包含了所有可能的情况。他将每个字符串发送给在线系统尝试登陆，并记录系统响应所消耗的时间。耗时最长的字符串就是第一字节相匹配的。攻击者知道第一字节后，并可以用同样的方式继续猜测第二字节、第三字节等等。一旦攻击者获得足够长的哈希值片段，他就可以在自己的机器上来破解，不受在线系统的限
    在网络上进行这种攻击似乎不可能。然而，有人已经实现了，并已证明是实用的。这就是为什么本文提到的代码，它利用固定时间去比较字符串，而不管有多大的字符串。
```



#### 业务

```java
1. 密钥必须被存储在外部系统，例如专用于密码验证一个物理上隔离的服务端，或者连接到服务端
```





### 密码存取

```java
// 存储密码
1. 使用 CSPRNG 生成足够长的随机盐值。
2. 将盐值混入密码，并使用标准的密码哈希函数进行加密，如Argon2、 bcrypt 、 scrypt 或 PBKDF2 。
3. 将盐值和对应的哈希值一起存入用户数据库。
    
// 校验密码
1. 从数据库检索出用户的盐值和对应的哈希值。
2. 将盐值混入用户输入的密码，并且使用通用的哈希函数进行加密。
3.  比较上一步的结果，是否和数据库存储的哈希值相同。
    如果它们相同，则表明密码是正确的；否则，该密码错误。    
```

## 密钥扩展技术

```java
介绍
    // 高端显卡（ GPU ）和定制的硬件每秒可以进行十亿次哈希计算
    为了降低使攻击的效率，我们可以使用一个叫做密钥扩展（ key stretching）的技术， 使密码更难破解
    终极目标
    	使哈希函数的速度慢到足以令攻击者放弃，
    	由此造成的延迟又不至于引起用户的注意
实现
    使用了一种 CPU 密集型哈希函数（ CPU-intensive hash function）
    这类算法采取安全因子或迭代次数作为参数。此值决定哈希函数将会如何缓慢。
    
缺点
    需要额外的计算资源来处理大量的身份认证请求，
    并且密钥扩展也容易让服务端遭受拒绝服务攻击（ DoS ）
调整
    1.要设定较低一些的迭代次数。
    	这个次数需要根据自己服务器的计算能力和预计每秒需要处理的认证请求次数来设置
    2. 消除拒绝服务的威胁可以通过要求用户每次登陆时输入验证码（ CAPTCHA ）来做到
    	系统设计时要将迭代次数可随时方便调整。
    3. 考虑在浏览器中使用 JavaScript 完成
    4. 如果用户的浏览器不支持 JavaScript ，服务端应该接手进行计算
    	客户端密钥扩展并不能免除服务端端进行哈希加密的需要。
    	你必须对客户端生成的哈希值再次进行哈希加密，就跟普通口令的处理一样。
    	
```

## 密码哈希设备

```java
介绍
    // 专用于密码验证一个物理上隔离的服务端，或者连接到服务端
    一个特殊的硬件设备，如 YubiHSM 。
    建议所有大型服务（超过10万用户）使用这种方式。我认为对于任何超过100万用户的服务托管是非常有必要的。
    
补充
    // 难以负担多个服务端或专用硬件的费用
    1. 不要给攻击者进入本地文件系统的权限（禁止数据库服务访问本地文件系统，如果有此功能的话）
    2. 生成一个随机密钥并将其存储在一个通过 Web 无法访问的文件上，然后进行加盐哈希加密，
    	那么得到的哈希值就不会那么容易被破解了
    3. 不要将密钥硬编码到代码中，应该在安装应用时随机生成

注意
    密钥哈希并不意味着无需进行加盐， 对密码哈希仍然需要进行加盐和密钥扩展，这一点非常重要
    
其他方式： 保证密码哈希值（和其他用户数据）不被窃取
    
```

## 总结

### 哈希算法使用

```java
// 可以使用
    精心设计的密钥扩展算法如 PBKDF2 、bcrypt 和 scrypt 。
    OpenWall的的 Portable PHP password hashing framework。
    PBKDF2在PHP、C＃、Java和Ruby的实现。
    crypt 的安全版本。
// 不可使用
	快速加密哈希函数，如 MD5 、SHA1、SHA256、SHA512、RipeMD、WHIRLPOOL、SHA3等。
    crypt()的不安全版本。
    任何自己设计的加密算法。只应该使用那些在公开领域中的、由经验丰富的密码学家完整测试过的技术。     
// 观点        
	目前还没有一种针对MD5或SHA1非常高效的攻击手段，
    但它们过于古老以至于被广泛认为不足以用来存储密码（可能有些不恰当）。
    所以我不推荐使用它们。但是也有例外，PBKDF2中经常使用SHA1作为它底层的哈希函数        
```

### 密码重置

```java
介绍
    当下所有广泛使用的密码重置机制都是不安全的。
    如果你对高安全性有要求，如加密服务，那么就不要让用户重设密码。
方法
    
    记得在用户重置密码时随机生成一个新的盐值用来加密，不要重复使用已用于密码哈希加密的旧盐值。
原因
    // 忘记密码大多是用户发送电子邮件来进行身份确认。
    做到这一点，需要随意生成一个一次性使用的令牌， 接关联到用户的帐号。然后将这个令牌混入一个重置密码的链接中，发送到用户的电子邮箱。
    当用户点击包含有效令牌的密码重置链接，就提示他们输入新密码。确保令牌只对一个帐号有效，以防攻击者从邮箱获取到令牌后用来重置其他用户的密码。
    // 令牌必须在15分钟内使用，且一旦使用后就立即作废
    当用户登录成功时（表明还记得自己的密码）， 或者重新请求令牌时，使原令牌失效是一个好做法。如果令牌永不过期，那么它就可以一直用于入侵用户的账号
    电子邮件（SMTP）是一个纯文本协议，网络上有很多恶意路由在截取邮件信息。
    在用户修改密码后，那些包含重置密码链接的邮件在很长时间内缺乏保护，因此，尽早使令牌尽快过期，来降低用户信息暴露给攻击者的风险。
    // 攻击者能够篡改令牌，因此不要把帐号信息和失效时间存储在其中。
    它们应该以不可猜测的二进制形式存在，并且只用来识别数据库中某条用户的记录。
    // 千万不要通过电子邮件向用户发送新密码。
    记得在用户重置密码时随机生成一个新的盐值用来加密，不要重复使用已用于密码哈希加密的旧盐值。
```

### 帐号数据库被泄漏或入侵

```java
// 首要任务： 应该尽快通知用户。
例如在首页放置一个链接，指向对此问题更为详细的说明；
如果可能的话通过电子邮件发送通知给每个用户告知目前的情况。
    
// 通知内容
1. 密码是如何被保护的
    向用户说明他们的密码究竟是如何被保护的：最好是使用了加盐哈希。
    但是，即使用了加盐哈希，恶意黑客仍然可以使用字典攻击和暴力攻击    
2. 解释密码泄漏的危害, 修改相似密码
    如果用户在很多服务使用相同的密码，恶意黑客会利用他们找到的密码去尝试登陆其他网站。
    告知用户这个风险，建议他们修改所有类似的密码，不论密码用在哪个服务上。
    强制他们下次登录你的网站时更改密码。
3. 告诉你的用户，网站存储了哪些个人信息。
    如果您的数据库包括信用卡号码，您应该通知用户仔细检查近期账单并销掉这张信用卡。

// 随后处理
1. 大多数用户会尝试“修改”自己的密码为原始密码，以便记忆。
    您应该使用当前密码哈希值以确保用户无法做到这一点。    
2. 应该对这些密码的帐号发送认证电子邮件，直到用户修改了密码。
    
// 提前处理
    通过给数据库连接设置两种权限，防止密码哈希在遭遇注入攻击时被篡改。
    1. 一种权限用于创建用户，“创建用户”的代码应该能够读写用户表；
    	一种权限用于用户登陆，“用户登陆”的代码应该只能够读取用户表而不能写入。
    2. 
```

### 密码强度设置

```java
1. 如果您的服务没有严格的安全要求，那么不要对用户进行限制
    建议在用户输入密码时，页面显示出密码强度，由他们自己决定需要多安全的密码。
    特殊的安全需求，那就应该实施长度至少为12个字符的密码，并且至少需要两个字母、两个数字和两个符号。
    
2. 不要过于频繁地强制你的用户更改密码，最多每半年一次，超过这个次数，用户就会感到疲劳
    更好的做法是教育用户，当他们感觉密码可能泄露时主动修改，并且提示用户不要把密码告诉任何人
```



### 为何使用哈希

```java
用户在你的网站上输入密码，是因为他们相信你能保证密码的安全。
如果你的数据库遭到黑客攻击，而用户的密码又不受保护，那么恶意黑客可以利用这些密码尝试登陆其他网站和服务（大多数用户会在所有地方使用相同的密码）。
这不仅仅关乎你网站的安全，更关系到用户的安全。你有责任负责用户的安全。
```



## 需要总结

```java
即使是经验丰富的开发人员也必须学习安全知识，才能编写安全的应用。此处有关于Web应用漏洞的重要资源： The Open Web Application Security Project (OWASP)。还有一个很好的介绍： OWASP Top Ten Vulnerability List 。除非你理解了列表中的所有漏洞，否则不要去尝试编写一个处理敏感数据的Web应用程序。雇主也有责任确保所有开发人员在安全应用开发方面经过充分的培训。
    
对您的应用进行第三方“渗透测试”是一个很好的主意。即使最好的程序员也可能会犯错，所以，让安全专家审计代码寻找潜在的漏洞是有意义的。找一个值得信赖的机构（或招聘人员）来定期审计代码。安全审计应该从开发初期就着手进行，并贯穿整个开发过程。
    
    
监控您的网站来发现入侵行为也很重要。我建议至少雇用一名全职人员负责监测和处理安全漏洞。如果某个漏洞没被发现，攻击者可能通过网站利用恶意软件感染访问者，因此，检测漏洞并及时处理是极为重要的    
```

