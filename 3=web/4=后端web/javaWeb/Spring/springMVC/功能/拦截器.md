## 拦截器

### 介绍

```java
拦截器
    允许在目标方法之前执行一些拦截工作，或者目标方法之后进行一些其他处理
    filter	javaWeb
    拦截器	  springMVC

拦截器链（InterceptorChain） 
    将拦截器按一定的顺序联结成一条链，
	在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。
    拦截器也是AOP思想的具体实现。    
```

### 与过滤器区别

| **区别** | **过滤器**                                                | **拦截器**                                                   |
| -------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| 使用范围 | 是 servlet 规范中的一部分，任何 Java Web 工程都可以使用   | 是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用 |
| 拦截范围 | 在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截 | 只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的 |

### 单拦截器

```java
步骤
    创建拦截器类实现HandlerInterceptor接口
    配置拦截器
    测试拦截器的拦截效果
    
拦截器中的方法执行顺序

    preHandler
		目标方法之前执行，
    	返回 true 则 chain.doFilter() 放行，反之则不放行
    目标方法
		目标方法执行，目标资源
    postHandle
        目标方法之后执行
    afterCompletion
    	整个请求完成之后，来到目标页面之后，进行资源清理
    	chain.doFilter() 放行之后， 资源相应之后
    
// 实现 HandlerIntercepter
public class MyHandlerInterceptor1 implements HandlerInterceptor {
    //在目标方法执行之前 执行
    public boolean preHandle(
        HttpServletRequest request, 
        HttpServletResponse response, 
        Object handler
    	) {
            System.out.println("preHandle running...");
            String param = request.getParameter("params");
            if ("yes".equals(param)) {
                return true
            } else {
                request.getRequestDispatcher("/error.jsp").forward(request,response);
                return false;        // return false  表示不放行
            }
        }
    
    //在目标方法执行之后 视图对象返回之前执行
    public void postHandle(
         HttpServletRequest request, 
         HttpServletResponse response, 
         Object handler, 
         ModelAndView modelAndView
    	) {
        System.out.println("postHandle running...");    
    }
    
     //在流程都执行完毕后 执行
    public void afterCompletion(
        HttpServletRequest request,
        HttpServletResponse response, 
        Object handler, Exception ex
    ) {       
        System.out.println("afterCompletion running...");
    } 
    
// sprngMVC.xml 配置
<!--springMVC 配置拦截器-->
    <mvc:interceptors>
        // 拦截所有请求
        <bean class="com.itheima.interceptor.MyInterceptor1"/>
            
        // 具体拦截
        <mvc:interceptor>
            <!--对哪些资源执行拦截操作-->
            <mvc:mapping path="/**"/>
            <bean class="com.itheima.interceptor.MyInterceptor1"/>
        </mvc:interceptor>
    </mvc:interceptors>
   
// 测试
@Controller
public class TargetController {

    @RequestMapping("/target")
    public ModelAndView show(){
        System.out.println("目标资源执行......");
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("name","itcast");
        modelAndView.setViewName("index");
        return modelAndView;
    }

}        
```

### 多拦截器

```java
介绍
    和单拦截器的写法一摸一样，只是配置的时候，使用多个 <mvc:interceptor> 标签
执行顺序
	//         
	preHandler
		按照拦截器的配置的 正常顺序 执行
         所有的拦截器的 preHandler 都执行完全，才会往下执行
	方法执行
        
    postHandle
        所有放行的拦截器，按照拦截器的配置的  逆序 依次执行

    afterCompletion
		按照拦截器的配置的  逆序 执行     
	注意
        一个拦截器没有被放行：
        	其之后的拦截器都不能用
        	器之前放行的拦截器仍旧会执行
        
```



### 相关方法

| **方法名**        | **说明**                                                     |
| ----------------- | ------------------------------------------------------------ |
| preHandle()       | 方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法 |
| postHandle()      | 该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为true 时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作 |
| afterCompletion() | 该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行，前提是preHandle 方法的返回值为true 时才能被调用 |







