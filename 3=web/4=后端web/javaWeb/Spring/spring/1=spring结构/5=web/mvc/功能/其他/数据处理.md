  

## 数据处理

### 介绍

```java
介绍
    数据转换、数据格式化、数据校验
	javaBean 要和页面提交的数据进行一一转化
    数据绑定期间：
    	数据类型转换： String -- integer
    		conversionService
    	数据格式化问题: 2020:02:01 2020-01-02
            conversionService
    	数据校验是否正确: 前端校验 + 后端校验
            validators 数据校验
            bindingResult 负责保存及解析数据绑定期间产生的异常
```

### 数据转换

#### 自定义类型转换器

```java
介绍    
    Spring 定义了 3 种类型的转换器接口， 
    实现任意一个就注册到ConversionServiceFactroyBean 中    
    Converter<S,T>：    	 
    	将 S 类型对象转为 T 类型对象（基本只用这个）	
    ConverterFactory：   
    	将相同系列多个 “同质” Converter 封装在一起。         
    	如果希望将一种类型的对象转换为另一种类型及其子类的对象可使用该转换器工厂类        
    	（例如将 String 转换为 Number 及 Number 子类 （Integer、Long、Double 等）对象）	
    GenericConverter：    	
    	会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换            
    
开发步骤	
    1. 定义转换器类实现Converter接口    
    2. 在配置文件 xml 中声明转换器    
    3. 在<annotation-driven>中引用转换器语法例子	
    
    public class DateConverter implements Converter<String, Date> {        
        public Date convert(String dateStr) {            
            //将日期字符串转换成日期对象 返回            
            SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");           
            Date date = null;           
            try {                
                date = format.parse(dateStr);            
            } catch (ParseException e) {                
                e.printStackTrace();            
            }            
            return date;        
        }    
    }   	

// bean.xml 配置    

<bean id="converterService"       
   class="org.springframework.context.support.ConversionServiceFactoryBean">		
    
    // 自定义类型转换器           
       <property name="converters">               
           <set>                 
                <bean class="com.itheima.converter.DateConverter"/>               
            </set>          
           </property>    
</bean>	
                    
// 告诉 springMVC 使用自定义转换器                         
<mvc:annotation-driven conversion-service="converterService"/>
```

### 数据校验

#### JSR303 校验

```java
// 参看注解 jsr 303 校验
```



#### spring校验

```java
介绍	
    Spring 4.0 拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架源码    
    Spring 的 LocalValidatorFactroyBean 
    	既实现了 Spring 的 Validator 接口，
    	也实现了 JSR 303 的 Validator 接口。
    只要	在 Spring 容器中定义了一个 LocalValidatorFactoryBean，
    	即可将其注入到需要数据校验的 Bean 中
    注意    
    	Spring 本身并没有提供 JSR303 的实现，
    	所以必须将 JSR303 的实现者的 jar 包放到类路径下
```

#### springMVC校验

```java
介绍    
    <mvc:annotation-driven/> 会默认装配好一个 LocalValidatorFactoryBean    
     在处理方法的入参上标注 @valid 注解即可让 Spring MVC 在完成数据绑定后执行数据校验的工作            
     使用	标注了 JSR303 注解的表单/命令对象前标注	
     Spring MVC 框架在将请求参数绑定到该入参对象后，就会调用校验框架根据注解声明的校验规则实施校验处理结果    
        
        
概述        
        Spring MVC 将校验结果
        	保存到对应的 BindingResult 或 Errors 对象中外，        	
        	还会将所有校验 结果保存到 “隐含模型”	
  方式一： 显式保存                
        // bean 对象和	保存结果的对象那个，必须相邻且中间不能有其他参数               
        校验结果保存到随后的入参中，保存结果的参数类型必须是 BindingResult 或Errors 类型，                
        同时 两者都位于 org.springframework.validation 包  
        
方式二： 隐式保存（页面展示）        
        // 入参中没有 BindingResult Errors        
        会将所有校验 结果保存到 “隐含模型”，         
        最终将通过 HttpServletRequest 的属性列表暴露给 JSP 视图对象        
        在 JSP 页面上可通过 <form:errors path=“字段名”> 显示错误消息        
            
       语法例子      
            // 告知 springMVC 该 javaBean 需要校验      
            // 并返回校验的结果，返回的是该参数之前的 javaBean 的校验结果，中间什么都不能要     
            public String addEmp(@Valid Employee employee, BindingResult result){ ... }
相关 api	
    BindingResult/ Errors	    	
    // BindingResult 扩展了 Errors 接口        
    FieldError getFieldError(String field)         
    List<FieldError> getFieldErrors()         
    Object getFieldValue(String field)         
    Int getErrorCount()
```



### 错误消息处理

#### 原生表单

```java
将错误放在请求域中即可
```

#### 数据校验国际化

##### properties文件

```java
介绍	每个属性在数据绑定和数据校验发生错误时，都会生成一个对应的 FieldError 对象国际化文件	格式    key=value	每一个字段发生错误以后，都会有自己的错误代码，国际化文件中错误消息的 key 必须对应一个错误代码错误代码    一个属性校验失败后，校验框架会为该属性生成 4 个消息代码，    注解类名为前缀，结合modleAttribute、属性名及属性类型名生成多个对应的消息代码错误代码格式 -- key     // 优先顺序：越精确越优先    User 类中的 password 属性标准了一个 @Pattern 注解，出错则        Pattern.user.password	校验规则.隐含模型中这个对象的 key.对象的属性        Pattern.password		校验规则.属性名，任何 email 属性出错都会出错        Pattern.java.lang.String 校验规则.属性类型， 只要是 String 类型发生email校验类型错误        Pattern		只要是 @Pattern  校验错误    动态出入消息参数    语法例子            @Length(min=5, max=15)        // errors_en_US.properties        // {1} 被替换成 5 {2} 被替换成 15        Pattern.password = email incorrect! {1} {2}	语法        {0} 当前属性的属性名        {1} {2}... 按照属性名的大小写进行排序	其他        每一个注解上都有一个 message 属性， 这个属性就是错先错误的时候，会显示的信息语法例子    // errors_en_US.properties    Pattern.password = email incorrect!	// errors_zh_CN.properties    Pattern.password = email incorrect! 的 utf8 编码备注    java 文件就是正常的代码   
```

##### springMVC 管理

```xml
就是 国际化中的 springMVC 管理管理国际化资源文件<!-- id 必须是 messageSource --><bean     id= "messageSource"     class="org.springframework.context.support.ResourceBundLeMessageSource">    <!-- basename指定基础名		name = 		value = 要引入的文件的名字的前缀： 			errors_en_US.properties  errors_zh_CN.properties	-->	<property name="basename" value="errors"></ property>       </bean>    .jsp 文件<form:form action= "hello/handle19.action" modelAttribute= "user"><form:errors path= *> </form:errors>	name: <input type= "text" name= "userName" />	<form:errors path= "userName"> </form:errors>    	email: <input type= "text" name = "email"/>	<form:errors path= "email"> < /form:errors>        	<input type= "submit "value= "Submit"/></form:form>
```



## 提交数据乱码

### 相应乱码

```java
response. setContentType("text/ html ; charset=utf-8")
```



### 请求乱码

```java
get请求	
    // web 服务器 tomcat 的 config/server.xml 中找到相应标签，添加   
    <Connectorl URIEncoding="UTF-8">
 post请求     
    // 在第一次获取之前获取设置    
    request.setCharacterEncoding("UTF-8")	
    // 自己写一个 filter, 其实 springMVC 中有这个 filter     
    <!-- 配置一个字符编码的Filter -->    
    <filter>        
    	<filter-name>CharacterEncodingFilter</ filter-name>        
    	<filter-class>org. springframework.web.filter.CharacterEncodingFilter</filter-class>            	 <init-param>                
            <param-name>encoding</param-name>                
            <param-value>utf-8</param-value>             
         </init-param>               
         <init-param>               
              <!-- forceEncoding :顺手解诀响应乱码; response.setCharacterEncoding                
              <param-name>forceEncoding</param-name>               
               <param-value>true</param-va1ue>            
          </init-param>    
 	</filter>    
    <filter-mapping>        
         <filter- name>CharacterEncodingF ilter</filter-name>       
         <ur1 -pattern>/ *</ur1-pattern>    
     </fi1ter-mapping>
```



