

## http -- 请求

### controller

```java
该注解表明该类扮演控制器的角色，
    Spring 不需要你继承任何其他控制器基类或引用 Servlet API。
```



### requestMapping

```java
@RequestMapping 
注解用于将特定 HTTP 请求方法映射到将处理相应请求的
控制器中的特定类/方法。此注释可应用于两个级别：
    类级别：映射请求的 URL 
    方法级别：映射 URL 以及 HTTP 请求方法
```



## http -- url 参数解析

### 介绍

```java
springMVC 可以接受的 url 参数
结构
    name=value&name=value……
    
类型
    基本类型参数
    POJO类型参数
    数组类型参数
    集合类型参数  -- url data
    


url 参数分类
    请求路径 url 
    	// localhost:8080/klasses/{klassId}/teachers?type=web
	    /klasses/{klassId}/teachers?name=zhangsan&age=12

    请求路径参数
    	locahost:8080 到 ？ 之前的内容的参数
        {klassId}
    
    请求参数
    	url 中 ？ 后面的键值对，键名为参数， 键值为参数的值
        name=zhangsan&age=12
    
注意 
 // 一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam和@PathVariable     

```

### 请求参数

#### 参数获取 -- 自动映射

```java
从 url 中获取自动映射到 java 类中
    url 中的参数 --： 普通 、 pojo 、数组
    
```



#### 自动映射 -- 基本类型

```java
控制器(controller)的业务方法 、 请求 url 中参数的名称
    
	相同：参数值会自动映射匹配
    	可以进行自动做类型转换，自动的类型转换是指从String向其他类型的转换
    
        // 发送的请求： http://xxx/quick9?username=zhangsan&age=12
        @RequestMapping(value="/quick11?")
        public void save11(String username,int age) throws IOException {
            System.out.println(username); // 自动映射请求中的请求参数
            System.out.println(age);
        }
	不同：通过@RequestParam注解显示的绑定
        
        // 发送的请求： http://xxx/quick9?name=zhangsan&age=12
        @RequestMapping(value="/quick11?")
        public void save11(
        	@RequestParam(value="name") String username,
        	int age
    	) throws IOException {
            System.out.println(username); // 自动映射请求中的请求参数
            System.out.println(age);
        }
        
```

#### 自动映射 -- pojo

```java
介绍
    // 一致，参数值会自动映射匹配
    Controller中的业务方法的POJO参数的属性名
    请求参数的键名 
    
原理
    SpringMVC会 自动的为这个POJO进行赋值?	
            1)、将POJO中的每一个属性，从request参数中尝试获取出来，并封装即可;	
            2)、还可以级联封装	
    
例子

    // POJO   
    @Data  // 自动生成 get set 等方法
    public class User {        
        private String username;
        private int age;
  
    }	
	
	// 请求
	http://localhost:8080/itheima_springmvc1/quick12?username=zhangsan	

    // 处理代码	   
    @ResponseBody  
    @RequestMapping(value="/quick12")            
    public void save12(User user) throws IOException {
        // springMVC 自动将参数封装到 User 中，直接打印 user 可以得到请求参数
        System.out.println(user.username);      // zhangsan
    }	

```

#### 自动映射 -- 数组

```java
介绍    
    // 一致，参数值会自动映射匹配
	Controller中的业务方法 数组名称
    请求参数的键名       
    
例子
// 请求
    http://localhost:8080/itheima_springmvc1/quick13?strs=aaa&strs=bbb	
// 处理代码    
    @ResponseBody 
    @RequestMapping(value="/quick13")      
	public void save13(String[] strs) throws IOException {        
        // 请求中的参数自动封装
        System.out.println(Arrays.asList(strs));     // [aaa,bbb]
    }        
    
```



#### 自动映射 -- url data

##### 表单数据

```java
介绍   
    获得集合参数时，要将集合参数包装到一个POJO中才可以。  
    // 感觉不全， 待整理
    
    // 表单    
    <form action="${pageContext.request.contextPath}/user/quick14" method="post">        
        <%--表明是第一个User对象的username age--%>        
        <input type="text" name="userList[0].username"><br/>        
        <input type="text" name="userList[0].age"><br/>       
        <input type="text" name="userList[1].username"><br/>        
        <input type="text" name="userList[1].age"><br/>        
        <input type="submit" value="提交">   
    </form>    
 // 原型    
    public class VO {	   
        // 集合类型        
        private List<User> userList;   
    }

// 操作
	@RequestMapping(value="/quick14")    
	@ResponseBody    
	public void save14(VO vo) throws IOException {
        System.out.println(vo);    
    }
```

#####  json -requestbody

```java
介绍    
    当使用ajax提交时，可以指定contentType为json形式，    
    
    那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装   
    // 代码    
    <script src="${pageContext.request.contextPath}/js/jquery-3.3.1.js"></script>    
    <script>       
        var userList = new Array();        
        userList.push({username:"zhangsan",age:18});        
        userList.push({username:"lisi",age:28});        
    $.ajax({            
        type:"POST",            
        url:"${pageContext.request.contextPath}/user/quick15",            
        data:JSON.stringify(userList),           
        contentType:"application/json;charset=utf-8"        
    });    
    </script>
 // 配置   
        <mvc:resoutces mapping:>        
// 处理代码	
    @RequestMapping(value="/quick15")   
    @ResponseBody    
        public void save15(@RequestBody List<User> userList) throws IOException { 
            System.out.println(userList);    
	 }      // 请求
```



### 路径参数

```java
介绍
    路径参数，无论名称是否一致， 都需要携带一个 @PathVariable 注解
	@DeleteMapping("remove/{id}")
    public R removeById(
        	@PathVariable String id
	){
		....
    }
```



### 注解开发

```java
// 参看注解
其他的注解， 参看
```



##  http -- 响应

### 视图

```java
参看
    视图解析、转发、重定向
```



### 数据

#### 介绍

```java
介绍
	响应的数据，主要存放在 response 域中
    // 主要是使用 responseBody 注解
    
方式一
    // 通过SpringMVC框架注入的response对象，
    // 使用 ResponseBody 注解
    @RequestMapping(value="/quick7")
    @ResponseBody  //告知SpringMVC框架 不进行视图跳转 直接进行数据响应
    public String save7() throws IOException {
        return "hello itheima";
    }
    
方式二
     // 使用response.getWriter().print(“hello world”) 回写数据，
    // 此时不需要视图跳转，业务方法返回值为void
    @RequestMapping(value="/quick6")
    public void save6(HttpServletResponse response) throws IOException {
        response.getWriter().print("hello itcast");
    }
方式三
    // 通过上下文进行传递
    请求控制器中方法的参数，在填充数据，响应后， 可以在 响应域中获取
```



#### 返回获取

```java
介绍
    将需要回写的字符串直接返回，
    使用 res
    
分类
    普通字符串 ： 直接返回字符串
    json 字符串 ： 将对象转换为 json 字符串后再返回
    其他对象	： 响应的数据会被转为 json 字符串
案例

// 直接返回字符串
    参看前面的介绍

// 返回 json 字符串
     @ResponseBody
	 @RequestMapping(value="/quick8")
     public String save8() throws IOException {
        User user = new User();
        //使用json的转换工具将对象转换成json格式字符串在返回
        // json转换工具jackson进行转换
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(user);
        return json;
     }

// 其他结构复杂结构

	@RequestMapping(value="/quick10")
    @ResponseBody
    //期望SpringMVC自动将User转换成json格式的字符串
	// springMVC 自动进行转换                    
    public User save10() throws IOException {
        User user = new User();
        user.setUsername("lisi2");
        user.setAge(32);
        return user;
    }
```

#### 上下文获取

```java
介绍
    // 处理器的方法中的参数，会保存在 响应域中
    请求方法中的对象等， 可以直接在请求域中获取
    
参数中传入返回
    可以在方法处传入Map、Model、ModelMap.
	给这些参数里面保存的所有数据都会放在域(请求域： requestScope )中。
    可以在页面获取
map model modelMap
    // 类型
    map的类型: class org. springframework. validation. support . BindingAwareModelMap
    mode1的类型: class org. springframework. validation. support . BindingAwareModelMap
    modelmap的类型: class org. springframework . validation. support .BindingAwareModelMap

     
语法例子
    @ResponseBody  //告知SpringMVC框架 不进行视图跳转 直接进行数据响应
    public String save7(map<String int> msg) throws IOException {
     	// map 会保存在域中，在页面获取
        return "success";
    }     
```

![image-20210327211414141](image-20210327211414141.png)



### 实现

#### xml

```java
	// xml 配置
    <!--SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数-->
    <!--指定使用jackson进行对象或集合的转换-->
    <!--处置处理器映射器-->
    <bean 
        // org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter
        class="固定.RequestMappingHandlerAdapter">
            <property name="messageConverters">
                <list>
            // org.springframework.http.converter.json.MappingJackson2HttpMessageConverter
                    <bean class="固定.MappingJackson2HttpMessageConverter"/>
                </list>
            </property>
    </bean>
    
```



#### 注解

```java

<mvc:annotation-driven/>
    作用
    <!-- 自动加载, 替代注解处理器和适配器的配置 -->
    
    RequestMappingHandlerMapping（处理映射器）
    RequestMappingHandlerAdapter（ 处 理 适 配 器 ）
    
    返回值
    集成jackson进行对象或集合的json格式字符串的转换
    
 
```

 



## 原生 api

```java
介绍    
    springMVC 中可以使用原生 api	
    HttpServletRequest    
    HttpServletResponse    
    HttpSession    
    java. security. Principal    
    Locale    
    InputStream    
    OutputStream   
    Reader   
    Writer    
```



## 其他操作

#### 静态资源开启

```xml
介绍	
	有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，
原因	
	SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,
	代表对所有的资源都进行过滤操作，
解决方法	
	方式一	
        <!--springMVC.xml 中设置-->	 
        <mvc:resources mapping="/js/**"location="/js/"/> 		
    方式二	
        <mvc:default-servlet-handler/>
```

#### 请求数据乱码

```xml
介绍
	配置全局乱码过滤器(应用)
	当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。

语法例子
<!--配置全局过滤的filter-->
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>	
```

