

## http --  请求

```java
@request_mapping
    
@PostMapping("/xxx")     
@PutMapping("/users/{userId}")
@DeleteMapping("/users/{userId}")
@PatchMapping("/profile")   //  PUT 不够用了之后才用 PATCH 请求去更新数据。  

@GetMapping("users") 
	 等价于： @RequestMapping(value="/users",method=RequestMethod.GET)
```



### RequestMapping

```java
@RequestMapping(value="/users",method=RequestMethod.GET)
作用：
    // 告诉 springMVC 来处理什么请求,路径
    用于建立请求 URL 和处理请求方法之间的对应关系
    将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。
    
特点
    一个请求对应一个方法
属性值（
    value(): String[]
            （"/hello"） 这个/是可以省略，即使省略了，也是默认从当前项目下开始;
            指定处理的客户端的请求的URL。
            它和path属性的作用是一样的
    method(): RequestMethod[]
            // 默认 method=RequestMethod.GET, 注意在 RequestMethod 类中
            用于指定请求的方式，枚举方式的，不是指定类型就会报错

    params(): String[]
			规定请求参数， 它支持简单的表达式。
            要求请求参数的key和value必须和配置的一模一样
            例如：
                params = {"accountName"}，请求参数必须有accountName
                params = {"!accountName"}，请求参数不能有accountName
            	{"userName=123"} 请求参数必须有accountName, 且值为 123
                {"userName!=123"} 请求参数必须有accountName, 且值不能为 123
            	{"userName","password"}  请求参数含有多个
    headers(): String()
		规定请求头， 写法形式和 params 相同
                

    consumes(): String()
		只接受内容类型是哪种的请求，规定请求头中的Content- Type

    produces(): String()  
		告诉浏览器返回的内容类型是什么，给响应头中加上Conteht-Type:text/html;charset=utf-8

                	
)
标注位置(
	类上	:
		请求URL 的第一级访问目录,相当于 web 的根路径
	方法上 :
		// 与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径                
		请求 URL 的第二级访问目录，
		若类上没有标注： 方法处标注 URL 先对应于 web 的根目录                
                        
)
返回值（
	返回值: 通过解析器解析为实际的物理视图。
   对于 InternalResourceViewResolver 视图解析器会做下面的解析
   通过 prefix + returnVal + 后缀的方式得到实际物理视图，然后做转发
）                
 
        
语法例子
@Controller
@RequestMapping('/book')
public class UserController {
    // http://localhost:8080/book/quick
    //  @RequestMapping(value="/quick", method=RequestMethod.GET, params = {"accountName"})
    @RequestMapping("/quick")
    public String save() {
        return "success.jsp";
			相对当前资源所在地址，即 http://localhost:8080/book
        	 默认形式是： forward: success.jsp
		return "/success.jsp";
        	从 web 引用下找这个资源
             默认形式是： forward: /success.jsp
}        

```

### URL 模糊匹配

```java
Ant风格资源地址支持3种匹配符:   
	? 	替代一个字符    
    * 	替代多个字符， 和一层路径    
    **	替代多层路径
```

### 请求方法

```java
@PostMapping("/xxx")     
@PutMapping("/users/{userId}")
@DeleteMapping("/users/{userId}")
@PatchMapping("/profile")   //  PUT 不够用了之后才用 PATCH 请求去更新数据。  

@GetMapping("users") 
	 等价于： @RequestMapping(value="/users",method=RequestMethod.GET)
  
```



## http -- url 参数解析

```java


@cookie_Value  
// 请求
    @Request_Body  
        用于读取 Request 请求的 body 部分并且Content-Type 为 application/json 格式的数据
    @Request_Param 用于获取查询参数
    @Path_Variable 用于获取路径参数  
// 响应
    responseBody 
    @response_Header            
```



### requestBody

```java

@RequestBody 
	// 应用于形参上
    用于读取 Request 请求的 body 部分并且Content-Type 为 application/json 格式的数据
	收到数据之后会自动将数据绑定到 Java 对象上去
	系统会
        使用 HttpMessageConverter或者自定义的HttpMessageConverter
        将请求的 body 中的 json 字符串转换为 java 对象。        
    
	// 使用
	@User   请求到这个接口，并且 body 携带 JSON 数据映射到我们的 User 类上        
	// User{ String name}      
	// body 中 json 中的对应 name 字段的数据会自动映射到 java 中的 User 类的 name 字段中
```

### responseBody

```java
作用
   // 是将java对象转为json格式的数据。
    将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，
    写入到response对象的body区，通常用来返回JSON数据或者是XML数据。
特点
	在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，
    他的效果等同于通过response对象输出指定格式的数据。
标注位置
    方法上
    	该方法的返回结果直接写入 HTTP response body 中，
    	一般在异步获取数据时使用【也就是AJAX】，会直接返回 json 数据

	类上：
    	说明该类的所有方法都是默认 标注 respo

例子
    @RequestMapping("/login")
　　@ResponseBody
　　public User login(User user){
　　　　return user;
　　}
　　User字段：userName pwd
　　那么在前台接收到的数据为：'{"userName":"xxx","pwd":"xxx"}'

　　效果等同于如下代码：
　　@RequestMapping("/login")
　　public void login(User user, HttpServletResponse response){
　　　　response.getWriter.write(JSONObject.fromObject(user).toString());
　　}
```



### RequestParam

```java

介绍
    // 请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定
    如果我们请求的 url 是：/klasses/{klassId}/teachers?type=web
    请求路径参数   {klassId}
    请求参数      问号之后的  type , ，但是不能获取响应参数（后半句有一位），
	// 一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam和@PathVariable        
        
    
参数
    value：请求参数名称
	required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错
	defaultValue：当没有指定请求参数时，则使用指定的默认值赋值

语法例子

<form action="${pageContext.request.contextPath}/quick16" method="post">
    <input type="text" name="name"><br>
    <input type="submit" value="提交"><br>
</form>
// 处理代码      
	@RequestMapping(value="/quick16")
    @ResponseBody
    public void save16(
    	// 从 url 中获取参数名为 name 的参数，并赋值给 username
    	// username = request.getParameter("name")
    	@RequestParam(value="name",required = false,defaultValue = "itcast") String username
		) throws IOException {
        System.out.println(username);
    }        
```

### PathVariable

```java
介绍
    参数注解
    // Restful风格的参数
    /book/[{user}pathVariable]?[{user=admin}requestParam]
    获取路径参数，但是不能获取请求参数，即不能获取 ？ 后面的参数

参数
    value：请求路径参数
	required：此在指定的路径参数是否必须包括，默认是true，提交时如果没有此参数则报错
	defaultValue：当没有指定路径参数时，则使用指定的默认值赋值
    
作用    
    通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中: 
语法例子
	// 语法实例
	@RequestMapping(" /delete/{id}")
        // 可以获取 URL 中的占位符
        public String delete (@PathVariable("id") Integer id){
        UserDao . delete(id);
        return "redirect: /user/list. action";
    }

```

### RequestHeader

```java
介绍	
    获得请求头信息，相当于web阶段学习的request.getHeader(name)属性    
 参数    
    value：请求头的名称	
    required：是否必须携带此请求头，提交时如果没有此参数则报错	
    defaultValue：当没有指定请求头，则使用指定的默认值赋值       
    语法例子   
    	@RequestMapping("/quick17")   
    	@ResponseBody    
    	public void quickMethod17(    	
    		@RequestHeader(value = "User-Agent",required = false) String headerValue	
		){    	
    		System.out.println(headerValue);	
		}
```



### CookieValue

```java
介绍
    获得指定Cookie的值
属性
    // 
    value：指定cookie的名称
	required：是否必须携带此cookie
语法例子
	@RequestMapping("/quick18")
    @ResponseBody
    public void quickMethod18(
    	@CookieValue(value = "JSESSIONID",required = false) String jsessionid
	){
    	System.out.println(jsessionid);
	}
    
    
```

## http --   响应

### session

```java
介绍
	@SessionAttributes
	只能标注在类上	
语法
@SessionAttributes
含义（
	给BindingAwareModelMap modelandview 中保存的数据，同时给session中放一份
）    
属性（
	value="msg"	只要保存的是这种key的数据，给Session中放- -份
	type={String.class}	只要保存的是这种类型的数据，给Session中也放一-份


） 
```



## http -- 参数校验JSR 注解

```java
参看 JSR303 注解
```

## json

```java
@JsonFormat: {     
    作用：{             一般用来格式化 json 数据      }     
    属性： {         
        (shape=JsonFormat.Shape.STRING,          
         pattern="yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",          
         timezone="GMT")     
    }         
}       

```





## // ==

## 类

## 字段



### @DateTimeFormat

```java
介绍
    FormattingConversionServiceFactroyBean 
    	内部已经注册了：JodaDateTimeFormatAnnotationFormatterFactroy
    支持对日期类型的属性使用
语法
{ @DateTimeFormat    
属性(
    pattern="yyyy-MM-dd",  // 日期格式
    iso =
    style
)
使用(
	java.util.Date、java.util.Calendar、java.long.Long 时间类型进行标注：
)}
配置
    // xml, 默认创建 ConversionService 实例
    <mvc:annotation-driven/>
例子
	// 规定提交的数据的格式        
    @DateTimeFormat(pattern="yyyy-MM-dd")
	private Date birth;        
```

### @NumberFormat

```java
介绍
    FormattingConversionServiceFactroyBean 内部已经注册了：NumberFormatAnnotationFormatterFactroy
    支持对数字类型的属性， 可对类似数字类型的属性进行标注
    
语法
<@NumberFormat
属性（
	style="Style.NUMBER" {
    	用于指定样式类型, 类型为 NumberFormat.Style
             Style.NUMBER（正常数字类型）、
			Style.CURRENCY（货币类型）、 
             Style.PERCENT（百分数类型）
	}
	patter="#,###" {
        自定义样式, 类型为 String
    }    	
）>    
配置
    // xml, 默认创建 ConversionService 实例
    <mvc:annotation-driven/>    
例子
    
```



## 方法

## 参数

```java
前端 -- url 参数解析
```





## JSR303

### 介绍

```java
以下每个注解都有一个 message 属性，属性值就是该注解校验出现错误的时候，显示在界面上的信息
    
介绍    
    JSR(Java Specification Requests）     
        是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，    
        我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！
场景使用	
        即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，    
        避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。        
注意	
        // 所有的注解，推荐使用 JSR 注解，即javax.validation.constraints        	
        实际用的是 Hibernate Validator 框架   
        spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。	
        Hibernate Validator 4.x 是 Bean Validation 1.0（JSR 303）的参考实现，     
        Hibernate Validator 5.x 是 Bean Validation 1.1（JSR 349）的参考实现，    
        Hibernate Validator 6.x 是 Bean Validation 2.0（JSR 380）的参考实现。            
```



### 基础注解

```java
@Null
	被注释的元素必须为null
@NotNull 
	被注释的元素必须不为null
@AssertTrue
	被注释的元素必须为true
@AssertFalse
	被注释的元素必须为false 
@Min(value)
	被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@Max(value)
	被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@DecimalMin(value)
	被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@DecimalMax(value)
	被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@Size(max, min)
	被注释的元素的大小必须在指定的范围内
@Digits(integer, fraction)
	被注释的元素必须是一个数字，其值必须在可接受的范围内
@Past
	被注释的元素必须是一个过去的日期
@Future
	被注释的元素必须是一个将来的日期
@Pattern (value)
	被注释的元素必须符合指定的正则表达式

```



### Hibernate Validator 扩展注解

```java
@Email
	被注释的元素必须是电子邮箱地址
@Length（
属性{
	min 
	max        
}）
	被注释的字符串的大小必须在指定的范围内
@NotEmpty
	被注释的字符串的必须非空
@Range
	被注释的元素必须在合适的范围内
        
@Valid 
      // 一定一定不要忘记在类上加上 Validated 注解了，这个参数可以告诉 Spring 去校验方法参数
      告知 springMVC 该 javaBean 需要校验
      并返回校验的结果，
        返回的是该参数之前的 javaBean 的校验结果，中间什么都别跟
        如果验证失败，它将抛出MethodArgumentNotValidException
      public String addEmp(
        @Valid Employee employee, 
        BindingResult result
    	){ ... }
```

## //  ===



#### @RequestParam

```java
介绍    // 获取 url 中获取请求参数    /book/[{user}pathVariable]?[{user=admin}requestParam]    获取请求参数，即获取 ？ 后面的参数，但是不能获取请求参数，	请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定    参数    value：请求参数名称	required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错	defaultValue：当没有指定请求参数时，则使用指定的默认值赋值语法例子<form action="${pageContext.request.contextPath}/quick16" method="post">    <input type="text" name="name"><br>    <input type="submit" value="提交"><br></form>// 处理代码      	@RequestMapping(value="/quick16")    @ResponseBody    public void save16(    	// 从 url 中获取参数名为 name 的参数，并赋值给 username    	// username = request.getParameter("name")    	@RequestParam(value="name",required = false,defaultValue = "itcast") String username		) throws IOException {        System.out.println(username);    }        
```

#### @PathVariable

```java
介绍    参数注解    // Restful风格的参数    /book/[{user}pathVariable]?[{user=admin}requestParam]    获取路径参数，但是不能获取请求参数，即不能获取 ？ 后面的参数参数    value：请求路径参数	required：此在指定的路径参数是否必须包括，默认是true，提交时如果没有此参数则报错	defaultValue：当没有指定路径参数时，则使用指定的默认值赋值    作用        通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中: 语法例子	// 语法实例	@RequestMapping(" /delete/{id}")        // 可以获取 URL 中的占位符        public String delete (@PathVariable("id") Integer id){        UserDao . delete(id);        return "redirect: /user/list. action";    }
```

#### @RequestHeader

```java
介绍	获得请求头信息，相当于web阶段学习的request.getHeader(name)属性    参数    value：请求头的名称	required：是否必须携带此请求头，提交时如果没有此参数则报错	defaultValue：当没有指定请求头，则使用指定的默认值赋值        语法例子    @RequestMapping("/quick17")    @ResponseBody    public void quickMethod17(    	@RequestHeader(value = "User-Agent",required = false) String headerValue	){    	System.out.println(headerValue);	}
```



#### @CookieValue

```java
介绍    获得指定Cookie的值属性    //     value：指定cookie的名称	required：是否必须携带此cookie语法例子	@RequestMapping("/quick18")    @ResponseBody    public void quickMethod18(    	@CookieValue(value = "JSESSIONID",required = false) String jsessionid	){    	System.out.println(jsessionid);	}    
```



## // ==