##  EqualsAndHashCode和equals()

### 介绍

```java
当这个注解设置 callSuper=true时，会调用父类的 equlas() 方法
public boolean equals(Object o) {    
    if (o == this) {       
        return true;    
    } else if (!(o instanceof BaseVO)) {        
        return false;    
    } else {        
        BaseVO other = (BaseVO)o;       
        if (!other.canEqual(this)) { 
            return false;       
        } else if (!super.equals(o)) {
            return false;        
        } else {             
            // 各项属性比较       
        }   
    }}  
如果一个类的父类是 Object（java 中默认没有继承关系的类父类都是 Object），那么这里会调用 Object 的equals() 方法，如下
    
public boolean equals(Object obj) {   
    return (this == obj);
}
```

### 问题

```java
对于父类是 Object 且使用了 @EqualsAndHashCode(callSuper=true) 注解的类，
这个类由 lombok 生成的equals() 方法
    只有在两个对象是同一个对象时，才会返回 true，否则总为 false，
    无论它们的属性是否相同(属性不同也可以)
    // 大部分时间是不符合预期的，equals() 失去了其意义
    
    
```



### 解决

```java
1. 不使用该注解
   大部分 pojo 我们是不会调用 equals 进行比较的，实际用到时再重写即可
2. 去掉 callSuper=true。
   如果父类是 Object，推荐使用    
3. 重写父类的 equals() 方法，
    确保父类不会调用或使用类似实现的 Ojbect 的 equals()。    
```

## data

### 介绍

```java
@data 实际上就是
    用的 @EqualsAndHashCode，
    没有调用父类的 equals()，
    当我们需要比较父类属性时，是无法比较的
    // 而是因为 lombok 自动生成的equals()只比较子类特有的属性。
    
注解原则
    Lombok对于第一个字母小写，第二个字母大写的属性生成的get-set方法
    和Mybatis以及idea或者说是Java官方认可的get-set方法生成的不一样:
    
@Data
public class ABO {    
    private int a;
}

@Data
public class BBO extends ABO {
    private int b;
    public static void main(String[] args) {
        BBO bbo1 = new BBO();        
        BBO bbo2 = new BBO();
        
        bbo1.setA(1);        bbo2.setA(2);
        bbo1.setB(1);        bbo2.setB(1);
        // lombok 自动生成的equals()只比较子类特有的属性。
        System.out.print(bbo1.equals(bbo2)); // true    
	}
}
```

### 解决

```java
1. 用了 @data
    就不要有继承关系
2. 自己重写 equals()
    lombok 不会对显式重写的方法进行生成
3. 显式使用 @EqualsAndHashCode(callSuper=true)
    lombok 会以显式指定的为准。
```

## builder

### 介绍

```java
使用@Builder.Default初始化变量@Builder要注意与其他注解的使用，特别是构造函数和@EqualsAndHashCode使用@Builder(toBuilder = true) 只能实现浅拷贝@NonNull，如果检测结果为null则抛出NullPointerException. 反而显式的null-check是更好的选择。
```

