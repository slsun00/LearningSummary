

## 日志记录时机

```java
编程语言提示异常
    编程语言、业务框架抛出的异常， 这类异常需要关注，进行适当记录，
    根据业务使用 warn error 级别
    
    
业务流程预期不符    
    目代码中结果与期望不符时也是日志场景之一
    所有流程分支都可以加入考虑。取决于开发人员判断能否容忍情形发生
    场景
    	外部参数不正确，数据处理问题导致返回码不在合理范围内等
    
系统核心角色、组件关键动作
    费心角色触发业务是需要关注的，是系统正常运行的重要指标： info
    场景
    	电商系统用户从登录到下单的整个流程；
    	微服务各服务节点交互；
    	核心数据表增删改；
    	核心组件运行等
    如果日志频度高或者打印量特别大，可以提炼关键点INFO记录，其余酌情考虑DEBUG级别。
    
    
系统初始化
    系统或者服务的启动参数， 三方会根据参数不同会提供不一样的服务 ： info
    打印出参数以及启动完成态服务表述。
```



## 日志代码格式

### 日志对象

```java
概述
    1. 日志变量往往不变，变量名用大写
    	一个对象中通常只使用一个Logger对象，Logger应该是static final的
    	只有在少数需要在构造函数中传递logger的情况下才使用private final。
    2. 不要使用具体的日志实现类
    	日志变量类型定义为门面接口， 面向接口编程，不要面向实现
            不推荐：InterfaceImpl interface = new InterfaceImpl();
            推荐  : Interface interface = new InterfaceImpl();
    	优势：方便切换不同的日志实现框架： Log4j、Logback 等日志实现框架
    
未整理
1. 引入lombok的依赖，在类的头部加上@Slf4j的注解，之后便可以在程序的任意位置使用log变量打印日志信息了，使用起来更加简洁一点，在重构代码尤其是修改类名的时候无需改动原有代码。
```

### 参数占位符

```java
代码
    log.debug("Save order with order no：[{}], and order amount：[{}]");
    使用参数化形式{}占位，[]进行参数隔离， 
    可读性好
    	[]里面是输出的动态参数，
		{}用来占位类似绑定变量，
    	而且只有真正准备打印的时候才会处理参数，方便定位问题。

不支持参数化形式
	日志框架不支持参数化形式，且日志输出时不支持该日志级别时会导致对象冗余创建，浪费内存
    此时就需要使用 isXXEnabled 判断，如：
        if(log.isDebugEnabled()){
            // 如果日志不支持参数化形式，debug又没开启，
            // 那字符串拼接就是无用的代码拼接，影响系统性能
            log.debug("Save order with order no：" + orderNo + ", and order amount：" + orderAmount);
        }
	至少 debug 级别是需要开启判断的，线上日志级别至少应该是 info 以上的
```

## 日志记录

### 概述

```java
    日志时间
    日志级别主要使用
    调用链标识（可选）
    线程名称
    日志记录器名称
    日志内容
    异常堆栈（不一定有）
```

### 日志时间

```java
这个数据非常重要，一般精确到毫秒。
由于线上一般配置为按天滚动日志文件，日期标识在文件名上，所以可以不放在这个时间中，
使用 HH:mm:ss.SSS 格式即可。非要加上也未尝不可，格式推荐：yyyy-MM-dd HH:mm:ss.SSS。

```

### 日志级别

```java
思考
    // 什么内容应该记在日志，什么内容不应该记录日志或者不应该将此日志内容提交到代码仓库
    是否只有我关注
    是否只有我在本次调试的时候才关注
    是否只要调试此模块的开发者都应该关注
```



### 调用标识链

```java
介绍
    分布式应用中，用户的一个请求会调用若干个服务完成，这些服务可能还是嵌套调用的，
    因此完成一个请求的日志并不在一个应用的日志文件，而是分散在不同服务器上不同应用节点的日志文件中
    
标识
    为了串联一个请求在整个系统中的调用日志
链式标识格式
    // 调用链标识作为可选项，无该数据时只输出 [] 即可。
    唯一字符串（trace ID）
    调用层级（span ID）

```

### 线程名称

```java
输出该日志的线程名称，一般在一个应用中一个同步请求由同一线程完成，
输出线程名称可以在各个请求产生的日志中进行分类，便于分清当前请求上下文的日志
```

### 日志记录器名称

```java
日志记录器名称一般使用类名，日志文件中可以输出简单的类名即可
看实际情况是否需要使用包名和行号等信息
    
主要用于看到日志后到哪个类中去找这个日志输出，便于定位问题所在。    
```

### 日志内容

```java
// 使用
禁用 
    System.out.println和System.err.println
日志字符串拼接
    不用
    	变参替换
    必须使用
    	// 或者需要耗费时间、浪费内存才能产生的日志内容
    	应使用 log.isXxxxxEnable() 进行判断后再进行拼接处理
            if (log.isDebugEnable()) {
                StringBuilder builder = new StringBuilder();
                for (Student student : students) {
                    builder.append("student: ").append(student);
                }
                builder.append("value: ").append(JSON.toJSONString(object));
                log.debug( "debug log example, detail: {}" , builder );
            }


预防空指针
    不要在日志中调用对象的方法获取值，除非确保该对象肯定不为 null，
    否则很有可能会因为日志的问题而导致应用产生空指针异常。
    // ----
        // 不推荐
        log.debug( "Load student(id={}), name: {}" , id , student.getName() );
        // 推荐
        log.debug( "Load student(id={}), student: {}" , id , student );
    // ----

输出日志的对象，
    应在其类中实现快速的 toString 方法，以便于在日志输出时仅输出这个对象类名和 hashCode
```

### 异常堆栈

```java
一般会出现在 ERROR 或者 WARN 级别的日志中，
异常堆栈含有方法调用链的系统，以及异常产生的根源。
异常堆栈的日志属于上一行日志的，在日志收集时需要将其划至上一行中。  //?
```

## 日志文件

```java
// 根据不同的环境配置不同的日志输出方式：

本地调试
    日志输出到控制台上
    
测试环境或者生产环境    
   输出到文件中  
    
生产环境
    可以考虑使用异步文件输出，该种方式日志并不会马上刷新到文件中去，会产生日志延时，在停止应用时可能会导致一些还在内存中的日志未能及时刷新到文件中去而产生丢失，如果对于应用的要求并不是非常高的话，可暂不考虑异步日志

文件分割滚动
    一个级别一个文件：error info 分别房子啊不同的文件中
    定时定量分割：
    	一天一个文件： 
    	当一个文件到达某个容量大小： 就分割
文件压缩 
    滚动后将前一文件进行压缩，以减少磁盘空间占用
```

## 使用规范

### 捕获错误

#### 输出Exceptions的全部Throwable信息

```java
void foo(){
    try{
       //do somehing 
    }catch(Exception e){
        // log.error(msg)和log.error(msg,e.getMessage())
        // 这样的日志输出方法会丢失掉最重要的StackTrace信息
        
        log.error(e.getMessage());//错误示范
        log.erroe("Bad Things",e.getMessage());//错误示范
        log.error("Bad Things",e);//正确演示
        
        e.printStacktrace();//错误, 不允许出现printStackTrace 
        log.error("Bad Things",e);//正确演示 
    }
}

```

### 输出

#### 不允许记录日志后又抛出异常

```java
介绍
    捕获异常后又抛出了自定义业务异常，此时无需记录错误日志，由最终捕获方进行异常处理。
    不能又抛出异常，又打印错误日志，不然会造成重复输出日志。

    void foo() throws LogException{
        try{
            //do somehing 
        }catch(Exception e){
            log.error("Bad Things",e);//正确
            throw new LogException("Bad Things",e);
        }
    }

```

#### 不允许使用标准输出

```JAVA
介绍
    禁止使用包括System.out.println()和System.error.println()语句
    
原因
    1. 只会打印到控制台，而不会记录到日志文件中，不方便管理日志
    2. 标准输出不会显示类名和行号信息， 大量标准输出的语句会难以排查问题

        void foo(){
            try{
               //do somehing 
            }catch(Exception e){
                Syste.out.println(e.getMessage());//错误
                System.error.println(e.getMessage());//错误
                log.error("Bad Things",e);//正确
            }
        }
```

#### 不要在大循环中打印日志

```java
如果你的框架使用了性能不高的 Log4j 框架，那就不要在上千个 for 循环中打印日志，
这样可能会拖垮你的应用程序，如果你的程序响应时间变慢，那要考虑是不是日志打印的过多了
    // 错误
        for(int i=0; i<2000; i++){
            log.info("XX");
        }
	// 正确
		最好的办法是在循环中记录要点，在循环外面总结打印出来
```

#### 打印有意义的日志

```java
通常情况下在程序日志里记录一些比较有意义的状态数据：
    程序启动，退出的时间点；
    程序运行消耗时间；
    耗时程序的执行进度；
    重要变量的状态变化。
```



### 调试

#### 禁止在线上环境开启debug级别日志输出

```java
出于日志性能的考虑，如果代码为核心代码，执行频率非常高，则输出日志建议增加判断，尤其是低级别的输出<debug、info、warn>。

一是因为项目本身 debug 日志太多，
二是各种框架中也大量使用 debug 的日志，线上开启 debug 不久就会打满磁盘，影响业务系统的正常运行。

```





