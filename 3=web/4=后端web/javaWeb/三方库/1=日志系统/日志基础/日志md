## 内容

```java
介绍
    记录日志是调试程序，监视程序运行的一种重要的方式    
目的：
    bug的及时发现和定位
    显示程序运行状态  
    安全审计：审计主要体现在安全上，可以发现非授权的操作
问题
    重要的是什么日志应该记录，应该怎么记录和记录什么内容
日志形式
    软件界面的特殊提示，例如弹出窗口
    通过调试工具控制台输出内容
    通过文件记录日志
    通过系统日志记录
    通过上报数据到服务器    
```



## 日志级别

### 概述

```java
介绍
    不同的日志实现库的等级不一样，但是基本都是差不多的
    
级别概述    
    // 以 Log4j 为例  
      all | 所有：所有日志级别，包括定制级别  
    trace | 跟踪：指明程序运行轨迹，比DEBUG级别的粒度更细。 
    debug | 调试：指明细致的事件信息，对调试应用最有用。     
     info | 信息：指明描述信息，从粗粒度上描述了应用运行过程。
     warn | 警告：指明可能潜在的危险状况。    
    error | 错误：指明错误事件，但应用可能还能继续运行。    
    fatal | 致命：指明非常严重的可能会导致应用终止执行错误事件，
    			一般指程序所依赖的环境出现错误，使的程序不恢复。     
      off | 关闭：最高级别，不打印日志。 

 日志优先级顺序
    ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
	// 如果日志设置为L,一个级别为P的输出日志只有当P >= L时日志才会输出
     即如果日志级别L设置INFO，只有P的输出级别为INFO、WARN，后面的日志才会正常输出。
```

![image-20210602211257635](image-20210602211257635.png)



### 使用

#### info & debug

```java
INFO：
    介绍
	    反馈系统的当前状态给最终用户看的
	    记录系统有关信息：旨在保留系统正常工作期间关键运行指标    
    设置
    	将初始化系统配置、
    	业务状态变化信息，
    	用户业务流程中的核心处理记录到INFO日志
    建议
    	测试环境将日志级别调成 INFO， 看是否能了解这个应用的运用情况
		Info输出的信息可以看作是软件产品的一部分，所以需要谨慎对待，不可随便输出
    	
    
debug
    包含调试时更详细的了解系统运行状态的东西，比如变量的值等
    
调整
    1. 如果一条日志会被频繁打印或者大部分时间对于纠错起不到作用，就当考虑下调为DEBUG级别。
    2. 如果代码为核心代码，执行频率非常高，务必推敲日志设计是否合理，是否需要下调为DEBUG级别日志
    3. 日志输出是多线程公用的，
    	如果有另外一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致。
    4. 注意日志的可读性，
    	不妨在写完代码review这条日志是否通顺，能否提供真正有意义的信息。
```



#### warn & error

```java
    
WARN：
    输出警告性质的内容，
    设置
    	// 这些内容是可以预知且是有规划的
    使用
    	一般来说，WARN级别不会短信报警
	    WARN代表可恢复的异常，此次失败不影响下次业务的执行
    例子
    	某个方法入参为空或者该参数的值不满足运行该方法的条件时
    
    
    
ERROR：
    要针对于一些不可预知的信息，
    设置
    	：错误、异常等，
    使用
    	ERROR级别则会短信报警甚至电话报警，必须有人马上处理
    	应该伴随着业务功能受损， 意味着系统中发生了非常严重的问题， 
    场景
    	数据库不可用
    	系统的关键业务流程走不下去
    	在 catch 块中抓获的网络通信异常，
	日志信息            
        发生了什么问题，哪些功能受到影响
        获取帮助信息：直接帮助信息或帮助信息的存储位置
        通过报警知道解决方案或者找何人解决

    注意
        异常影响不大，可以以 warn 级别日志输出
        在输出时，尽量多地输出方法入参数、方法执行过程中产生的对象等数据，
        在带有错误、异常对象的数据时，需要将该对象一并输出
            
            
            
未整理
    1. 都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内ERROR日志的数量来确定的。因此如果我们不分轻重缓急，一律ERROR对待，就会徒增报错的频率，久而久之，我们的救火队员对错误警报就不会那么在意，这个警报也就失去了原始的意义。
            
	2. 开发人员会苦恼某些场景下几次失败可容忍，频率高的时候需要提醒，记录ERROR的结果是线上时不时出现容忍范围内的报警，这时报警是无意义的。但反之不记录ERROR日志，真正出现问题则不会有实时报警，错过最佳处理时机。
            

```

























## 打日志位置

```java
1. 调用或封装外部程序或接口
　　　　程序中对外部系统与模块的依赖调用前后都应该记下日志，方便接口调试。出问题时也可以很快查出是哪里出的问题

　　　　LOG.debug("Calling external system:" + parameters);
　　　　Object result = null;
　　　　try {
　　　　　　result = callRemoteSystem(params);
　　　　　　LOG.debug("Called successfully. result is " + result);
　　　　} catch (Exception e) {
　　　　　　LOG.warn("Failed at calling xxx system . exception : " + e);
　　　　}

　　2.对重要对象或变量被修改，要以INFO记录修改前的信息和修改后的状态。
　　　　程序中重要的状态信息的变化应该记录下来，方便查问题时还原现场，推断程序运行过程

　　　　boolean isRunning;
　　　　isRunning = true;
　　　　LOG.info("System is running");
　　　　//...
　　　　isRunning = false;
　　　　LOG.info("System was interrupted by " + Thread.currentThread().getName());

　　3.系统入口与出口：
　　　　系统的入口和出口，重要方法或模块的执行。记录它的输入与输出，方便定位。

　　4.业务异常或者重要的业务处理：
　　　　任何业务异常都应该记下来，还有系统中一些重要的业务，比如结算等业务，也最好能记录下来。

　　5.非预期执行：
　　　　为程序在“有可能”执行到的地方打印日志。如果我想删除一个文件，结果返回成功。但事实上，那个文件在你想删除之前就不存在了。最终结果是一致的，但程序得让我们知道这种情况，要查清为什么文件在删除之前就已经不存在

　　　　int myValue = xxxx;
　　　　int absResult = Math.abs(myValue);
　　　　if (absResult < 0) {
　　　　　　LOG.info("Original int " + myValue + "has nagetive abs " + absResult);
　　　　}
　　6.很少出现的else情况：
　　　　代码中，一定要有完整的if else，如果else 里面没有要执行的，记录日志，这样避免else吞掉你的请求，或是返回给你难以理解的结果。

　　　　Object result = null;
　　　　if (running) {
　　　　　　result = xxx;
　　　　} else {
　　　　　　result = yyy;
　　　　　　LOG.debug("System does not running, we change the final result");
　　　　}

　　7. 批量数据的执行进度：

　　　　LOG.debug("current progress: " + (currentPos * 100 / totalAmount) + "%");

　　日志记录的方式

　　1. 日志信息应该包含记录程序运行时间和错误发生的时间.

　　2. 日志信息清晰准确有意义
　　　　日志应该是清晰准确的: 当看到日志的时，就能准确的知道错误是因为连接池取不到连接导致的问题。

　　　　Connection connection = ConnectionFactory.getConnection();
　　　　if (connection == null) {
　　　　　　LOG.warn("System initialized unsuccessfully");
　　　　}
　　3. 记录错误的位置
　　　　代码中，一定要记录下错误所在的文件名和函数名（必须能区分开重载函数）,有行数最好。

　　4. 区分日志级别
　　　　在程序中Log进行分级是很重要的，通常可以分为6 级：TRACE<DEBUG<INFO<WARN<ERROR<FATAL。
DEBUG用来输出调试信息，一般是在程序中不是非常重要的地方；INFO代表一些比较重要的信息，比如程序初始化完毕，ERROR一般指程序本身引起的，可以恢复的错误；FATAL其中常用的是DEBUG和 ERROR。

　　5. 信息详细准确
一定要记录下完整准确的信息，否则还不如记录，因为错误的信息可能会误导开发人员。所以最简单的办法就是记录完整的stack trace.

　　6. 最好能给log带上上下文
　　　　没有相应的上下文的log，不过是噪音，它们不会对调试过程中有意义的数值或是空间起作用。
　　　　Transaction failed 这样的log信息比没有记录更让人抓狂。
```



## 参考总结

```java
https://www.cnblogs.com/zhangweizhong/p/3918524.html
https://www.jianshu.com/p/546e9aace657
```

## 其他

```java
在测试的设备上，是安装不了如此重的 VisualStudio 的，于是 WPF 如何在应用程序调试启动 的方法也用不了。同时因为软件一启动就 gg 了，所以附加调试也用不了。就连 神器如 dnSpy 也被测试小姐姐说不要弄坏她的电脑不能用
```

