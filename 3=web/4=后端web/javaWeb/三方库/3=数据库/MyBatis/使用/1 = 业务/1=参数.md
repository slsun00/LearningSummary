# 参数

## #{ } 获取参数值 -- 预编译

```java
获取方法的参数
// public void update(Integer ID)
<update id="update">
    update User set id=#{ID} 
</update>   
    
介绍
    告诉 MyBatis 创建一个预处理语句参数，
    通过 JDBC，这样的一个参数在 SQL 中会由一个 "?" 来标识，并被传递到一个新的预处理语句中
	// Similar JDBC code
    <update id="update">
        update User set id= ? 
    </update>   
    
    
参数
    单个参数
    	基本类型： #{ 随便写 }， 都会默认取仅有的参数
    	pojo   :  #{ }
    多个参数
        // 自动封装 map
        方式一： 使用参数位置索引（0,1,2，...） 
        	#{0}
        方拾二： 使用第几个参数 paramN （param1, param2, ...） 
            #{param1}
	    方式三：参数中之指定封装的 map 的 key
             findAll(@Param("id")Integer id,@Param("name")String name);
		原因： 
            传入多个参数，mybatis 会自动将这些参数封装到一个map 中
            key 为参数的索引、参数的第几个表示， #{key} 即从  map 中取值
    传入 pojo
		#{pojo的属性名}     
	传入 map
        #{key}
复合多参数
    参数中具有 基本类型、map、pojo， mybatis 会自动封装为 map
    使用
    	// 使用索引、第几个参数找参数
    	map 位于第 n 个参数 #{paramN.key}
    参数
```

## ${ } 拼接参数值 -- 拼接

```sql
${key}：
    直接拼接到SQL中
    获取参数的值，有SQL注入问题。ORDER BY ${name}
语法例子
    id=${id} and empname= #{empName}:
    select * from t_ employee where id=1 and empname= ?
    id=#{id} and empname=#{empName}:
    select * from t_ employee where id=? and empname= ?
使用
	# sql 只有参数位置支持预编译，所以只能使用 ${ }     ???
场景一 	
	有时你只是想直接在 SQL 语句中插入一个不改变的字符串。
	比如，像 ORDER BY，你可以这样来使用(这里 MyBatis 不会修改或转义字符串)
		ORDER BY ${columnName}
	优化
		以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，
		因此要么不允许用户输入这些字段，要么自行转义并检验
```

## # vs $ 不同

```sql
#{key}：
    参数预编译的方式，参数的位置都是用 ？ 代替， 参数都是后来预编译设置进去的
    获取参数的值，预编译到SQL中。安全。
${key}
	直接拼接到SQL中
	
识别记忆
	java vue reacr 中都有一个 ${} 表示一个变量，
	这个变量就是一个占位符传递的值是直接拼接到原位置的
```





## 参数取值规范

```java
参数位置支持的属性
    // 都是自动的，除了 jdbcType 可能需要执行
    javaType、jdbcType、mode、numericScale、resultMap、typeHandler、jdbcTypeName、expression
语法例子
    id = #{id, jdbcType=INTEGER}
注意
    当传递的值为 null 对于所有可能为空的列，jdbcType 需要被设置
    mysql 插入 null 无问题
    oracle 不知道 null 是什么类型
```



# 传参

## 简单类型

```sql
# 普通的传参
<select id="selectUsers" resultType="User">
  select id, username, password    # 简单的参数
  from users
  where id = #{id}
</select>


```

## 对象类型 -- 参数映射

```sql
# User 类型的参数对象传递到了语句中，
# id、username 和 password 属性将会被查找，然后将它们的值传入预处理语句的参数中

<insert id="insertUser" parameterType="User">
  insert into users (id, username, password)
  values (#{id}, #{username}, #{password})
</insert>
      
      
      
不懂
      像 MyBatis 的剩余部分一样，javaType 通常可以从参数对象中来去确定，前提是只要对象不是一个 HashMap。那么 javaType 应该被确定来保证使用正确类型处理器。

NOTE 如果 null 被当作值来传递，对于所有可能为空的列，JDBC Type 是需要的。你可以自己通过阅读预处理语句的 setNull() 方法的 JavaDocs 文档来研究这种情况
```

# 参数类型

```sql
介绍


    指定一个特殊的数据类型
     #{property,javaType=int,jdbcType=NUMERIC}

	指定一个特殊的类型处理器类（或别名）
	#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}

	数值类型，还有一个小数保留位数的设置，来确定小数点后保留的位数
	#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}
```

### mode 属性

```mysql
mode 属性允许你指定 IN，OUT 或 INOUT 参数。
     OUT 或 INOUT，
    	参数对象属性的真实值将会被改变，就像你在获取输出参数时所期望的那样。
        若 jdbcType 为 CURSOR(也就是 Oracle 的 REFCURSOR)，
    		你必须指定一个 resultMap 来映射结果集到参数类型。
        要注意这里的 javaType 属性是可选的，
    		如果左边的空白是 jdbcType 的 CURSOR 类型，它会自动地被设置为结果集。
    
#{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}  


	支持很多高级的数据类型，比如结构体，但是当注册 out 参数时你必须告诉它语句类型名称。
	比如（再次提示，在实际中要像这样不能换行）：
	#{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, 
	    resultMap=departmentResultMap}
```

### 空列设置

```sql
需要将可能为空的列名指定 jdbcType。
    #{firstName}
    #{middleInitial,jdbcType=VARCHAR}
    #{lastName}
    
```

