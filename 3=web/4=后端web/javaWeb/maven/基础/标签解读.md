

### project 

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

    
<!ELEMENT project
    是 pom.xml 中描述符的根。
子元素(
    
  modelVersion
    	指定 pom.xml 符合哪个 maven 版本的描述符。
		maven 2 和 3 只能为 4.0.0。
    
    
 <!-- The Basics -->  
  groupId
    	团体、组织的标识符, 
    	公司的逆命名 com.baidu
  artifactId
    	包名，	不要在 artifactId 中包含点号(.)。
  version
	    一个项目的特定版本
  packaging
    	打包的方式， 默认是 jar
    	常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par
     
  parent
  modules
    
// 依赖信息    
  dependencies
  dependencyManagement
  properties
    
    <!-- Build Settings -->
  build
  reporting

  <!-- More Project Information -->
  name
  description
  licenses
    
  organization
  inceptionYear
  url
  developers    
  contributors




    
 <!-- Environment Settings -->
  prerequisites
  repositories
  pluginRepositories
  profiles    
    
  distributionManagement   
  issueManagement    
  ciManagement
  scm
  mailingLists

)>    
    
```





















###   dependencies

```xml
<!ELEMENT dependencies 
子元素(
	dependency*
)> 

<!ELEMENT dependency
子元素(
	groupId artifactId	version
		<!--同 project 的-->
	type
		<!--对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。-->
	scope
		<!--此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。
		有 5 种可用的限定范围：
		compile - 
			如果没有指定 scope 标签，maven 默认为这个范围。
			编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。
		provided 
			与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。
			它只适用于编译和测试 classpath，不可传递。
		runtime -
 			此范围表示编译不需要依赖关系，而是用于执行。
			它是在运行时和测试 classpath，但不是编译 classpath。
		test - 
			此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。
			它不是传递的。
		system - 
			此范围与 provided 类似，
			除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。
		-->
	systemPath
		<!--
		仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。
		该路径必须是绝对路径，建议使用 propertie 来指定特定的路径，如\$ {java.home} / lib
		假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。
	     如果没有，maven 将会失败，并建议您手动下载安装
		-->
	optional
		<!--让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。
		-->
	exclusions*
	    <!--包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。
			与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。
		-->
)>
<!ELEMENT  exclusions 
子元素(
	groupId artifactId	version
		<!--同 project 的-->
)>

<dependencies>
    <dependency>
     <groupId>org.apache.maven</groupId>
      <artifactId>maven-embedder</artifactId>
      <version>2.0</version>
      <type>jar</type>
      <scope>test</scope>
      <optional>true</optional>
      <exclusions>
        <exclusion>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-core</artifactId>
        </exclusion>
      </exclusions>
    </dependency>
```



### profiles

```java
介绍
    开发环境： 开发、测试、线上
    
```



### 可被继承的标签

```java
// 坐标
	groupId：项目组ID，项目坐标的核心元素
    version：项目版本，项目坐标的核心元素
    description：项目的描述信息
        
// 依赖信息
    properties：自定义的Maven属性
    dependencies：项目的依赖配置
    dependencyManagement：项目的依赖管理配置     

// 仓库信息
	   repositories：项目的仓库配置        
// 其他信息        
    organization：项目的组织信息
    inceptionYear：项目的创始年份
    url：项目的URL地址
    developers：项目的开发者信息
    contributors：项目的贡献者信息
    distributionManagement：项目的部署配置
    issueManagement：项目的缺陷跟踪系统信息
    ciManagement：项目的持续集成系统信息
    scm：项目的版本控制系统信息
    mailingLists：项目的邮件列表信息

 
    build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等
    reporting：包括项目的报告输出目录配置、报告插件配置等

   
```

### 父项目标签

#### modules

```java
介绍
	子模块列表
语法例子
  <modules>
    <module>my-project</module>
    <module>another-project</module>
    <module>third-project/pom-example.xml</module>
  </modules>
```

#### dependencies

```java
    引入一个无版本号的 jar 包， 就会去 dependencyManagement 里找对应的 artifactId的jar,
	如果有就继承他，如果没有就会报错 
```

#### properties

```java
介绍
	属性列表。
	定义的属性可以在 pom.xml 文件中任意处使用 ！！！！！！
	使用方式为 ${propertie} 
语法例子
<project>
      ...
      <properties>
        <maven.compiler.source>1.7<maven.compiler.source>
        <maven.compiler.target>1.7<maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
      </properties>
      ...
</project>
```

#### dependencyManagement

```java
dependencyManagement
    管理依赖jar版本号的作用, 一般只用在父项目中
    // 注意！！！子模块也要声明
    子项目使用到里面声明的 jar, 需要写声明依赖，但是不用写版本号，
    不是真实的下载jar，只有在子module中使用到，才会去下载依赖
    // 版本号获取
    各个依赖的版本号由properties标签定义，通过$ {变量名}的形式动态获取版本号。


介绍
	表示依赖 jar 包的声明， 可以被子 POM 继承
	即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，
使用场景
	当有父子项目的时候，父项目中可以利用 dependencyManagement 声明子项目中需要用到的依赖 jar 包，之后，
	当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。
```



### 子项目标签

#### parent

```java
介绍
	maven 支持继承功能。
	子 POM 可以使用 parent 指定父 POM ，然后继承其配置
语法
<!ELEMENT parent
子元素(
	groupId artifactId	version
		<!--同 project 的-->
	relativePath
		指明父模块 POM 的路径，
    	值默认值:	
    		../pom.xml。其值同样是一个是基于当前POM文件的相对路径
    	使用： 
    		父子目录结构： 该元素值可省略，使用默认值即可
    		平行目录结构： ../springBoot2-root/pom.xml
)>
```













#### 方式一

```java
在父pom中引入相关依赖，都记录在<dependencies>下，
    子模块直接继承父pom的依赖，在子模块中开发中就不必再去引入依赖，
    但在项目中有模块可能就是单一的工具包，它并不需要springboot的依赖，这时候启动就会冲突。
    可以这样解决，在父pom中定义springboot版本号，子模块作为项目启动的模块配置springboot插件依赖，
    普通的dao，serivce，common不必引入。如下配置文件，文件中只列举个别依赖包，重在说明问题：
// 方式二
    将所有的依赖在父pom的中声明，子模块把需要的都引入一遍：
```



### 父子交互

```java
父项目找到子项目
    通过 modules 找到子项目
子项目找到父项目
    通过 parents 找到
依赖传递
// 父项目
    
// 子项目    
    
```

