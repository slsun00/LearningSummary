## == 数据结构 ==

## 变量

```js
可以使用变量来储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。
    
    

class LoginControl extends React.Component {
  constructor(props) {
    super(props);
	
    // 变量存储元素      
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.state = {isLoggedIn: false};
  }
 
  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

 
  render() {
    const isLoggedIn = this.state.isLoggedIn;
 
    let button = null;
    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }
 
    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}  // 变量
      </div>
    );
  }
}
 
ReactDOM.render(
  <LoginControl />,
  document.getElementById('example')
);
    
```

## == 面向对象 == 

## 方法

```java
参看：事件
```



## == 高级结构 == 



## keys

### 使用

```java
介绍
    1. Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。
    	因此你应当给数组中的每一个元素赋予一个确定的标识。
    2. 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。
    	通常，我们使用来自数据的 id 作为元素的 key
    	当元素没有确定的 id 时，你可以使用他的序列号索引 index 作为 key
    3. 如果列表可以重新排序，我们不建议使用索引来进行排序，因为这会导致渲染变得很慢
    
例子
    const todoItems = todos.map((todo, index) =>
      // 只有在没有确定的 id 时使用
      <li key={index}>
        {todo.text}
      </li>
    );
```

### 使用位置

```java
元素的 key 只有在它和它的兄弟节点对比时才有意
数组元素中使用的 key 在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。  

function ListItem(props) {
  // 对啦！这里不需要指定key:
  return <li>{props.value}</li>;
}
 
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // 又对啦！key应该在数组的上下文中被指定
    <ListItem key={number.toString()}
              value={number} />
 
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}
 
const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('example')
);
   
```

### 传递

```java
介绍
    key 会作为给 React 的提示，但不会传递给你的组件。
    如果您的组件中需要使用和 key 相同的值，请将其作为属性传递：
例子
    const content = posts.map((post) =>
	// Post 组件可以读出 props.id，但是不能读出 props.key。                              
      <Post
        key={post.id}
        id={post.id}
        title={post.title} />
    );
```



## 数组

```java
介绍
    SX 允许在模板中插入数组，数组会自动展开所有成员

```

### 遍历

```java
介绍
    
// 遍历    
	map() 方法遍历数组


    function NumberList(props) {
      const numbers = props.numbers;
    
     // 遍历数组
      const listItems = numbers.map((number) =>
	   // 组件接收数组参数，每个列表元素分配一个 key，
       // 不然会出现警告 a key should be provided for list items，意思就是需要包含 key：
	   // 避免使用索引这种变化的数据作为 key                                     
        <li key={number.toString()}>
          {number}
        </li>
      );
      return (
        <ul>{listItems}</ul>
      );
    }

    const numbers = [1, 2, 3, 4, 5];
    ReactDOM.render(
      <NumberList numbers={numbers} />,
      document.getElementById('example')
    );

 

// 自动展示    
    var arr = [
      <h1>菜鸟教程</h1>,
      <h2>学的不仅是技术，更是梦想！</h2>,
    ];
    ReactDOM.render(
      <div>{arr}</div>,
      document.getElementById('example')
    );

// 嵌入{}
    function NumberList(props) {
      const numbers = props.numbers;
      return (
        <ul>
          {numbers.map((number) =>
            <ListItem 
               key={number.toString()}
               value={number} />

          )}
        </ul>
      );
    }
	
```



## 集合 => map

## == 数据验证 ==

## props 数据验证

### 介绍

```java
对于组件来说， props 是外来的， 无法保证组件使用者传入什么格式的数据
如果传入的数据格式不对， 可能会导致组件内部报错
问题
    组件的使用者不知道明确的报错原因
```

### 使用

```java
校验
    允许在创建组件的时候，就指定 props 的类型、格式
作用
    捕获组件时，因为 props 导致的错误，给出明确的错误提示，增加组件的健壮性
步骤
    1. 安装 prop-types (npm i props-types)
    2. 导入 prop-types 包
    	import PropTypes from 'prop-types'
    3. 使用组件名.prortypes = {} 给组件的 props 添加校验规则
    	class 组件名 extends xxx {}
        组件名.protypes = {
         colors：PropTypes.array
        }
```



### 常见约束规则

```java

MyComponent.propTypes = {
    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的
   optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,
 
    // 可以被渲染的对象 numbers, strings, elements 或 array
    optionalNode: React.PropTypes.node,
 
    //  React 元素
    optionalElement: React.PropTypes.element,
    
    // 特定 shape 参数的对象
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),
 	
    // 任意类型加上 `isRequired` 来使 prop 不可空。
    requiredFunc: React.PropTypes.func.isRequired,
 
    // 不可空的任意类型
    requiredAny: React.PropTypes.any.isRequired,
    
    
    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
    optionalMessage: React.PropTypes.instanceOf(Message),
 
    // 用 enum 来限制 prop 只接受指定的值。
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),
 
    // 可以是多个对象类型中的一个
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),
 
    // 指定类型组成的数组
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),
 
    // 指定类型的属性构成的对象
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),
 

 

 
    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }
  }
}

```

