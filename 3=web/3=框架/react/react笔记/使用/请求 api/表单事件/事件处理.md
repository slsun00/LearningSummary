## 介绍

```java
React 元素的事件处理和 DOM 元素类似, 只是语法不同
    React 事件绑定属性的命名采用驼峰式写法，而不是小写
    如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM 元素的写法)
    
```

## 事件绑定

### 语法

```java
介绍
    react 事件绑定语法和 dom 事件语法类型
语法
    // 事件名称采用 驼峰法
    on + 事件名称 = {事件处理程序}
例子
    // react 语法
    <button onClick={activateLasers}>
      激活按钮
    </button>
    
    // == html 写法
    <button onclick="activateLasers()">
      激活按钮
    </button>
```

### 例子

#### 普通

```js
class App  extends React.Component{
	state = {
        count: 0 //,
    }
    render() {
        return(
   		<div>
            <h1>点我！点击次数为: {this.state.clickCount}</h1>
            
			// 事件绑定
            <button onClick={() => {              
                this.setState({
                    count:this.state.count + 1
                })
            }}> +1 </button>
		</div>
        )
    }
}    
ReactDOM.render(
  <App />,
  document.getElementById('example')
);

```



#### 类组件绑定

```js
class App extends React.Component {
    
  // 事件处理程序
 activateLaser() {
      console.log("事件触发了")
  }
  
  render() {
      return (
       <button onClick={this.activateLaser}>
        激活按钮
      </button>
      )
  }
}

ReactDOM.render(
<App />,
  document.getElementById('root')
)
```

#### 函数组件绑定

```js
function App() {
    
  // 事件处理程序
 activateLaser() {
      console.log("事件触发了")
  }

return (
    <button onClick={this.activateLaser}>
    激活按钮
	</button>
)
  }
}

ReactDOM.render(
<App />,
  document.getElementById('root')
)
```

### 方法抽离

#### 介绍

```java
需要解决 js 方法抽离以后， this 的指向问题
    
// 函数如何在 JavaScript 中运行
	通常情况下，如果你没有在方法后面添加 () ，
    例如 onClick={this.handleClick}，你应该为这个方法绑定 this。'    
```



#### 箭头函数 -- es6

```java
利用 箭头函数不绑定 this 的特点， 
render 方法中的 this 为组件实例，可以获取到 setState
    
// =======================================    
class App  extends React.Component{
	state = {
        count: 0 //,
    }

	onIncreame() {
        console.log(this) // 就是 App 对象
        this.setState({
            count:this.state.count + 1
        })
    }
    render() {
        return(
   		<div>
            <h1>点我！点击次数为: {this.state.clickCount}</h1>
            // 箭头函数中的 this 指向外部环境
            // 此处就是 render() 方法的 this, 就是类的实例     
            // 有参数情况： (e) => this.onIncreame(e) 
            <button onClick={() => this.onIncreame() }> +1 </button>
		</div>
        )
    }
}    
ReactDOM.render(
  <App />,
  document.getElementById('example')
);

// 注意
          
/*
、每次 LoggingButton 渲染的时候都会创建一个不同的回调函数
、然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染
、建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题			
*/          
//  这个语法确保了 `this` 绑定在  handleClick 中

```

#### bind() -- es5

```java
利用 es5 中的  bind 方法 ， 将事件处理程序的 this 和 组件实例绑定到一起

    
// =======================================    
class App  extends React.Component{
    constructor() {
        super()
		// 和实例的 this 相绑定            
		this.onIncreame = this.onIncreame.bind(this)            
    }
	state = {
        count: 0 //,
    }

// 	onIncreame()  函数
    
    render() {
        return(
   		<div>
            <h1>点我！点击次数为: {this.state.clickCount}</h1>
	// 箭头函数中的 this 指向外部环境
	// 此处就是 render() 方法的 this, 就是类的实例              
            <button onClick={ this.onIncreame }> +1 </button>
		</div>
        )
    }
}    
ReactDOM.render(
  <App />,
  document.getElementById('example')
);
    
```



#### class 实例方法

```js
利用箭头函数形式的 class 实例化方法
注意
	这个是实验性质的语法，由于 babel 存在才可以直接使用
  	如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：     
// =======================================    
class App  extends React.Component{

	state = {
        count: 0 //,
    }
	
	// 利用箭头函数形式的 class 实例化方法
    // 这个语法确保了 `this` 绑定在  handleClick 中
	// 这里只是一个测试
	onIncreame = () =>{
        this.setState({...})
    }
    
    render() {
        return(
   		<div>
            <h1>点我！点击次数为: {this.state.clickCount}</h1>
	// 箭头函数中的 this 指向外部环境
	// 此处就是 render() 方法的 this, 就是类的实例              
            <button onClick={ this.onIncreame }> +1 </button>
		</div>
        )
    }
}    
ReactDOM.render(
  <App />,
  document.getElementById('example')
);
    
```



## 事件参数对象

### 事件对象

#### 介绍

```java
介绍
    可以通过事件处理程序的参数获取到事件对象
    react 中的事件对象叫做： 合成事件（对象）
    合成事件：
    	这样叫原因是该对象经过合成了
    	兼容所有浏览器，无需担心跨浏览器兼容性问题

```

#### 例子

```js
class App extends React.Component {
    
  // 事件处理程序
 activateLaser(e) {
     e.preventDefault() // 阻止浏览器的默认行为
      console.log("事件触发了")
  }
  
  render() {
      return (
       <button onClick={this.activateLaser}>
        激活按钮
      </button>
      )
  }
}

ReactDOM.render(
<App />,
  document.getElementById('root')
)
```

### 事件参数

#### 介绍

```java
介绍
    常我们会为事件处理程序传递额外的参数
语法
    // 以下两种方法是等价的
    // 若是 id 是你要删除那一行的 id
    <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
	<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
分析
    1. 参数 e 作为 React 事件对象将会被作为第二个参数进行传递。
    	通过箭头函数的方式，事件对象必须显式的进行传递，
    	通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。
```

### 组件参数传递

```java
参看组件中的数据传递
```



## 监听器

### 介绍

```java
介绍
    使用 React 的时候通常你不需要使用 addEventListener 为一个已创建的 DOM 元素添加监听器。
    你仅仅需要在这个元素初始渲染的时候提供一个监听器。
注意
    // 谨慎对待 JSX 回调函数中的 this,类的方法默认是不会绑定 this 的
    
例子
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};
 
    // 这边绑定是必要的，这样 `this` 才能在回调函数中使用
   // 如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。
    this.handleClick = this.handleClick.bind(this);
  }
 
  // 你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。    
  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }
 
  render() {
    return (
      // 如果你忘记绑定 this.handleClick 并把它传入 onClick, 
     // 当你调用这个函数的时候 this 的值会是 undefined。        
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
 
ReactDOM.render(
  <Toggle />,
  document.getElementById('example')
);
    
```



### 类组件中监听函数

```java
介绍
	通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面
例子
    
    class Popper extends React.Component{
        constructor(){
            super();
            this.state = {name:'Hello world!'};
        }

        preventPop(name, e){    //事件对象e要放在最后
            e.preventDefault();
            alert(name);
        }

        render(){
            return (
                <div>
                    <p>hello</p>
                    {/* 通过 bind() 方法传递参数。 */}
                    <a href="https://reactjs.org" 
                	   onClick={this.preventPop.bind(this,this.state.name)}
                	>Click</a>
                </div>
            );
        }
    }
	
```

## 事件行为

### 阻止默认行为

```java

// == React 中另一个不同是你不能使用返回 false 的方式阻止默认行为， 你必须明确使用 preventDefault
function ActionLink() {
  // e 是一个合成事件
  // 
  function handleClick(e) {
    e.preventDefault();
    console.log('链接被点击');
  }
 
  return (
    <a href="#" onClick={handleClick}>
      点我
    </a>
  );
}

// == HTML
<a href="#" onclick="console.log('点击链接'); return false">
  点我
</a>
```