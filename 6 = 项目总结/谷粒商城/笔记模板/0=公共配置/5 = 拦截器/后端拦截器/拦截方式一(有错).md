## 配置类

```java
package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.validation.MessageCodesResolver;
import org.springframework.validation.Validator;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.config.annotation.*;

import java.util.List;

/**
 * 拦截器(可做跨域，token验证等)
 */

@Configuration
public class WebRequestInterceptor implements WebMvcConfigurer {
    
   /*
	   这里放各种配置的代码
   
   */
    
    
    
    /**
     * 修改访问路径
     * @param configurer
     */
    public void configurePathMatch(PathMatchConfigurer configurer) {
        // 设置为true后，访问路径后加/ 也能正常访问  /user == /user/
        // configurer.setUseTrailingSlashMatch(true);
    }

    /**
     * 内容协商机制，主要是方便一个请求路径返回多个数据格式
     * @param configurer
     */
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
    }

    /**
     * 处理异步请求的。只能设置两个值，一个超时时间（毫秒，Tomcat下默认是10000毫秒，即10秒），还有一个是AsyncTaskExecutor，异步任务执行器
     * @param configurer
     */
    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
//        //设置超时时间
//        configurer.setDefaultTimeout(1000000);
//        //设置异步任务执行器
//        configurer.setTaskExecutor(new AsyncTaskExecutor() {
//            @Override
//            public void execute(Runnable runnable, long l) {
//
//            }
//
//            @Override
//            public Future<?> submit(Runnable runnable) {
//                return null;
//            }
//
//            @Override
//            public <T> Future<T> submit(Callable<T> callable) {
//                return null;
//            }
//
//            @Override
//            public void execute(Runnable runnable) {
//
//            }
//        });
    }

    /**
     * 这个接口可以实现静态文件可以像Servlet一样被访问。
     * @param configurer
     */
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
    }
    

    /**
     * 添加静态资源--过滤swagger-api (开源的在线API文档)
     * @param registry
     */
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
    }



    public void addViewControllers(ViewControllerRegistry registry) {
    }

    public void configureViewResolvers(ViewResolverRegistry registry) {
    }

    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
    }

    public void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers) {
    }
    /**
     * 配置消息转换器
     * @param converters
     */
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
    }

    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
    }

    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
    }

    public void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
    }

    @Nullable
    public Validator getValidator() {
        return null;
    }

    @Nullable
    public MessageCodesResolver getMessageCodesResolver() {
        return null;
    }
}

```

### 自定义 拦截器

```java

    /**
     * 自定义拦截器()
     * @param registry
     */
    public void addInterceptors(InterceptorRegistry registry) {
    	// RequestInterceptor为具体拦截逻辑的执行类 实现了HandlerInterceptor接口
    	// addPathPatterns("/test/**")  意义是访问路径下/test 下所有的访问路径都需要被RequestInterceptor拦截
    	// excludePathPatterns 这个访问路径/test/exception则不在被RequestInterceptor拦截的范围
    	// /user/** user下所有路径都包含在内 例：/user/api 、/user/api/zz 
    	// /user/* 只有user下一层路径包含在内 例：/user/api(包含) 、/user/api/zz(不包含) 
    	// /test/queryUser接口则是token验证后，把token为xx的玩家信息放入Request中，方便接口拿取
        registry.addInterceptor(new RequestInterceptor())
        		.addPathPatterns("/test/**")
        		.addPathPatterns("/test/queryUser")
                .excludePathPatterns("/test/exception");
    }
```



### 跨域配置

```java

    /**
     * 跨域支持 比如说vue 的axios访问
     * @param registry
     */
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                .maxAge(3600 * 24);
    }
```

### 格式转换

```java


    /**
     * 增加转化器或者格式化器。这边不仅可以把时间转化成你需要时区或者样式。还可以自定义转化器和你数据库做交互，比如传进来userId，经过转化可以拿到user对象
     * @param registry
     */
    public void addFormatters(FormatterRegistry registry) {
    }
```

## 自定义拦截器

```java
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.example.demo.entity.model.ResponseDto;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.util.Enumeration;

public class RequestInterceptor implements HandlerInterceptor {

        /**
         * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller
         * 返回值：
         * true表示继续流程（如调用下一个拦截器或处理器）；
         * false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；
         */
        @Override
        public boolean preHandle(
            HttpServletRequest httpServletRequest, 
            HttpServletResponse httpServletResponse, 
            Object o
        ) throws Exception {
        	//将头部信息都转换成map
            JSONObject map = new JSONObject();
            Enumeration<String> headerNames = httpServletRequest.getHeaderNames();
            while (headerNames.hasMoreElements()) {
                String key = headerNames.nextElement();
                String value = httpServletRequest.getHeader(key);
                map.put(key, value);
            }
            map.put("token", httpServletRequest.getHeader("AUTH-TOKEN"));
            //判断从前端传来的头部信息中AUTH-TOKEN的值是否与我们后台定义的token值一致
            if("111".equals(map.get("token"))){
                //token正确 继续下一步拦截器(如果有)
                System.out.println("token is right");
                //从Spring上下文中拿到UserMapper
                UserMapper userMapper= ApplicationContextUtil.getBean(UserMapper.class);
                //获取该token对应的用户信息
                User user=userMapper.getUserByToken(String.valueOf(map.get("token")));
                //将用户信息放入Request中
                httpServletRequest.setAttribute("test",JSON.toJSONString(user));
                return true;
            }else{
                //token错误 返回错误response 
                System.out.println("token is error");
                PrintWriter writer = null;
                try {
                    ResponseDto dto=new ResponseDto();
                    dto.setErrorCode(1002);
                    dto.setMessage("RequestInterceptor");
                    httpServletResponse.setCharacterEncoding("utf-8");
                    httpServletResponse.setHeader("Content-Type","application/json");
                    writer = httpServletResponse.getWriter();
                    //将返回的错误提示压入流中
                    writer.write(JSON.toJSONString(dto));
                    writer.flush();
                } catch (Exception e) {

                } finally {
                    if (null != writer) {
                        writer.close();
                    }
                    return false;
                }
            }

        }

        /**
         * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。
         */
        @Override
        public void postHandle(
            HttpServletRequest request, 
            HttpServletResponse response, 
            Object handler, 
            ModelAndView modelAndView
        ) throws Exception {
        }

        /**
         * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中
         */
        @Override
        public void afterCompletion(
            HttpServletRequest httpServletRequest, 
            HttpServletResponse httpServletResponse, 
            Object o, 
            Exception e
        ) throws Exception {
        }


}

```

