## 自定义异常模板

```java
1. 创建具体类型的异常，需要 extends runtimeException
2. 异常处理类
    // 注解上你自定义的类： exceptionHandler(....class)
    添加具体的处理方法
    	视图跳转：
    		具体出现这类错误需要跳转的页面
 3. 编写具体的错误页面
```

### 使用的异常

```java
登陆异常
```



```java
controller
    1. 获取请求参数
    2. 参数传入对应的 service
    service

// 该方法失败的自定义异常    
service
    1. 调用  mapper 查数据
    2. 业务处理
    3. 抛异常
mapper    
```

## 登陆

```java
// 前端

// 点击
		<form action="admin/do/login.html" method="post">
			<h2 >
				<i class="glyphicon glyphicon-log-in"></i> 管理员登录
			</h2>
			
			<div>
				<input type="text" name="loginAcct" class="form-control" id="inputSuccess4"
					placeholder="请输入登录账号" autofocus>
			</div>
			<div>
				<input type="text" name="userPswd" class="form-control" id="inputSuccess4"
					placeholder="请输入登录密码" style="margin-top: 10px;">
			</div>
			<button type="submit" >登录</button>
		</form>


// 后端
controller
    1. 获取请求参数
    2. 参数传入对应的 serviceImpl 的方法
		根据账号查询 admin 对象                
    3. 登陆成功
		将 admin 存入 session 域， 
		视图跳转：
			重复提交： 重定向到新的页面                   
    
service
	1. 查询 admin 对象（根据账号）
		admin 为 null
                抛出自定义异常
		admin 不为 null
                1.数据库密码 从 admin 中取出
                2.表单密码 ==>  加密  ==》 加密密码
                3.admin密码  === 加密秘密
                	不一致： 跑异常
                	一致：  返回 admin 对象
                
    
mapper   
	//                
```

## 退出

```java
1. session 失效
2. 重定向
    redirect:/admin/to/login/page.html  view-name
```

## 登陆检查 -- 拦截器

![image-20210613193138976](image-20210613193138976.png)

```java
handlerIntercepter
    对登陆前后都进行检查
// 对请求前判断即可
HandlerInterceptorAdapter 空的实现
    
检查业务
    1. 获取 sessioin     
    2. 从 session 域中获取 admin 对象
    	admin 为 null
    		抛出自定义异常
    	admin 非 null
    		直接返回true 不作处理
    
    
 // 为什么退出不进行拦截器检查登陆
    当你出去过长的时间， session 失效， 
    当你退出的时候，
    	进行拦截：你需要登陆以后才能进行退出
    	没有拦截： 直接退出就行了
    	// 所以没哟必要对 退出进行登陆拦截检查
    
    
    

public class LoginInterceptor extends HandlerInterceptorAdapter {

	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		
		// 1.通过request对象获取Session对象
		HttpSession session = request.getSession();
		
		// 2.尝试从Session域中获取Admin对象
		Admin admin = (Admin) session.getAttribute(CrowdConstant.ATTR_NAME_LOGIN_ADMIN);
		
		// 3.判断admin对象是否为空
		if(admin == null) {
			
			// 4.抛出异常
			throw new AccessForbiddenException(CrowdConstant.MESSAGE_ACCESS_FORBIDEN);
			
		}
		
		// 5.如果Admin对象不为null，则返回true放行
		return true;
	}

}
    
```



## 问题

```java
// 重定向

return "redirect:/admin/to/main/page.html";   // 目标地址配置 controller

// 相当于是级联操作把？
// 为什么要进行级联操作，而不是直接重定向到这里？
<mvc:view-controller path="/admin/to/main/page.html" view-name="admin-main"/>
    
    
    
原因
    直接使用 
    	/*
    		浏览器访问的就是 localhost:8080/admin-main.js 是不对的 
    		实际路径是：/WEB-INF/admin-main.jsp
    		但是浏览器是不能访问 web-inf 文件夹的
    	*/
    	return "redirect:/admin-main"
    所以
    	使用一个级联操作
    	使用一个新的请求， 给该请求直接配置上这个视图即可
	    <mvc:view-controller path="/admin/to/main/page.html" view-name="admin-main"/>
```

