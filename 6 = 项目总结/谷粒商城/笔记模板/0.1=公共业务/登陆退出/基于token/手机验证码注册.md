## == vue ==

## 手机验证码注册

```java
业务逻辑总结
    其实这是两个逻辑，
    	发送验证码是一个api，
    	进行注册是一个api
用户/浏览器
    1. 通过浏览器（注册界面），发送请求验证码的请求（地址是：短信发送模块）
    2. 这个是通过两个 url 进行发送的
    	输入完手机号： 进行验证码发送，是一个请求
    	得到验证码，注册： 这个是另一个请求
    
服务器（和阿里云短信发送对接的平台）
    短信验证微服务
    1. 生成验证码
    	通过传递过来的手机号，
    	验证码： 通过随机数工具进行发送（也可使用其他工具api）
    2. 将验证码发送给阿里云平台： 
    	调用阿里云的 sdk 进行发送发给前台：【手机号。信息】，参考阿里云文档了就需要
    	阿里云发送信息之后，会抛给服务器一个结果信息， 需要对该信息进行判断， 来确定是否发送成功
 
    3. 将验证码存入到 redis 数据库
    	将【手机号。验证码。过期时间。过期时间的单位】
    
阿里云平台
    将验证码作为短信，发送给用户
    
用户
    输入验证码，点击注册， 发起请求（地址是：用户登陆注册模块）
    
服务器（用户注册登录模块）
    1. 校验验证码
    	从 redis 数据库获取验证码，和请求过来的验证码进行校验
    2. 注册用户
    	将用户信息存储入数据库
    3. 返回注册成功的结果
    
用户
    获取后盾返回的数据，根据反正状态码，进行数据渲染
    // 请求时相互对应的，是不需要进行
```

## == 信息发送模块 ==

### controller

```java
package com.atguigu.guli.service.sms.controller;

@RestController
@RequestMapping("/api/sms")
@Api(description = "短信管理")
@CrossOrigin //跨域
@Slf4j
public class ApiSmsController {

    @Autowired
    private SmsService smsService;

    @Autowired
    private RedisTemplate redisTemplate;

    @GetMapping("send/{mobile}")
    public R getCode(@PathVariable String mobile) throws ClientException {

        //校验手机号是否合法
        if(StringUtils.isEmpty(mobile) || !FormUtils.isMobile(mobile)) {
            log.error("请输入正确的手机号码 ");
            // 下面返回给前端，是不是也会拆分成三个部分？？？？？
            throw new GuliException(ResultCodeEnum.LOGIN_PHONE_ERROR);
        }

        //生成验证码
        String checkCode = RandomUtils.getFourBitRandom();
        // 通过阿里云的发送验证码
        smsService.send(mobile, checkCode);
        //将验证码存入redis缓存
        redisTemplate.opsForValue().set(mobile, checkCode, 5, TimeUnit.MINUTES);

        return R.ok().message("短信发送成功");
    }
}
```

### service -- 阿里云非通用

```java
package com.atguigu.guli.service.sms.service.impl;

@Service
@Slf4j
public class SmsServiceImpl implements SmsService {

    @Autowired
    private SmsProperties smsProperties;

    @Override
    public void send(String mobile, String checkCode) throws ClientException {

        //调用短信发送SDK，创建client对象
        DefaultProfile profile = DefaultProfile.getProfile(
            	// 在官方的基础上改版了
                smsProperties.getRegionId(),
                smsProperties.getKeyId(),
                smsProperties.getKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);

        //组装请求参数
        CommonRequest request = new CommonRequest();
        request.setSysMethod(MethodType.POST);
        request.setSysDomain("dysmsapi.aliyuncs.com");
        request.setSysVersion("2017-05-25");
        request.setSysAction("SendSms");
        request.putQueryParameter("RegionId", smsProperties.getRegionId());
        request.putQueryParameter("PhoneNumbers", mobile);
        request.putQueryParameter("SignName", smsProperties.getSignName());
        request.putQueryParameter("TemplateCode", smsProperties.getTemplateCode());

        Map<String, Object> param = new HashMap<>();
        
        // 接口本身就叫 code 
        param.put("code", checkCode);

        //将包含验证码的集合转换为json字符串
        Gson gson = new Gson();
        request.putQueryParameter("TemplateParam", gson.toJson(param));

        //发送短信
        CommonResponse response = client.getCommonResponse(request);

        // 不能使用 response.getHttpResponse().isSuccess()
        // 这个只是说明你 http 连接成功了，但是你欠费了，仍旧不可用
        //得到json字符串格式的响应结果
        String data = response.getData();

        //解析json字符串格式的响应结果
        HashMap<String, String> map = gson.fromJson(data, HashMap.class);
        String code = map.get("Code");
        String message = map.get("Message");

        //配置参考：短信服务->系统设置->国内消息设置
        //错误码参考：
        //https://help.aliyun.com/document_detail/101346.html?spm=a2c4g.11186623.6.613.3f6e2246sDg6Ry
        //控制所有短信流向限制（同一手机号：一分钟一条、一个小时五条、一天十条）
        if ("isv.BUSINESS_LIMIT_CONTROL".equals(code)) {
            log.error("短信发送过于频繁 " + "【code】" + code + ", 【message】" + message);
            throw new GuliException(ResultCodeEnum.SMS_SEND_ERROR_BUSINESS_LIMIT_CONTROL);
        }

        if (!"OK".equals(code)) {
            log.error("短信发送失败 " + " - code: " + code + ", message: " + message);
            throw new GuliException(ResultCodeEnum.SMS_SEND_ERROR);
        }
    }
}
```



## == 用户中心 ==

## 注册

### 后端

#### controller

```java
package com.atguigu.guli.service.ucenter.controller.api;

@Api(description = "会员管理")
@CrossOrigin
@RestController
@RequestMapping("/api/ucenter/member")
@Slf4j
public class ApiMemberController {

    @Autowired
    private MemberService memberService;

    @ApiOperation(value = "会员注册")
    @PostMapping("register")
    public R register(@RequestBody RegisterVo registerVo){
        memberService.register(registerVo);
        return R.ok();
    }
}
```

#### service

```java
@Autowired
private RedisTemplate redisTemplate;

/**
     * 会员注册
     * @param registerVo
     */
@Transactional(rollbackFor = Exception.class)
@Override
public void register(RegisterVo registerVo) {

    String nickname = registerVo.getNickname();
    String mobile = registerVo.getMobile();
    String password = registerVo.getPassword();
    String code = registerVo.getCode();

    //校验参数

    if (StringUtils.isEmpty(mobile)
        || !FormUtils.isMobile(mobile)
        || StringUtils.isEmpty(password)
        || StringUtils.isEmpty(code)
        || StringUtils.isEmpty(nickname)) {
        throw new GuliException(ResultCodeEnum.PARAM_ERROR);
    }

    // 优先走 redis ， 这样验证码不对， 就不用走数据库了
    // 减轻了服务器的压力
        
    //校验验证码
    String checkCode = (String)redisTemplate.opsForValue().get(mobile);
    if(!code.equals(checkCode)){
        throw new GuliException(ResultCodeEnum.CODE_ERROR);
    }

    //是否被注册
    // 手机号是唯一的， 账号的话，使用微信， 名字可能就是重复的
    
    QueryWrapper<Member> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("mobile", mobile);
    Integer count = baseMapper.selectCount(queryWrapper);
    if(count > 0){
        throw new GuliException(ResultCodeEnum.REGISTER_MOBLE_ERROR);
    }

    //注册： 就是将新用户的数据插入数据库
    Member member = new Member();
    member.setNickname(nickname);
    member.setMobile(mobile);
    member.setPassword(MD5.encrypt(password));
    member.setDisabled(false);
    member.setAvatar("https://guli-file-helen.oss-cn-beijing.aliyuncs.com/avatar/default.jpg");
    baseMapper.insert(member);
}
```

### 前端

#### api

```java
import request from '~/utils/request'

export default {

  sendMessage(mobile) {
    return request({
      baseURL: 'http://localhost:8150',
      url: `/api/sms/send/${mobile}`,
      method: 'get'
    })
  },

  register(member) {
    return request({
      baseURL: 'http://localhost:8160',
      url: '/api/ucenter/member/register',
      method: 'post',
      data: member
    })
  }
}
```

#### 页面 - 发送验证码

```js
import registerApi from '~/api/register'

// 获取验证码
getCodeFun() {
  // this.sending原为false,
  // 点击后立即使 this.sending == true，防止有人多次点击
  // 注意电话错误、重复提交都要禁用   
  this.sending = true
  registerApi.sendMessage(this.member.mobile).then(response => {
    this.timeDown()
    this.$message({
      type: 'success',
      message: '短信发送成功'
    })
  })
},

// 倒计时, 就是说需要发送一个验证码，需要间隔多长时间才能再次发送
// 这个算是个小工具把，以后会用到， 总结出来，以后使用  
timeDown() {
  const result = setInterval(() => {
    this.codeText = this.second
    this.second--
    if (this.second < 0) {
      clearInterval(result)
      this.sending = false
      this.second = 60
      this.codeText = '获取验证码'
    }
  }, 1000)
},
```

#### 页面 - 注册提交

```js
import registerApi from '~/api/register'

// 注册
submitRegister() {
    memberApi.register(this.member).then(response => {
        // 提示注册成功
        this.$message({
            type: 'success',
            message: '注册成功'
        })
        this.$router.push({ path: '/login' })
    })
}
```

