## 介绍

*   LIFO 结构， 栈就是堆栈！！！
*   last in first out
*    只能从表的一端存取数据 且 遵循 "先进后出" 原则的线性存储结构。



```java
/*        |
		 \/
        ┌    ┐
      4 |    |  
        ├ ── ┤
     3  |    |	
        ├ ── ┤
     2  | a2 |  栈顶元素
        ├ ── ┤
     1  | a1 |
        ├ ── ┤
   ->0  | a0 |  栈底元素
        └ ── ┘
	只能从上面进行增加、删除   
   
*/

栈： 只有一端可以进行数据的插入删除
    上面定制一个规则： 只允许从右侧添加和删除数据
    
// 一般来说栈顶、栈底都是说的栈顶元素、栈底元素 : 不一定对   
栈顶:	 栈的开口段，只有在该处允许插入和删除 // 6 号位置右侧的那条线
栈底： 栈的风口端： // 0 号位置左侧的那条竖线
    
栈顶元素： 距离栈顶最近的元素   // a2    
栈底元素： 位于栈最底部的元素  // a1

栈溢出
    加入过多元素，超过栈的本身大小
    top >= 栈容量
栈下溢
    栈为空， 仍旧进行取数据
    top < 0
```

## 分类

### 1. 顺序栈

*    **顺序存储结构**模拟栈存储数据的特点
*    底层采用的是数组， 



### 2. 栈链

*    **链式存储结构**实现栈结构；
*    底层采用的是链表 





## 顺序栈

### 1. 术语

```java
/*
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┐ 
| a0 | a1 | a2 | a3 | a4 |    |      <==可以添加数据的一侧
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┘  
   0    1    2    3    4    5    6		    
   
*/

栈底：
    数组下标为 0 的一端作为栈底  // a0
长度：
    数组的长度，注意数组内并不一定都有数据，看你是什么数组
游标 top
    // 记录元素的下标
    空栈： top 不指向任何下标，	 top=-1
    一个元素： top 指向下标为 0 	  top=0
    满栈： 数组长度减去一 
栈操作
    进栈： top + 1
    出栈： top - 1
```

### 2. 操作

```java
/*
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┐ 
| a0 | a1 | a2 | a3 | a4 |    |      <==可以添加数据的一侧
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┘  
   0    1    2    3    4    5    6		    
   
*/
 

空栈：
    top 不指向任何下标，	 top=-1
满栈： 
    数组长度减去一 
```



### 3.双端堆栈

#### 介绍

```java
*   对于两个相同类型的栈，不同类型栈，会增加问题的复杂度
*   用一个数组来存储两个栈
```



#### 操作

```java
/*
   0    1    2    3    4    5    6    7    8    9   10   11   13    
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┐ 
| a0 | a1 | a2 | a3 | a4 |    |    |    |    |    |    |    |    |  
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┘  
 top1                                                   top2	  
栈1栈底             -> 		                               栈 1 栈顶
栈2栈顶									  <-             栈 2 栈底
*/   

空栈
    栈1 ：top1 = -1
    栈2 ：top2 = 数组长度-1
满栈
    1. 栈1 满了
    2. 栈 2 满了
    3. 两栈
满栈
    // 两个栈的的栈顶元素相邻，即：相差 1 的时候, 两栈向中间靠拢的
    // 栈1 满了 + 栈 2 满了 + 两栈碰面
    top1 + 1 = top2
增加元素
    从数组的两端，向中间靠拢
    除了插入元素参数外，还需要判断是栈1 还是栈2 的栈号参数 stackNum
```



#### 优缺点

*   缺点：
    *   事先必须先确定数组存储空间大小，万一不够用，就需要进行扩容
    *   浪费空间
*   优点
    *   效率高

## 链栈

```java
/*
     a1               a2                a3
 [data,*Next] --> [data,*Next] --> [data,*Next] --> null
栈底						           栈顶 top    --->
*/


介绍
    // 对增删做出规定的单链表
    单链表， 不需要头结点
满栈
    基本不存在满栈的情况，除非内存没有空间
空栈
    链表为空的状态： 即 top = null
```

## 应用

*   不需要关注数组、链表的下标等细节问题，
*   简化程序设计的问题，划分不同关注层次，使思考范围缩小，更加聚焦于我们要解决的核心问题

### 1. 递归

*   使用栈解决迭代问题

### 2.四则运算

*   后缀（逆波兰）表示法定义

    *   不需要括号的后缀表达法，称为逆波兰表示
    *   所有的符号都要在运算数字的后面出现
    *   从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果

*   中缀表达式转后缀表达式

    *   中缀表达式

        ```go
        9 + ( 3 -1 ) * 3 + 10 / 2
        ```

    *   后缀表达式

        ```go
        9 3 1 - 3 * + 10 2 / +
        ```

    *   规则

        *   从左到右遍历中值表达式中的数字和符号

        *   数字 ： 

            *   直接写出来就可
            *   输出，成为后缀表达式的一部分

        *   符号 ：

            *   判断其和栈顶符号的优先级
            *   栈用来进出运算的符号

            *   当前符号是右括号或者低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止



## 操作

### 添加 -- 压栈

```java
含义
    向栈中添加元素 	
别称
    进栈、压栈、入栈（push）
 过程
```

### 删除 -- 弹栈

```java
含义
    从栈中提取出指定元素	
别称
    出栈、弹栈、入栈（push
```











## 进出栈变化顺序

*   最先进栈的元素不一定最先出栈，只要保证是栈顶出即可

    ```go
     1 2 3 依次进栈的情况
    1. 1 2 3 进栈，3 2 1 出栈
    2.1 进 1 出。2 进 2 出。 3 进 3 出
    
    ```

*   复杂度

    ```go
    进栈 、 出栈,没有循环操作， 时间复杂度都是 O(1)
    ```

    

































































