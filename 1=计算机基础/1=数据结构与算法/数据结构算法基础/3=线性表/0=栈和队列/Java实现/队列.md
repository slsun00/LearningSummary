

## api

```java
1. 建立缺省长度的队列
2. 建立长度为 size 的队列
3. 清空队列， 释放内存
4. 入队
5. 出队
6. 读取队头元素， 但是不删除
7. 判空
8. 判满
9. 清空
10 打印
11 获取元素个数    
```



## 循环队列



### 结构

```java
package com.it.puke.queue;



class Que {
    private int rear;
    private int font;
    private int maxSize;
    private int[] arr;

    public Que(int maxSize) {
        this.rear = -1;  // 队尾， 这个是包含所指向位置的元素
        // font 指向的位置时空位置
        this.font =-1;  // 对头，这个是不包含所指向的位置的元素
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
    }






    public void show(){
        if (isEmpty()) {
            System.out.println("空对立，不用返回");
        }
        for (int i= font+1; font!=rear; i++){
            System.out.println(arr[i]);
        }
    }

    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("空对类无数据");
        }
        return arr[font+1];
    }
}

```

### 入队

```java
public void enQueue(int data) {
    if (isFull()) {
		throw new RuntimeException("队列已满");
    }
    
    // 循环逻辑， 出现数字比数组长度还大的, 
    // 循环方式的 rear++
    rear = (rear + 1 ) % maxSize;
    arr[rear] = data;    
}
```

### 出队

```java
public void deQueue(int data) {
	if (isEmpty()){
        throw new RuntimeException("队列为空，无法删除");
    }
    
    // 指针下标循环
    // font 位置时没有元素的，即先进行游标移动， 后进行删除
    front = (front + 1) % maxSize;
}    
```

### 查

```java
// 读取队头元素
public int getQueue() {
	if (isEmpty()) {
        throw new RuntimeException("队列为空，没有对头元素");
    }
    int i = (font+1) % maxSize;
    return arr[i];
}

// 判空
public boolean isEmpty() {
	if (font == rear) {
        return true;
    }
    return false;
}

// 判满
public boolean isFull() {
	 font = (font+1) % maxSize;
   	 rear = (rear+1) % maxSize;
     int result = Math.abs(font, rear);
    if (result == 1) {
        return true;
    }
    return false;

}
```





## 链队列

### 结构

```java
public class Node {
    int data;
    Node next;
    public Node(int data){
        this.data = data;
        this.next = null;
    }
}
public class Queue {
    Node head;
    public Queue() {
        this.head = null;
    }
}
```



### 入队

```java
public void enQueue(int data) {
    Node curNode = this.head;
    while (curNode.next != null) {
        curNode = curNode.next;
    }
    curNode.next = new Node(data);
}
```



### 出队

```java
public boolean deQueue() {
    if (this.isEmpty()){
        return false;
    } else {
        this.head = this.head.next;
    } 
}
```

### 查

```java
public boolean isEmpty() {
	if (this.head == null) {
        return true;
    }
    return false
}    
```



