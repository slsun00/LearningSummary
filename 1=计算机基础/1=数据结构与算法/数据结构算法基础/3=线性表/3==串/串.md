

*   不同语言的字符串
## 1.介绍

*   串
    *   就是字符串
    *   由 0 个或者多个字符组成的有限序列
*   下标
    *   开始 ： 从 0 开始
        *   有些在这个位置存储字符串的长度，有些也会将长度存储在数组最后一个位置
    *   结尾 ：
        *   有些 是在串值后面加一个 \0 结尾（还是占一个空间，还不如存成长度呢）
*   空串
    *   null string
    *   零个字符的串
*   空格串
    *   只包含空格的串
    *   空格串的内容有长度，而且不止一个空格
*   长度
    *   串中字符的数目
*   子串
    *   串中任意个数的连续字符组成的字序列称.为该串的子串
    *   子串在主串中的位置
        *   子串首个字符在主串的位置
*   主串
    *   包含子串的串

## 2.比较

*   看字符串比较

## 3.存储结构

*   与线性表相同
*   串值的存储空间可在程序执行过程中动态分配

### 1. 顺序存储

*   静态数组
*   定长的数组存储 ，  需结合目标字符串的长度，预先申请足够大的内存空间。 
*   用一组地址连续的存储单元来存储串中的字符序列的
*   根据预定义的大小，为每个串变量分配一个定长的存储区

### 2.  堆分配存储

*   动态数组
*   动态数组的长度是可变的
*   堆区的内存空间需要程序员手动使用 malloc 函数申请，并且在不用后要手动通过 free 函数将其释放。 
    *    使用 malloc 函数最多的场景是给数组分配空间，这类数组称为动态数组。 

### 3. 链式存储

*   介绍
    *   与线性表相似
    *   块链存储
*   节点
    *   一个节点存放一个字符，会造成很大的空间浪费 ，一个节点可存放多个字符，
        *   一个节点存放多少个字符，直接影响串的影响效率，根据实际情况处理
    *   最后一个节点未被占满时，可以用 # 或者其他字符补全
*   存储数据个数
    *    串的长度和存储空间的大小 
        *    若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；
        *   如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑； 
    *    程序实现的功能 
        *    实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各节点存储数据的数量；反之，就需要再结合其他因素。 
    *    在实际场景中，还需结合实现环境综合分析。 

#### 缺点

*   串的链式存储结构除了在串链接操作时方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好


## 4. 操作

### 查询

#### 长度

```java
表示字符串的长度
    1. 用一个变量来表示串的实际长度
    2. 在串结尾存储一个在串中不会存在的特殊符号作为终结符，表示串的结尾
    	c \0
    3. 在数组的第 0 号单元存储串的长度，从 1 号单元开始存放串值
    	[ 9 | a | b | c | d | 空闲 ]
    	  0   1   2   3   4   ...
```



## 5.模式匹配算法

### 模式匹配

```java
在目标(字符串)中寻找一个给定的模式(也是字符串)，返回目标和模式匹配的第一个子串的首字符位置 
```

### 1. BF算法

```java
介绍
    暴力算法 （Brute Force）
    普通模式匹配算法
过程
  将目标串S的第一个字符与模式串T的第一个字符进行匹配， 
    相等： 则继续比较S的第二个字符和 T的第二个字符
    不相等，则比较S的第二个字符和T的第一个字符，依次比较下去
    直到得出最后的匹配结果 
    
分析过程
    s1 = 'bbabdabc'   s2 = 'abc'

// 第1次    
    s1:  b b a b d a b c
	s2:  a b c 
          x
1. s1[0] != s2[0]
        
// 第2次： 将 s2 向右移动一次，进行对比        
    s1: b b a b d a b c
	s2:   a b c  
           x
2. s1[1] != s2[0] 
        
// 第3次： 将 s2 向右移动一次，进行对比        
    s1: b b a b d a b c
	s2:     a b c 
        	 = = x
3. s1[2] == s2[0]     
   s1[3] == s2[1] 
   s1[4] != s2[2]  
	// 回溯 4 -2 + 1 = 3

// 第4次： 将 s2 向右移动一次，进行对比   
        0 1 2 3 4 
    s1: b b a b d a b c
	s2:       a b c 
        	  x
4. s1[3] != s2[0]
        
// 第5次： 将 s2 向右移动一次，进行对比    
        0 1 2 3 4 5 6   // 长表回溯 3 - 0 + 1 = 4        
    s1: b b a b d a b c
	s2:         a b c 
        		x
5. s1[4] != s2[0] 
        
// 第6次： 将 s2 向右移动一次，进行对比   
        0 1 2 3 4 5 6 7        
    s1: b b a b d a b c
	s2:           a b c  
        		  = = =
6. s1[5] == s2[0]    
   s1[6] == s2[1]
   s1[7] == s2[2]
	匹配成功  
```

### 2.KMP

*    Knuth-Morris-Pratt 算法 
*    匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的



#### 术语

```java
前缀
    指除了最后一个字符以外，一个字符串的全部头部组合
    abc: {a, ab}
后缀
    指除了第一个字符以外，一个字符串的全部尾部组合
    abc: {c, bc}
最大公共前后缀
    一个字符：其前缀、后缀集合，长度最大的交集子元素
Next[]数组
    存放最大公共前后缀的长度值
    值定义为K值，即Next[]数组存储一组k值
匹配串
    源字符串： a b a b a b a a b g g a b a b a a a
    需要查找： a b a b a a a   // 模式
    不匹配位置 = = = = = x
    匹配串    a b a b a 
// 例子
    a
    	 前缀为：无
		后缀为： 无
		最大公共前后缀： 无
		最大公共前后缀长度为 0
         next[k] : 0
    ababaa
    	前缀为： {a, ab, aba, abab, ababa}
		后缀为： {a, aa, baa, abaa, babaa}
		最大公共前后缀： {a}
		最大公共前后缀长度为 1
         next[k] : 1
            
    ababa
    	前缀为： {a, ab, aba, abab}
		后缀为： {a, ba, aba, baba}
		最大公共前后缀： {aba}
		最大公共前后缀长度为 3
         next[k] : 3
         
```

#### 朴素算法 -- 流程

```java
匹配子串
    不存在： 按照 BF 算法移动(就是向后移动一位)
    存在：判断是否存在最长公共前缀
    	// 跳过已匹配的子串进行匹配
    	存在： 公共前缀移动到公共后缀的位置(覆盖住)
    	不存在： 将第一个位置的字符移动到不匹配的位置
//=====================================

源字符串：a b a b a b a a b g g a b a b a a a
需要查找： a b a b a a a    // 模式

// 第一次比较    
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...   
源字符串s1：  a b a b a b a a b g g a b a b a a a
需要查找s2：  a b a b a a a   // 模式
不匹配位置    = = = = = x
匹配的子串 a b a b a 
    子串最长公共前后缀 ： a b a
    移动到：公共前缀移动到公共后缀的位置(覆盖住)
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：     a b a b a a a    // 模式
匹配过程
    1. s1[0] == s2[0]  s1[1] == s2[1] ...  s1[5] == s2[5]  s1[6] != s2[6]
    2. 将 s2[0] 移动到 s2[3] 的位置
    3. 下一次对比： 直接从 s2[4] 的位置和 s1 对应的位置对比
    
// 第二次比较   
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：        a b a b a a a   // 模式
不匹配位置    	       = = = x
匹配的子串 a b a b a a
    子串最长公共前后缀 ： a
    移动：公共前缀移动到公共后缀的位置(覆盖住)
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：               a b a b a a a    // 模式 
匹配过程
    1. s1[5] == s2[4]  s1[6] == s2[5] ...  s1[7] == s2[6]  s1[8] != s2[7]
    2. 将 s2[0] 移动到 s2[7] 的位置
    3. 下一次对比： 直接从 s2[1] 的位置和 s1[8] 对应的位置对比    
    
// 第三次比较   
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                  a b a b a a a    // 模式  
不匹配位置                    = x
匹配的子串 a b  
    子串最长公共前后缀 ： 无
    移动： 直接将模板字符首字母移动到不匹配的位置
        源字符串：a b a b a b a a b g g a b a b a a a
        需要查找：                  a b a b a a a    // 模式 
匹配过程
    1. s1[8] == s2[1]  s1[9] != s2[2]
    2. 将 s2[0] 移动到 s2[2] 的位置: 
    3. 下一次对比： 直接从 s2[0] 的位置和 s1[9]对应的位置对比        
    
// 第四次比较    
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                      a b a b a a a    // 模式  
不匹配位置                      x
匹配的子串 无   
    子串最长公共前后缀 ： 无
    移动：  直接移动到不匹配位置下一个位置
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：                     a b a b a a a    // 模式   
匹配过程
    1. s1[9] != s2[0]
    2. 将 s2[0] 移动到 s2[1] 的位置: 直接后移一位
    3. 下一次对比： 直接从 s2[0] 的位置和 s1[10]对应的位置对比    
    
// 第四次比较 
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...        
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                        a b a b a a a    // 模式  
不匹配位置                        x
匹配的子串 无   
    子串最长公共前后缀 ： 无
    移动：  直接移动到不匹配位置下一个位置
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：                       a b a b a a a    // 模式 
匹配过程
    1. s1[10] != s2[0]
    2. 将 s2[0] 移动到 s2[1] 的位置: 直接后移一位
    3. 下一次对比： 直接从 s2[0] 的位置和 s1[11]对应的位置对比      
    
// 第五次比较 
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                          a b a b a a a   // 模式 
    							= = = = = = =
不匹配位置  无
匹配的子串： 完全匹配    
    
```



#### next[] -- 前缀表

```java
0 1 2 3 4 5 6 7 8 9 10 11 12
  a b a b a a a b a b  a  a
    
// 模式分析
    a b a b a a a
// 前缀表
    前缀子串	最长公共前后缀缀    长度
    a			    无            0
    a b			    无            0
    a b a			a		     1
    a b a b			a b           2
    a b a b a 		a b a         3
    a b a b a a      a		      1
// 最长公共前缀排列起来
    模板字符串             	 a  b  a  b  a  a  a
    最长公共前后缀长度     	  0  0  1  2  3  1  -
    左边字符最长公共前后缀长度  -   0  0  1  2  3  1
    优化方便判断   		    -1  0  0  1  2  3  1   
    // 需要判断第一个字母，前面没有，就设置为 -1 ，表示不存在
    模板字符串             	 a  b  a  b  a  a  a
    最长公共前后缀长度     	  0  0  1  2  3  1  -
    优化判断   				-1  0  0  1  2  3  1 
```

#### next[]  -- 流程解释一

```java

```



#### next[] -- 流程解释二

```java
源字符串：a b a b a b a a b g g a b a b a a a
需要查找： a b a b a a a    // 模式

// ==== next ===    
    模板字符串             	 a  b  a  b  a  a  a
    优化判断   				-1  0  0  1  2  3  1 
    下标		    		   0  1  2  3  4  5  6 
// ===      ===
    
// 第一次比较    
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...   
源字符串s1：  a b a b a b a a b g g a b a b a a a
需要查找s2：  a b a b a a a   // 模式
不匹配位置    = = = = = x
不匹配字符的 next.value = 3
    	// ==== next ===    
            模板字符串             	 a  b  a  b  a  a  a
            优化next 				  -1  0  0  1  2  3  1 
            下标		    		   0  1  2  3  4  5  6 
        // ===      ===
    	// 所以将 3 号位置的 b 拉倒此位置
    					  x
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：     a b a b a a a    // 模式
匹配过程
    1. s1[0] == s2[0]  s1[1] == s2[1] ...  s1[5] == s2[5]  s1[6] != s2[6]
	2. s2[5] 的 next.value = 3 
    3. 把 s2[3] 位置的字符串拉到此处, 往后进行比较
    
// 第二次比较   
字符串下标s1: 0 1 2 3 4 x 6 7 8 9 ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：        a b a b a a a   // 模式
不匹配位置    	       = = = x
不匹配字符的 next.value = 1
    移动：// 所以将 1 号位置的 b 拉倒此位置
    						   x
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：               a b a b a a a    // 模式 
匹配过程
    1. s1[5] == s2[4]  s1[6] == s2[5] ...  s1[7] == s2[6]  s1[8] != s2[7]

    
// 第三次比较   
字符串下标s1: 0 1 2 3 4 5 6 7 8 x ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                  a b a b a a a    // 模式  
不匹配位置                    = x
不匹配字符的 next.value = 0
    移动： // 所以将 0 号位置的 a 拉倒此位置
    							x
        源字符串：a b a b a b a a b g g a b a b a a a
        需要查找：                  a b a b a a a    // 模式 
匹配过程
    1. s1[8] == s2[1]  s1[9] != s2[2]
  
    
// 第四次比较    
字符串下标s1: 0 1 2 3 4 5 6 7 8 x ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                      a b a b a a a    // 模式  
不匹配位置                      x
不匹配字符的 next.value = -1
    移动： // 所以右移一位
    							 x 
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：                     a b a b a a a    // 模式   
匹配过程
    1. s1[9] != s2[0]
 
    
// 第四次比较 
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 x ...        
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                        a b a b a a a    // 模式  
不匹配位置                        x
不匹配字符的 next.value = -1
    移动： // 所以右移一位
    							   x
        源字符串： a b a b a b a a b g g a b a b a a a
        需要查找：                       a b a b a a a    // 模式 
匹配过程
    1. s1[10] != s2[0]
    2. 将 s2[0] 移动到 s2[1] 的位置: 直接后移一位
    3. 下一次对比： 直接从 s2[0] 的位置和 s1[11]对应的位置对比      
    
// 第五次比较 
字符串下标s1: 0 1 2 3 4 5 6 7 8 9 ...      
源字符串：    a b a b a b a a b g g a b a b a a a
需要查找：                          a b a b a a a   // 模式      
不匹配位置  无
匹配的子串： 完全匹配    
    
```

#### 原因 --  位置跳转原理

```java
```

## java实现

### BF算法

### KMP算法

#### 需要总结

```java
https://blog.csdn.net/GreatXiang888/article/details/104724556
https://www.cnblogs.com/zzuuoo666/p/9028287.html
```

