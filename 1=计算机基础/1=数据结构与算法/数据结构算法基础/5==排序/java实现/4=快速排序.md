## 介绍

```java
介绍
    // 一般将递归程序改成非递归首先想到的就是使用栈，因为递归本身就是一个压栈的过程
	主要是在划分子区间
    递的时候： 
    	// 其实在根据大小在划分区间的时候，就是在排序
    	用来划分子区间， 在划分区间的时候完成大小的排序
    归的时候： 
    	将划分好的区间进行合并
    顺序问题
    	递归顺序的问题，其实这个是很重的部分，脑子里虚构出来这个过程，才能更好理解递归
   		// 压栈弹栈分析
```



## 普通递归



### 前后指针 - -分治+递归 

```java
public class Quick{
   public void quickSort(int[] arr, int start, int end) {

        // 递归跳出条件: 可以跳出单个元素和空元素的
        if (start == end) {
            return;
        }


        int tempIndex = start; // 基准值
        int temp = arr[start];  // 基准值下标
       
       // 递归传入
        int newStart = start;
        int newEnd = end;

        // 在比较过程中，是需要不停来回切换，碰到一个就需要返回另一端
        while (start < end) {

            // 右指针移动
            // 加上 start < end 是防止自减越界
            while (start < end) {  // 有指针防止越界
                if (temp > arr[end]) {
                    // arr[temp] > arr[end] 进行交换, 记录下新的
                    swap(arr[tempIndex], arr[end]);
                    tempIndex = end;
                    start++;  // 每次跳回,都是和跳回位置的下一个位置比较
                    break; // 碰到第一个符合条件的就跳出，回到左指针移动
                } else {   // temp <= arr[end]
                    end--;
                }
            }

            // 左指针移动
            while (start < end) {
                if (temp < arr[start]) {
                    swap(arr[tempIndex], arr[start]);
                    tempIndex = start;
                    end--; // 每次跳回,都是和跳回位置的下一个位置比较
                    break;
                } else {
                    start++;
                }
            }
        }

        // 最后 tempIndex start end 都是在一个位置
        // 递归处理左边
        quickSort(arr,oldStart, tempIndex-1);
        // 递归处理右边
        quickSort(arr,tempIndex+1, oldEnd);

    }

    public void swap(int a, int b) {
        if (a > b) {
            int temp = a;
            a = b;
            b= temp;
        }
    }
}    
```

### 挖坑 - -分治+递归 

```java
介绍
    挖坑和左右指针思路是一样的， 只不过思路更加清晰
    不用进行交换，相当于 选择排序
public class Quick{
    
    
    
   public int quickSort(int[] arr, int start, int end) {

        // 递归跳出条件: 可以跳出单个元素和空元素的
        if (start == end) {
            return;
        }


        int tempIndex = start; // 基准值下标, 坑的下标
        int temp = arr[start];  // 基准值， 坑值
       
       // 递归传入
        int newStart = start;
        int newEnd = end;

        // 在比较过程中，是需要不停来回切换，碰到一个就需要返回另一端
        while (start < end) {

            // 右指针移动
            // 加上 start < end 是防止自减越界
            while (start < end) {  // 有指针防止越界
                if (temp > arr[end]) {
                    // 将  arr[end] 填到 arr[tempIndex] 中，s[end]就形成了一个新的坑
				  arr[tempIndex] = arr[end]; 
                    tempIndex = end;
                    start++;  // 每次跳回,都是和跳回位置的下一个位置比较
                    break; // 碰到第一个符合条件的就跳出，回到左指针移动
                } else {   // temp <= arr[end]
                    end--;
                }
            }

            // 左指针移动
            while (start < end) {
                if (temp < arr[start]) {
                   // 将  arr[end] 填到 arr[tempIndex] 中，s[end]就形成了一个新的坑
				  arr[tempIndex] = arr[start]; 
                    tempIndex = start;
                    end--; // 每次跳回,都是和跳回位置的下一个位置比较
                    break;
                } else {
                    start++;
                }
            }
        }
       
        // 最后 tempIndex start end 都是在一个位置
        // 把坑填上
       arr[tempIndex] = temp;

          
        // 递归处理左边
        quickSort(arr,newStart, tempIndex-1);
        // 递归处理右边
        quickSort(arr,tempIndex+1, newEnd);
       
    }

}    
```



## 普通压栈

```java
介绍
    将递归函数的本质就是压栈和弹栈，所以对于递归的函数是可以都改写为栈操作
改写方法
    1. 递归函数有参数的， 需要在压栈之
    
    
    
    
//  未总结
void QuickSortNotR(int* array,int left,int right)
{
	assert(array);
	stack<int> s;
	s.push(left);
	s.push(right);//后入的right，所以要先拿right
	while(!s.empty)//栈不为空
	{
		int right = s.top();
		s.pop();
		int left = s.top();
		s.pop();
		
		int index = PartSort(array,left,right);
		if((index - 1) > left)//左子序列
		{
			s.push(left);
			s.push(index - 1);
		}
		if((index + 1) < right)//右子序列
		{
			s.push(index + 1);
			s.push(right);
		}
	}
}
————————————————
版权声明：本文为CSDN博主「清枫若待佳人醉」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_36528114/article/details/78667034    
```

## 优化

### 三数取中