## 5.  自己思路

*   实例

    ```go
    a = [ 30 , 87 , 20 , 71 , 43 ]
    // 手动排序  a = [ 20 , 39 , 43 , 71 , 87 ]
    ```

* 第一个位置

    *   当成排好序的数字

    *   此位置前面没有数据，是不用进入冒泡循环的

    *   即默认第一个默认最小的数

        ```go
        0 a = [ 30 , 87 , 20 , 71 , 43 ]
        ```


* 第二个位置

    * 此位置的数字，与前面排过序的数据（第一个数字）进行向前冒泡排序
    * 将该位置数据往前冒，冒到比该数据小的数，就可以通知冒泡

    ```go
    此位置数据 80
    30 80 进行冒泡 ：不用交换
    ```

* 第三个位置

    *   此位置数字，与前面排过序的数据进行冒泡排序
    *   将该位置数据往前冒，冒到比该数据小的数，就可以通知冒泡

    ```go
    此位置数据 20
    30 80 20 进行冒泡 ： 20 ， 30 ， 80
    ```

* 其他位置

    *   同前面位置
    *   最后一个位置的数据也要往前面冒

## 5.demo

### 1.golang

```go
package main

import "fmt"

func InsertionSort(a []int) {

	// 空数组就不讨论了

	length := len(a)

	// i = 0 的位置的数据，是默认的最小数值
	// i:=1 从下标为 1 的位置开始，与前面的数据进行对标
	// i<length  i 位置的数据都要和前面的数据进行比较，所以要取到最后一个元素即 i = length-1
	// i 位置移动
	for i := 1; i < length; i++ {

		// j := i  j 下标位置的数据要和前面的有序序列进行冒泡排序
		// j > 0 ,j最坏的情况，j 位置的数据要对比到第一个数据对比，即j-1 = 0 ，所以 j 最坏取 j=1
		//  i-- 移动一个位置
		for j := i; j > 0; j-- { // 进行向前冒泡

			if a[j-1] > a[j] { // 前一个位置数据大于后一个位置的数据，就进行数据对换
				a[j-1], a[j] = a[j], a[j-1]
			}
		}
	}
}

func main() {
	var arr = []int{39, 62, 71, 87, 43, 29}
	InsertionSort(arr)
	fmt.Println(arr) // [29 39 43 62 71 87]
}
=======================================================================
// 冒泡优化
// 前面的已经是有序的序列了，只要不进行数据交换，就说明数据就差在了正确的位置，
for i ：= range a {
	for j := i; j > 0; j-- { // 进行向前冒泡
		flag := 0
		if a[j-1] > a[j] { // 前一个位置数据大于后一个位置的数据，就进行数据对换
		a[j-1], a[j] = a[j], a[j-1]
		flag ++
    	}
        if flag == 0 {
            break
        }
	}
}		


```





