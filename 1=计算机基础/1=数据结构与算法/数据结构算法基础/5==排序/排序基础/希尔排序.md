## 介绍

*    Shell's Sort 
*    百度百科 ： [希尔排序](https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)
*    本质
     *   插入排序的一种
*    别称
     *    缩小增量排序”（Diminishing Increment Sort） 

## 使用

*   较大规模数据并且无序
*   部分有序，局部有序

## 方法思路

*   方法

    ```go
    // 感觉就是有增量的冒泡排序
    通过增量，将数据主段进行分割，组成一个一个子列
    对子列进行插入排序
    随着增量逐渐减少，每列包含的关键词越来越多，当增量减至1时，整个文件恰被分成一列，算法便终止。
    	增量最终减少到 1 ，注意是 1
    
    // 三层循环 : 第一次写的时候，就少写了一层，导致在哪里看了半天，一定要注意
    第一层 ： 控制gap
    第二层 ： 控制向后取元素
    第三层 ： 控制向前对比
    ```

*   排序例子

    ```go
    a = [ 25 61 72 59 95 27 78 79 92 75 49 51 22 46 7 45 73 ]
    
    // 以增量 step = 5 分割 
    25 61 72 59 95 
    27 78 79 92 75 
    49 51 22 46 7 
    45 73
    
    1. 每一列都是一个子序列，每列进行插入排列
    	比如第 0 列： 25 27 49 45 是这一列数进行插入排序
    2. 比较过程
    	27 78 79 92 75 49 51 22 46 7  45 73
    	25 61 72 59 95 27 78 79 92 75 49 51
    	其实你就会发现，比较过程还是一个挨着一个有步长的冒泡
    		元素一个一个往后找元素
    		找到的元素通过步长找到自己相应列的元素; 比如 49 找 27 ，27 找 25
    
    
    // 将每一列的数据分别进行排序后得到
    25 51 22 46 7
    27 61 72 59 75
    45 73 79 92 95
    49 78
    // 此时数组变成
    25 51 22 46 7 27 61 72 59 75 45 73 79 92 95 49 78
    ```

*   以步长为 step = 3

    ```go
    25 51 22
    46 7 27 
    61 72 59 
    75 45 73 
    79 92 95 
    49 78
    
    1. 再对每一列的数据进行插入排序
    	比如第 0 行 ：25 46 61 75 79 49 进行插入排序
    
    25	7	22
    46	45	27
    49	51	59
    61	72	73
    75	78	95
    79	92
    // 此时数据变成
    25	7	22	46	45	27	49	51	59	61	72	73	75	78	95	79	92
    ```

*   以步长为 1

    ```go
    此时就是简单的插入排序
    ```

*   索引规律

    ```go
    0		1		2		3		...		gap-1
    gap 	gap+1	gap+2	gap+3	  ...	  gap + (gap-1)
    2gap	2gap+1	2gap+2	2gap+3	  ...	   2gap + (gap-1)
    
    从第二行的 [gap] 位置开始同步，依次向前面遍历，
    当前元素可前面相差 grap 的元素进行对比，，这样可以做到每个元素都和自己前面的元素进行一次比较
    ```



## 步长

*   使用有一定的讲究

    ```go
    最开始 
    	d= n/2; d>=1; d=d/2
    ```


