## 介绍

*   Merge Sort 
*   百度百科： [归并排序](https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)

## 思路

*    先递归分解数组，再合并数组。 

```java
拆分
    
注意
	A[first … mid] 和 A[mid+1 … last]前面那个不包括 mid
    // 正常截取，在切片个数是奇数的时候，会导致最左边的切片会出现空的情况
    mid = len(a) / 2
    // 确定左边的一定是偶数个数据元素
    mid = len(a) / 2 + len(a) % 2
    
    
    
    
               ╭﹣﹣﹣﹣﹣ 8 4 5 7 1 3 6 2 ﹣﹣﹣﹣﹣╮                    ﹣﹣﹣﹣ 
        ╭﹣﹣ 8 4 5 7 ﹣﹣╮                ╭﹣﹣ 1 3 6 2 ﹣﹣╮           分 h=1og2n = 1ogz8=3
    ╭﹣ 8 4 ﹣╮      ╭﹣ 5 7 ﹣╮       ╭﹣ 1 3 ﹣╮       ╭﹣ 6 2 ﹣╮         |
    8 	     4       5	      7       1 	   3       6 	    2      ﹣﹣﹣﹣
    ╰- 4 8 --╯       ╰- 5 7 --╯       ╰- 1 3 --╯        ╰- 2 6 --╯      治  h=1og2n = 1ogz8=3
         ╰--- 4 5 7 8 ---╯                 ╰--- 1 2 3 6 ---╯               |
                 ╰--------  1 2 3 4 5 6 7 8 ---------╯ 				   ﹣﹣﹣﹣
    
```

*    拆分
     *    进行的排序序列分为左右两个部分，
          *   进行排序的序列
              *   起始元素下标为first，
              *   最后一个元素的下标为last，
              *   那么左右两部分之间的临界点下标mid=(first+last)/2，
              *   这两部分分别是 A[first … mid] 和 A[mid+1 … last]
     *    两部分序列继续按照上面继续进行划分，直到划分的区间长度为1 
*    合并
     *    执行归并排序 
     *    对所分的n个子序列进行两两合并，得到n/2或n/2+l个含有两个元素的子序列，再对得到的子序列进行合并，直至得到一个长度为n的有序序列为止 
*    



## 性能分析

### 稳定性

*   稳定
*   归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。

### 时间复杂度

* 

## 用途

*   一般用于对总体无序，但是各子项相对有序的数列
*   速度仅次于快速排序
* 代价是需要额外的内存空间。

    
