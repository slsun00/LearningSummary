## 1. 认识

*   英语：Insertion Sort

## 代码思路

```java
介绍
    通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
    插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
    
 个人感觉就是： 
    从后向前的冒泡排序 , 冒泡直接两个进行比较，插入是用一个中间两存储过度下    
    
例子
    a = [ 39 , 87 , 20 , 71 , 43 ]
    手动排序 
    	a = [ 20 , 39 , 43 , 71 , 87 ]
    
    // 假设数组左边的就是排序好的序列， ！！！！！默认是有序序列的初始值
    a = [ 39 || 87 , 20 , 71 , 43 ]    // 格式 有序的序列 || 无序的序列
    
    // temp = 87
    87 > 39 ,不动  
    	结果 ： a = [ 39 ， 87 || 20 , 71 , 43 ]
    // temp = 20
    20 < 87 , 所以 87 往后移一位
    20 < 39 , 所以 39 往后移一位
    	结果 ： a = [ 20 ， 39 ， 87 || 71 , 43 ]
    // temp = 71
    71 < 87 , 所以 87 往后移一位
	71 > 39 , 所以 71 插入原 87 的位置
       	结果 ： a = [ 20 ， 39 ， 71 ， 87 || 43 ]
    
    // temp = 43
    43 < 87 , 所以 87 往后移一位
    43 < 71 , 所以 71 往后移一位
    43 > 39 , 所以 43 插入原 71 的位置
	     	结果 ： a = [ 20 ， 39 , 43 , 71 ， 87 ]
```



## 3. 使用场景

* 小规模数据
* 数据基本有序，数据有序程度越高，越高效
* 大量的移动和比较，会导致算法效率低下



## 8.性能分析

### 时间复杂度

*   最好情况
    *   比较次数  n - 1        移动次数 ：2（n-1）
    *   时间复杂度  $O(n)$
*   最坏情况（逆序或者反序）
    *   比较 n-1 次				移动 n * n 次，即：每次都要比较都要交换
    *   时间复杂度 $O(n^2)$

### 空间复杂度

*   需要一个记录的辅助空间

### 4.稳定性

### 5.问题

*   如何构造初始有序序列
*   如何查找待插入记录的位置



## 扩展

* 其实无序列表中的元素插入到有序列表中，可以分成两步来分析
    * 找到要插入的位置 ： 二分等等
    * 插入该元素