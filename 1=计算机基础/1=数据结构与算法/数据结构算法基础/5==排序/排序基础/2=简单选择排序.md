

## 1.认识

*   （Selection sort）
*   百度百科 ： [选择排序](https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)

## 2. 运行分析

```go
1.  未排序序列中找到最小元素，存放到排序序列的起始位置，
2.  剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。
3.  以此类推，直到所有元素均排序完毕。
   对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上 

a = [ 39   62  71  87  43  29 ]

min 记录最小值下标
//----------------------
min == 0
    39 与 62 71 87 43 相比都是 39 小 ，所以 min 不变
    39 > 29  所以 min == 5
	结束  所以 a[0] <--> a[min]  :a = [ 29   62  71  87  43  39 ]
min == 1
	62 < 71 , 87 ,min 不变
	62 > 43 , min == 4
	43 < 39 , min == 5
	结束 所以 所以 a[1] <--> a[min]  :a = [ 29 39  71  87  43  62 ]
min == 2
	71 < 87 ,min 不变
	71 > 43 , min == 4
	43 < 62 , min == 4
	结束 所以 所以 a[1] <--> a[min]  :a = [ 29 39  43  87  71  62 ]
min == 3
	87 > 71 ,min == 4   a[min] = 71
	71 > 62 , min == 5  a[min] = 62
	结束 所以 所以 a[3] <--> a[min]  :a = [ 29 39  43  62  71  67 ]

min == 4
	71 < 87 , min 不变
	结束 :a = [ 29 39  43  62  71  87 ]
min == 5
	剩余一个元素就不用比较了，所以取到倒数第二个元素即可
```







## 2.性能分析

### 时间复杂度

```go
// 最好的情况 [1 2 3 4 5]
交换次数 0
比较次数 O（n^2）
// 最坏的情况 [5 4 3 2 1]
每次找到就要交换一下  交换次数 3（n-1）
比较次数 O（n^2）

时间复杂度 为  O（n^2） ，效率比选择排序还要好点儿

```

### 稳定性

*    不稳定的排序 
     *    序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了 

## 4.优点

*   是一种简单直观的排序算法。
*   无论什么数据进去都是 O(n²) 的时间复杂度 
*   唯一的好处可能就是不占用额外的内存空间  
*   如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。



## 5.使用场景

*    用到它的时候，数据规模越小越好。
*    在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种



