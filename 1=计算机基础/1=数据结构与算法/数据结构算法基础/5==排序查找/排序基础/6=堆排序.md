## 主要思想

*   每次构造一个堆 ，将堆的根结点（最大值或最小值）添加到有序列中

## 堆定义

* 是具有以下性质的近似完全二叉树

    ```go
    //就是以二叉树的角度去操作数据组
    小跟堆
    	// 小的 root
    	父节点 < 左右孩子  
    	1. 根结点是最小者
    	2. 较小结点靠近根结点，不是绝对
                    ╭﹣﹣﹣﹣﹣﹣﹣﹣ 13 ﹣﹣﹣﹣﹣﹣﹣╮ 
            ╭﹣﹣﹣ 38 ﹣﹣﹣╮                ╭﹣﹣﹣ 49 ﹣﹣﹣╮               
        ╭﹣ 48              76               65              69      
        97 	 
    
    
    大根堆
    	// 大的 root
    	父节点 > 左右孩子 
		1. 根结点是最大者
    	2. 较大结点靠近根结点，不是绝对
                   ╭﹣﹣﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮ 
            ╭﹣﹣﹣ 76 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
        ╭﹣ 48              49               13              65      
        38 	 
    
    
    
    重要的关系
        堆节点的关系
              k/2
             /
            k
           /  \
         2k    2k+1
    	最后一个非叶子节点的下标
    	解释
    		最后一个非叶子节点，其下面的结点下标，有一个正好是树的总长度(或者减一)
    		所以最后一个非叶子节点的下标为 heap.length / 2 - 1 (从 0 开始)
    
    
    https://zhuanlan.zhihu.com/p/104110241
    ```

## 业务流程

### 堆操作



#### 最堆调节 -- 下沉调节

```java
 介绍
     堆调节一般是在其左右子树都是最堆的情况下进行调节， 不是这种情况的话，调节起来比较麻烦
     
业务介绍
     当前节点 与 孩子结点中最大的值进行交换
     交换后：变化后位置结点是否是最堆，不是的话继续和其孩子结点交换比较
     结束：
     	1. 交换后的新节点没有左右孩子
     	2. 交换后的新节点所处的堆是最堆
     
     
业务流程
// 当前节点为 49 ，所在堆不是最堆，所以进行调节
// 49 左孩子存在： 49 < 97
// 49 右孩子存在 ： 49 < 69
// 总上： 49 < 69 < 97 , 所以取 97 和 49 进行换位     
     
     		╭﹣﹣﹣﹣﹣﹣﹣﹣ 49 ﹣﹣﹣﹣﹣﹣﹣╮ 
    ╭﹣﹣﹣ 97 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
╭﹣ 48              76               13              65      
38 	  

// 换位后     
// 49 左孩子存在： 49 > 48
// 49 右孩子存在 ： 49 < 76
// 总上： 48 < 49 < 76 , 所以取 76 和 49 进行换位 
     
     		╭﹣﹣﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮ 
    ╭﹣﹣﹣ 49 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
╭﹣ 48              76               13              65      
38 	
     
// 换位后     
// 49 左孩子不存在
// 49 右孩子不存在
// 再往下没有子节点，所以不用调节 
      		╭﹣﹣﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮ 
    ╭﹣﹣﹣ 76 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
╭﹣ 48              49               13              65      
38 	
         
    
```





#### 构建最堆 

```java
注意
    当你交换一个元素之后，跟参与交换的元素子堆也要重复确定是大根堆
    向上调整的时候，还需要向下调整
    // 上浮构建, 下沉调节

数组	49  38  65  97  76  13  69  48
下标   0   1   2   3   4   5   6   7
    
		   ╭﹣﹣﹣﹣﹣﹣﹣﹣ 49 ﹣﹣﹣﹣﹣﹣﹣╮ 
    ╭﹣﹣﹣ 38 ﹣﹣﹣╮                ╭﹣﹣﹣ 65 ﹣﹣﹣╮               
╭﹣ 97              76               13              69      
48 	  
    
    

1. 倒数第一个非叶子节点  97
    // 调整其所在堆为：有序堆， 
    ╭﹣ 97        ╭﹣ 97 
    48 	         48
2. 倒数第二个非叶子节点 65
        // 调整其所在堆为：有序堆， 
      ╭﹣﹣﹣ 65 ﹣﹣﹣╮         ╭﹣﹣﹣ 69 ﹣﹣﹣╮            
     13              69        13              65

3. 倒数第三个非叶子节点 38    
    // 1. 调整其所在的最小堆为大根堆：有序堆，
        ╭﹣﹣﹣ 38 ﹣﹣﹣╮        ╭﹣﹣﹣ 97 ﹣﹣﹣╮             
        97              76      38              76 
	// 2. 移动过的 38 所处的堆就变成无序堆，需要调整
         ╭﹣﹣﹣ 97 ﹣﹣﹣╮                ╭﹣﹣﹣ 97 ﹣﹣﹣╮         
     ╭﹣ 38              76           ╭﹣ 48              76
    48                               38
4. 倒数第四个非叶子节点 49
    // 调整其所在的最小堆为大根堆：有序堆，
    ╭﹣﹣﹣﹣﹣﹣ 49 ﹣﹣﹣﹣﹣﹣﹣╮           ╭﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮       
    97           			   69         49              			  69   
    // 移动过的 49 所在的堆也要调整为有序堆
               ╭﹣﹣﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮ 
        ╭﹣﹣﹣ 49 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
    ╭﹣ 48              76               13              65      
    38 	  
    
                ╭﹣﹣﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮ 
        ╭﹣﹣﹣ 76 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
    ╭﹣ 48              49               13              65      
    38 	  
    
    
    

```



### 排序

```java
步骤
    交换：将根结点与最后一个未排序的叶子结点进行交换
    调整：从根结点开始调整堆
    循环： 循环执行交换、调整
// 构造中已经构造出有一个大根堆
                ╭﹣﹣﹣﹣﹣﹣﹣﹣ 97 ﹣﹣﹣﹣﹣﹣﹣╮ 
        ╭﹣﹣﹣ 76 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
    ╭﹣ 48              49               13              65      
    38 	 
                    
// 将 根位置的元素 和 最后一个位置的元素对换位置
                ╭﹣﹣﹣﹣﹣﹣﹣﹣ 38 ﹣﹣﹣﹣﹣﹣﹣╮ 
        ╭﹣﹣﹣ 76 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮               
        48              49               13              65      
    97 	    
// 调整 0 位置元素所在的堆为大根堆
                ╭﹣﹣﹣﹣﹣﹣﹣﹣ 76 ﹣﹣﹣﹣﹣﹣﹣╮ 
        ╭﹣﹣﹣ 38 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮   
                    
// 调整移动后，38 所在的堆为大根堆

        ╭﹣﹣﹣ 38 ﹣﹣﹣╮                   ╭﹣﹣﹣ 49 ﹣﹣﹣╮
    ╭﹣ 48              49              ╭﹣ 48              38
// 调整完毕
                ╭﹣﹣﹣﹣﹣﹣﹣﹣ 76 ﹣﹣﹣﹣﹣﹣﹣╮ 
        ╭﹣﹣﹣ 49 ﹣﹣﹣╮                ╭﹣﹣﹣ 69 ﹣﹣﹣╮   
        48              38               13              65
    97      
//  76 49 69 48 38 13 65 97    

```

## java业务实现

### 堆操作

#### 堆调节

```java
// 介绍： 是从最堆开始进行开始调整的
/*
arr
parent： 此结点为：从这个节点往下调整
headMaxIndex : 局部调整的子堆的最大元素的叶子结点的最大下标值
*/
public void adjustMaxhead(int[] arr, int curNode, int headMaxIndex) {
    int largest = curNode;			// 父节点
    int left = 2 * curNode + 1;       // 左孩子
    int right = 2 * curNode + 2;      // 右孩子

    // 左孩子大，注意使用的是 largest ，比较之后，还可以进行 left 进行比较
    // 左孩子存在
    if ( left < headMaxIndex && arr[left] > arr[largest]) {
        largest = left;
    }

    // 右孩子存在
    if ( right < headMaxIndex && arr[right] > arr[largest]) {
        largest = right
    }
	
    // 出现当前节点不是最大值的，就直接跳过了，函数就执行结束了
    if (largest != curNode) {
        swap(int[], largest, curNode);
        adjustMaxHead(arr, largest, headMaxIndex)
    }
}

public void swap(int[] arr, int largest, int curNode) {
    int temp = arr[largest];
    arr[largest] = arr[parent];
    arr[parent] = temp;
}
```

#### 最堆构建

```java
	public int[] buildMaxHeap(int[] arr){
        // 数组的最大下标，数组长度判读
        int headMaxIndex = arr.length-1;       
        // 最后一个非叶子结点开始循环，下标为：（arr.length）/ 2 -1
        // 调整为有序堆
        for (int i = (arr.length)>>1-1; i>=0; i--) {
            adjustMaxHead(arr, i, headMaxIndex);
        }
    }
```



### 排序

```java
public class headSort {
    public void sort (int[] arr) {
        
        // 将数组构建为最堆结构的数组
	    arr = bulidMaxHeap(arr);
        
        // 利用堆进行排序
        for (int i = arr.length-1; i>0; i--) {
            swap(arr, 0, i);
            // arr 排序的数组。 i 当前节点， 从 最后一个非叶子结点开始调
            // adjustMaxHead(arr, i, headMaxIndex--);
            
            // 直接从 root 开始调整， 
            // 从底部调整, 底部都是完整的大根堆，没必要调， 还是到 root 才开始进行调节的
            adjustMaxHead(arr, 0, i--);
        }
        
    }
    

}



```

