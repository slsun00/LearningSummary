## 介绍

```java
基础
    属于分配式排序，
    又称"桶子法"(Bucket Sort或Bin Sort)，
    将要排序的元素分配到某些"桶"中，以达到排序的作用

    
    
分类
    最低位优先法: LSD（Least sgnificant digital）
    	LSD——从低位向高位排， 适用于位数小的数列
    最高位优先法: MSD（Most sgnificant digital）
		MSD——从高位向低位排， 位数多  
    


```

## 性能分析

## LSD - 运行逻辑

```java
介绍
    从低位开始将待排序的数按照这一位的值放到相应的编号为0~9的桶中。
    等到低位排完得到一个子序列，再将这个序列按照次低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。
    
待排序序列
    [3, 1, 18, 11, 28, 45, 23, 50, 300]
    
1.遍历序列找出最大的数(为的是确定最大的数是几位数) : 300 -- 是三位数
2. 根据数据规模，得出桶的个数： (55-11)/10 + 1 = 4
3. 按个位大小入桶 // 遍历入桶
    [ 0 ]  :  50, 300
    [ 1 ]  :  1, 11 
    [ 2 ]  : 
    [ 3 ]  : 3, 23, 
    [ 4 ]  : 
    [ 5 ]  : 45， 
    [ 6 ]  :   
    [ 7 ]  : 
    [ 8 ]  : 18, 28， 
    [ 9 ]  : 
4. 将桶中数据放回原数组:  [50, 300, 1, 11, 3, 23, 45, 18, 28, ]
   按十位大小入桶 // 遍历入桶
    [ 0 ]  :  300, 1, 3
    [ 1 ]  :  11, 18
    [ 2 ]  :  23, 28
    [ 3 ]  :  
    [ 4 ]  : 45
    [ 5 ]  : 50， 
    [ 6 ]  :   
    [ 7 ]  : 
    [ 8 ]  :  
    [ 9 ]  : 
5. 将桶中数据放回原数组:  [300, 1, 3， 11, 18, 23, 28, 45, 50]
      按百位大小入桶 // 遍历入桶
    [ 0 ]  :  1, 3， 11, 18, 23, 28, 45, 50
    [ 1 ]  :  
    [ 2 ]  :  
    [ 3 ]  :  300
    [ 4 ]  : 
    [ 5 ]  : 
    [ 6 ]  :   
    [ 7 ]  : 
    [ 8 ]  :  
    [ 9 ]  : 
6.将数据放回原数组中，
    // 已经到达最高位，所以这是最终的结果，不用再排序了
    [1, 3， 11, 18, 23, 28, 45, 50，300]
```



## java实现

```java
public class radix {
    public void sort(int[] arr) {
        
        int digitCount = 10;  // 0 -  9  十个数
        int maxSize = getMaxNumSize(arr);  // 数组中大的数字有多少为
        
        int[][] bucketArr = new int[digitCount][arr.length];  // 创建桶
        
        for(int i=0; i<maxSize; i++) { // 从最低位开始，到最高位
            
            // 用来记录每个对应桶[0-9]里面有多少个元素了
            int[] count = new int[digitCount];
            
            // 当前位进行排序
            for (int j=0; j<arr.length; j++) {              
                int bucket = (arr[j] / radix) /10; // 要放入的桶号
                bucketArr[bucket][count[bucket]++] = arr[j]; // 元素放入对应的桶
            }
            
            // 排序后恢复到原数组
            int index = 0;
            for (int j=0; j<digitCount; j++) {
                for (int k=0; k<cout[j]; k++) {
                    arr[index++] = bucketArr[j][k];
                }
            }
            
            // 下一位
            radix *= 10 ;
        }
    }
}
    
    

// 计算最大数的位数（按道理应该拆成两个函数，省事儿了，就拆成一个了）
public int getMaxNumSize(int[] arr) {
    int max = arr[0];
    for (int i=0; i<arr.length; i++) {
        max = math.max(max, arr[0]);
    }
    
    // 获取最大数的位数
    int count = 0;
    while (max != 0) {
        count++;
        max /= 10;
    }
    return count++;
}
```



