## 介绍

*   Merge Sort 
*   百度百科： [归并排序](https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)

## 思路

*    先递归分解数组，再合并数组。 

```java
拆分
    
注意
	A[first … mid] 和 A[mid+1 … last]前面那个不包括 mid
    // 正常截取，在切片个数是奇数的时候，会导致最左边的切片会出现空的情况
    mid = len(a) / 2
    // 确定左边的一定是偶数个数据元素
    mid = len(a) / 2 + len(a) % 2
    
    
    
    
               ╭﹣﹣﹣﹣﹣ 8 4 5 7 1 3 6 2 ﹣﹣﹣﹣﹣╮                    ﹣﹣﹣﹣ 
        ╭﹣﹣ 8 4 5 7 ﹣﹣╮                ╭﹣﹣ 1 3 6 2 ﹣﹣╮           分 h=1og2n = 1ogz8=3
    ╭﹣ 8 4 ﹣╮      ╭﹣ 5 7 ﹣╮       ╭﹣ 1 3 ﹣╮       ╭﹣ 6 2 ﹣╮         |
    8 	     4       5	      7       1 	   3       6 	    2      ﹣﹣﹣﹣
    ╰- 4 8 --╯       ╰- 5 7 --╯       ╰- 1 3 --╯        ╰- 2 6 --╯      治  h=1og2n = 1ogz8=3
         ╰--- 4 5 7 8 ---╯                 ╰--- 1 2 3 6 ---╯               |
                 ╰--------  1 2 3 4 5 6 7 8 ---------╯ 				   ﹣﹣﹣﹣
    
```

*    拆分
     *    进行的排序序列分为左右两个部分，
          *   进行排序的序列
              *   起始元素下标为first，
              *   最后一个元素的下标为last，
              *   那么左右两部分之间的临界点下标mid=(first+last)/2，
              *   这两部分分别是 A[first … mid] 和 A[mid+1 … last]
     *    两部分序列继续按照上面继续进行划分，直到划分的区间长度为1 
*    合并
     *    执行归并排序 
     *    对所分的n个子序列进行两两合并，得到n/2或n/2+l个含有两个元素的子序列，再对得到的子序列进行合并，直至得到一个长度为n的有序序列为止 
*    

## java业务实现

```java
介绍
    1. 先判断符合递归实现，
    2. 找到最小的递归单元
个人理解
    就是利用下标，按照二叉树遍历的模式，遍历到最小子树
    
    
public class merge {
    public void mergSort(int[] arr, int left, int right) {
        if (left < right) {
            mid = (left + right) >> 1;
            mergSort(int[] arr, left, mid);
            mergSort(int[] arr, mid+1, right);
            adjust(int[] arr, left, mid, right);
        }
    }
    
    public void adjust(int[] arr, left, right) {
        
        int[] temp = new int[right-left+1];
        int temIndex = 0;  // temp 初始坐标
        
        int left_start = left;
        int right_start = mid+1;
        
        // 当左右两部分子区间都非空的时候
        while (left_start <= mid && right_start <= right) {
            if (arr[left_start] <= arr[right_start]) {
                temp[tempIndex++] = arr[right_start++];
            } else {
                temp[tempIndex++] = arr[left_start++];
            }
        }
                
        // 其中的一边完全存储入 临时数组中： right 全存入
        // left_start <= mid && right_start > right
        while (left_start <= mid) {
        	temp[tempIndex++] = arr[left_start];
        }
        
        // 其中的一边完全存储入 临时数组中： left 全存入
        // left_start > mid && right_start <= right
        while (right_start <= right) {
            temp[tempIndex++] = arr[right_start];
        }
        
        // 将 temp 中排好序号的数列覆盖原本 arr 中的位置
        tempIndex = 0;
        while (left < right) {
            arr[left++] = temp[tempIndex++]
        }
    }
}     
```



## 性能分析

### 稳定性

*   稳定
*   归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。

### 时间复杂度

* 

## 用途

*   一般用于对总体无序，但是各子项相对有序的数列
*   速度仅次于快速排序
* 代价是需要额外的内存空间。

    