## 介绍

```java
自我理解
    创建一系列从小到大的桶，
    将相同的数据放到同一个桶中，不同的数据，根据最小值为基数，放到不同的桶中
    将所有的桶中的数据还原回原数组即可
跟桶排序不同
    桶排序：是范围， 面对大范围的数据
    计数排：具体的值，面对大量重复的数据
    
参考
    https://zhuanlan.zhihu.com/p/137576551
```

## =========

## 业务逻辑

```java
前期业务处理
	// 对数组 92 99 98 91 96 97 99进行排序
    99 - 91 = 8
    所以数组下标和值对应的值为下表所示
    下标			0  1   2  3  4  5   6   7   8   9    ...
    下标对应的值   91  92  93 94 95 96  97  98  99  100  ...
    对数组进行遍历，对于出现的数值，其对应的下标位置上的值加 1
    
    
// 遍历数组： 92     
           92               
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     |    | 1  |    |    |    |    |    |    |    |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9
    
    
 // 遍历数组： 92 99
           92                                 99
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     |    | 1  |    |    |    |    |    |    |  1 |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9

// 遍历数组： 92 99 98       
           92                             98   99
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     |    | 1  |    |    |    |    |    | 1  | 1  |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9
       
        
// 遍历数组： 92 99 98 91    
       91   92                            98   99
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     | 1  | 1  |    |    |    |    |    | 1  | 1  |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9
        
// 遍历数组： 92 99 98 91 96   
       91   92                  96        98   99
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     | 1  | 1  |    |    |    | 1  |    | 1  | 1  |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9   
    
// 遍历数组： 92 99 98 91 96 97   
       91   92                  96   97   98   99
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     | 1  | 1  |    |    |    | 1  | 1  | 1  | 1  |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9    
// 遍历数组： 92 99 98 91 96 97 99   
       91   92                  96   97   98   99
┌ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ ── ┬ 
     | 1  | 1  |    |    |    | 1  | 1  | 1  | 2  |   
└ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴ ── ┴  
  0    1    2    3    4    5    6     7    8    9     
    
// 遍历结束，将对应的数值和下标进行一一对应，
遍历数组， 输出下标对应的值，元素的值是几， 就输出几次
91 92 96 97 98 99 99

```

## java业务实现

```java
public class CountSort {
    public void sort([]int arr) {
        int min = findMin(arr);
        int max = findMax(arr);
        int arrSize = max - min + 1
        []int countArray = new int[arrSize];
        
        // 入桶
        for (int i = 0; i < arr.length; i++){
            int j = arr[i] - min
            countArray[j]++;
        }
        
        // 遍历放回原数组， 进行出桶
        int index = 0;
        for (int i = 0; i < countArray.length; i++) {
            for (int j = 0; j < coutArray[i]; j++) {
                arr[index++] = min + i
            }
        }
    }
    
    
	public int findMin([]int arr) {
        int min = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (min > arr[i]) {
                min = arr[i];
            } 
        }       
        return min
    }
    
    public int findMax([]int arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (max < arr[i]) {
                max = arr[i];
            } 
        }        
        return max
    }

}

```

## =========

## 优化业务逻辑

```java
```



## java 优化业务实现

```java
```

## =========

## 优缺点

### 优点

```java
1. 在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法
```

### 缺点

```java
1. 然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序
   （基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）
//=====================================================
2.当数列最大最小值差距过大时，并不适用于计数排序
	比如给定20个随机整数，范围在0到1亿之间，此时如果使用计数排序的话，就需要创建长度为1亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。
3.当数列元素不是整数时，并不适用于计数排序
	如果数列中的元素都是小数，比如3.1415，或是0.00000001这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。
	正是由于这两大局限性，才使得计数排序不像快速排序、归并排序那样被人们广泛适用。    
```

