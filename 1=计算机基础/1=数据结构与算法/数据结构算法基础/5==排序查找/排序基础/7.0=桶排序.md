## 介绍

```java
介绍
	桶排序是一种排序的思想
    桶排序提出了一种新的思路，即基于数据状态的排序
    
    
别称
    桶排序（Bucket sort
    箱排序
分类    
    基数排序
    计数排序
    	位图排序
// 个人理解
    利用数组的下标表示数，
    
概念
    // 划分多个范围相同的区间，每个自区间自排序，最后合并。
    首先：数组分到有限数量的桶里。
    然后：每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），
    最后：依次把各个桶中的记录列出来记得到有序序列
```

## 性能

```java
平均时间复杂度：O(n + k)
最佳时间复杂度：O(n + k)
最差时间复杂度：O(n ^ 2)
空间复杂度：O(n * k)
稳定性：稳定
```



### 时间复杂度

* 遍历数组求最大值最小值为O(n)，
* 遍历数组放入"桶"中复杂度为O(n)，
* 遍历桶取出每个值的复杂度为O(n)，
* 最终的时间复杂度为O(3n)，也就是O(n)

### 空间复杂度

* 额外的空间取决于元素的取值范围，总的来说为O(n)

### 稳定性

* 桶排序是否稳定取决于"桶"用什么数据结构实现，
    * 如果是队列，那么可以保证相同的元素"取出去"后的相对位置与"放进来"之前是相同的，即排序是稳定的，
    * 如果用栈来实现"桶"，则排序一定是不稳定的，
* 因为桶排序可以做到稳定，所以桶排序是稳定的排序算法

### 提效措施

* 在额外空间充足的情况下，尽量增大桶的数量
* 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中；



## 运行逻辑

```java
  
逻辑介绍
    设置一个定量的数组当作空桶子。寻访序列，并且把项目一个一个放到对应的桶子去。对每个不是空的桶子进行排序。
    从不是空的桶子里把项目再放回原来的序列中。
    
待排序序列
    [18, 11, 28, 45, 23, 55]
    
1. 自己确定每个桶的大小： 10
2. 根据数据规模，得出桶的个数： (55-11)/10 + 1 = 4
3. 确定每个桶的范围，并把数据放入各个同 
    0 [10 - 20 )  : 18 11 23
    1 [20 - 30 )  : 28  
    2 [30 - 40 )  : 
    3 [40 - 50 )  : 45
    4 [50 - 60 )  : 55
4. 对每个桶进行排序
    [10 - 20 )  : 11 18 23
    [20 - 30 )  : 28 
    [30 - 40 )  : 
    [40 - 50 )  : 45
    [50 - 61 )  : 55
5. 所有桶的数据都合并到一起就会得到排序好的数组
   [11, 18, 23, 28, 45, 55]
```

## java实现

```java
public class bucket {
    public void sort(int[] arr, int bucketSize) {
        int arrLength = arr.length;
        int max = arr[0];
        int min = arr[0];
        for (int i=1; i<arr.length; i++) {
            max = math.max(max, arr[i]);
            min = math.min(min, arr[i]);
        }
        
        // 分桶进行创建
        int bucketCount = (max - min) / bucketSize + 1 ;
        List<list<Integer>> buckets = new ArrayList<>(bucketCount);
        
        // 创建桶
        for(int i=0; i<bucketCount; i++) {
            buckets.add(new ArrayList<Integer>);
        }
        
        // 装桶
        for (int i=0; i<arr.length; i++) {
            int num = ( arr[i] - min ) / bucketSize;  // 要进入的桶编号
            bukets.get(num).add(arr[i]);  	// 添加进入桶
        }
        
        // 对每个桶内的数据进行排序
        for (int i = 0; i<bucketSize; i++) {
            Collection.sort(buckets.get(i))
        }
        // 将同桶中的数据放回原序列
        int index = 0;
        for (int i=0; i< bucketCount; i++) {
            for (int j=0; j<buckets.get(i).size(); j++) {
                arr[index++] = buckets.get(i).get(j);
            }
        }
        
    }
}
```

