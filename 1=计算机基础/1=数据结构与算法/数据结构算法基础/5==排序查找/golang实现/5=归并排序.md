## 递归实现

```java
package main


func merge(left ,right []int) []int {
	var result []int
	for len(left) != 0 && len(right) != 0 {
		if left[0] <= right[0] {
			result = append(result, left[0])
			left = left[1:]
		} else {
			result = append(result, right[0])
			right = right[1:]
		}
	}

	for len(left) != 0 {
		result = append(result, left[0])
		left = left[1:]
	}

	for len(right) != 0 {
		result = append(result, right[0])
		right = right[1:]
	}

	return result

}

func mergeSort(a []int) []int {

	length := len(a)
	if length < 2 {
		return a
	}

	// 确保前面的数据始终是偶数个的
	mid := length / 2 + length % 2

	// 取左边
	left := mergeSort(a[0:mid])
	// 取右边
	right := mergeSort(a[mid:])
	// 进入递归
	// 这里有一个逻辑，就是 left 没有归，就会一直递下去 ，
	// 同时有一个right 等待执行，而 right 进行回溯的时候，其中的其中的切片，正好是上层的两个元素
	// 最后一层 left 归的时候，
	// 递归到底层的时候，就不
	return merge(left,right)

}
```

