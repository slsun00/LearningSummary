## 结构

```java
public class Node {
    int data;
    int height;
    Node left;
    Node right;
    Node parent;
}

public class AVLTree {
    public Node root;
}
```

## 增

### 构造

```java
public AVLTree createAVLTree(int[] arr) {
    // 遍历数组
    // 插入树
}
```



### 插入节点

#### 最值插入

```java
public void insert(int value) {
    
    Node node = new Node(value);
    if (this.root == null) {
        this.root = node;
        adjustHeight(this.root);
        return
    }
    
    // 非空

    while (curNode != null) {
        if (curNode.value > value) {
            if (curNode.left == null) {
                curNode.left = node;
                node.parent = curNode;
                // 节点关系还没有添加完全
			   Node problemNode = findProblemNode(node);
                if (problemNode != null) {
                    adjustNode(problemNode)
                }
                
                return
            } else {
               
                curNode = curNode.left;
            }
           
        } else if (curNode.value < value) {
			if (curNode.right == null) {
                curNode.right = node;
			   Node problemNode = findProblemNode(node);
                if (problemNode != null) {
                    adjustNode(problemNode)
                }
                return
            } else {
                curNode = curNode.right;
            }
        }
    }
}




```

#### 其他未完成

```java
    
    // 调整节点
    if (node.value < problemNode.value) {
        
        if (node.value < problemNode.left.value) { 
            // problemNode > problemNode.left > node
            adjustThreeNode(problemNode, problemNode.left, probleNode.left.left);
		             
       	 } else if (node.value > problemNode.left.value) {
            // problemNode >  node > problemNode.left    
		  adjustThreeNode(problemNode, probleNode.left.right, problemNode.left);
         }
 
    } else if (node.value > problemNode.value) {
        if (node.value < problem.right.value) {
            // problemNode <  node < problemNode.right
            adjustThreeNode(problemNode.right, probleNode.right.left, problemNode);
        } else if (node.value < problem.right.value) {
            // problemNode < problemNode.right <  node
            adjustThreeNode(problemNode.right.right, probleNode.right, problemNode);
        }
            
    }
```



## 删

### 节点删除

#### 分支删除

#### 最值删除

## 改

### 失衡节点

```java
public Node findProblemNode(Node node) {
    while (getBalanceFactor(node) <= 1) {
        if (node == this.root) {
            node.height++;
            return null;
        }
        node.height++
	    node = node.parent;            
    }
    return node;
}
```



### 失衡调整

```java

// 节点调整
public void adjustNode(Node problemNode) {    
    
    // 问题节点的父节点
    Node fatherNode = problemNode.parent;

    // 调整后的中间父节点
    Node midFatherNode = null
        
        
    // problemNode > problemNode.left : 确定使用左子节点
    if (problemNode.left.height >= problemNode.right.height) {
        // 决定用左子节点
        Node child = problemNode.left
        // 确定使用哪一个孙节点
        if (child.left.height >= child.right.height) {
            // 选用孙左节点 : child.left < child < problem
            midFatherNode = adjustThreeNode(problem.left.left, problemNode.left, problemNode);
        } else if (child.left.height >= child.right.height) {
            // 选用孙右节点 : child < child.right < problem
             midFatherNode = adjustThreeNode(problem.left, problemNode.left.right, problemNode);
        }

    // problemNode > problemNode.left : 确定使用右子节点
    } else if (problemNode.left.height < problemNode.right) {
        // 决定使用 右子节点
        Node child = problemNode.right
        // 决定使用哪个孙子节点
        if (child.left.height >= child.right.height) {
            // 选用孙左节点 : problem < child.left < child
             midFatherNode = adjustThreeNode(problem.left, problemNode.left.right, problemNode);
        } else if (child.left.height >= child.right.height) {
            // 选用孙右节点 : problem < child < child.right
             midFatherNode = adjustThreeNode(problem, problemNode.right, problemNode.right.right); 
        }
    }
    
    // 返回调整后的父节点,接入原来的树    
    // 根结点
    if (fatherNode == null) {
        this.root = midFatherNode;
        return;
    } 
    
     // 非根节点
    if (fatherNode.value < midFatherNode.value) {
		fatherNode.right = midFatherNode;
        midFatherNode.parent = fatherNode;
    } else if (fatherNode.value > midFatherNode.value){
		fatherNode.left = midFatherNode;
         midFatherNode.parent = fatherNode;
    }
   
	// 从一个节点分别向上向下改变树的高度
    // midFatherNode   ---》   root
    // midFathrNode -->  根结点
	
    this.adjustHeight(fatherNode);
}


public midFatherNode adjustThreeNode(Node maxNode, Node midNode, Node minNode) {
    maxNode.left = mid.right;
    mid.right.parent = maxNode;
    min.right = mid.left;
    mid.left.parent = min;
    return midNode;  
}
```

### 高度调整

```java
public void adjustHeight(Node node) {
    
    // 向下调整
    while (node != null) {
        int leftHeight = nodeHeight(node.left);
        int rightHeight = nodeHeight(node.right);
        // 得出来的是深度
        node.height = max(leftHeight, rightHeight)+1;
    }
    
    // 向上调增
    while (node != null) {
		this.adjustHeight(node.parent)
         node = node.parent;
    }
    
}


```



## 查

### 节点的高度

```java
public int nodeHeight(Node node) {
    if (node == null) {
        return 0
    }
    // 这个得出的是层数
    int leftHeight = nodeHeight(node.left);
    int rightHeight = nodeHeight(node.right);
    // 得出来的是深度
    return max(leftHeight, rightHeight)+1;
} 

public int max(int a, int b) {
    if (a >= b) return a;
    return b
}
```

### 平衡因子

```java
public int getBalanceFactor(Node node) {
    return math.abs(node.left - node.right);
}
```

