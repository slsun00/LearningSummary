

## 基础结构

```java
public class Node {
    public int data;
    public Node leftNode;
    public Node rightNode;
    // 设计这个是为了以后删除好用，不然查询父节点很痛苦的
    public Node parentNode; 
    // 省略 set get toString 方法 
    
    Node(int data) {
        this.data = data;
    }
}

public class BinarySearchTree {
    
    // 构造搜索树
    public BinarySearchTree ArrayToBSTree(int[] arr) { ... }
    
    // 插入
    public void add(int value) { ... }
}
```



## 增加

### 插入 + 构造

```java
   // 不考虑插入相同的数据
   public void add(int value) {

        Node newNode = new Node(value);

        if (this.root == null) {
            this.root = newNode;
            return;
        }
        // 非空
        Node curNode = this.root;
        while (curNode != null) {
            if (curNode.value > value) {
                if (curNode.leftNode == null) {
                    // 没哟设置父节点，不用维护
                    curNode.leftNode = newNode;
                    return;
                } else  {
                    curNode = curNode.leftNode;
                }
            }

            if (curNode.value < value) {
                if (curNode.rightNode == null) {
                    curNode.rightNode = newNode;
                    return;
                } else {
                    curNode = curNode.rightNode;
                }
            }
        }
    }
}
```

## 删除

### 结点删除

```java
public boolean deleteNode(int value) {
	// 找到该节点
    Node node = findValue(value);
    if (node != null) {
       	return circleDelete(node); 
    }
	return false;
}    
public boolean circleDelete(Node node) {
    // 是叶子节点就直接置空
    if (node.left == null && node.right == null) {
        this.setNodetoNull(node);  // 叶子节点置空
        return true;
    }
    
    // 只有左孩子, 或者有两个孩子： 都直接使用前驱替换
    if (node.left != null) {
        // 找到直接前驱： 其子树的最大值
        Node prenode = maxNode(node.left);
		// 直接前驱元素覆盖
        node.value = prenode.value;  
        
        // 删除替换节点，同时当替换节点为非叶子节点，需要循环删除
        circleDelete(prenode);
        
        return true;
    }
    
    // 只有右孩子
    if (node.right != null) {
        // 找到直接后继元素: 其子树的最小值
        Node nextNode = minNode(node.right)；
       // 值覆盖
	  node.value = nextNode.value;
       // 删除替换节点，同时当替换节点为非叶子节点，需要循环删除
       circleDelete(nextNode);
        return true
    }
    return false;
}

public void setNodetoNull(Node node) {
    // 说明删除的是根结点
    if (node.parent == null) {
        node.left = null;
        node.right = null;
        return;
    }
    
    if (node.parent.value < node.value) {
        node.parent.right = null;
    } else {
        node.parent.left = null;
    }
}
```

### 节点删除 - 非递归

```java
public boolean circleDelete(Node node) {

    // 找到叶子结点
    while (node.left =!null || node.right != null) {
         // 只有左孩子, 或者有两个孩子： 都直接使用前驱替换
        if (node.left != null) {
            // 找到直接前驱
            Node changeNode = maxNode(node.left);
            
        // 只有右孩子
        } else if (node.right != null) {
            // 找到直接后继元素
            Node changeNode = minNode(changeNode.right)；
        }
        
        // 值交换
        node.value = changeNode.value;
        // 循环删除前驱节点
        node = changeNode;
    }
    	// 叶子结点，直接置空
        this.setNodetoNull(node);

}
```



## 查询

### 查询某个元素存不存在

```java
   public  Node findValue(int value) {
        if (root == null) {
            return null;
        }

        Node curNode = this.root;
        while (curNode != null) {
            if (curNode.value == value) {
                return curNode;
            }
            
            // 循环
            if (value < curNode.value) {
                curNode = curNode.leftNode;
            } else if (value > curNode.value) {
                curNode = curNode.rightNode;
            }
            
        }
        
        return  null;

    }
```

### 最大值

```java
介绍
    从某个节点为根个树的最大值
public Node maxNode(Node curNode) {	
    while (curNode.right != null) {
        curNode = curNode.right;
    }
    return curNode;

}    
```



### 最小值

```java
介绍
    从某个节点为根个树的最小值
public Node preNode(Node curNode) {
	
    while (curNode.left != null) {
        curNode = curNode.left;
    }
    return curNode;

}    
```



### 叶子结点

```java
public boolean isLeafNode(Node node) {
	if (node.left == null && node.right == null) {
		return true;
    }
    return false;
}
```





### parentNode 父节点

```java
public Node parentNode(int value) {
    if (this.root == null) {
        return null;
    }
    
    if (this.root.value == value) {
        return null;
    }
	Node parentNode = null;
    Node curNode = this.root;
    while (curNode != null) {
        if (curNode.value == value) {
            return parentNode;
        }
        
        if (value < curNode.value) {
            parentNode = curNode;
            curNode = curNode.leftNode;
        } else if (value > curNode.value) {
            parentNode = curNode;
            curNode = curNode.rightNode;
        }

    }

    return  parentNode;

}
```

