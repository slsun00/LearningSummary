

## golang 实现

### 基础结构

```go
// 节点  BinarySearchTreeNode
type node struct {
    value int
	// times int  如果树中存在值相等的点
    left *Node
    right *Node
}

// 二叉搜索树，  BinarySearchTree  树中包含一个根元素
type BSTree struct {
    root *node
}

// 初始化二叉查找树
func NewTree() *Tree {
    return new(BinarySearchTree)
}

// 结点构建
func newNode(value int64) *Node {
    return &Node{value:value}
}

```



### 最值结点

```go
// 最小值
// 根据性质，最小值的节点一定在树的最左边

func (tree *BSTree) Min () interface{} {
    node := bst.root
    if node == nil {
        return nil 
    }
    for {
        if n.left == nil {
            return &n.value
        } else {
            n = n.left
        }
    }
}
   

// 最大值
// 值最大值的节点在树的最右边
func Max (root node) (node , bool ) {
    node := bst.root
    if node == nil {
        return nil ，false 
    }
    for {
        if node.right == nil {
            return node , true
        } else {
            node = node.right
        }
    }
}
```

### 添加 / 插入元素

* 非优化

    ```go
    说明
    	1. 要把树的 add 方法 和 node 的 Add  方法拆开来写
    		因为对象不同 树 和 node 的结构体不同，所以各自调用各自的方法
    
    func (tree *BSTree) Add (value int64) {
        // 空树
        if tree.root == nil {
            tree.root = NewNode(value)
            return
        }
        // 添加结点
        tree.Root.Add(value)
    }
    
    func (node eNode) Add (value int64) {
        // 1. 元素  < 当前节点的元素 , 进行左树遍历
        if value < node.value {
            if node.left == nil {
                // 连接起来形成树
                node.left = NewNode(value)
            } else {
                // jin
                node.left.Add(value)
            }
        // 2. 添加元素  > 当前节点元素 ， 进行右树遍历
        } else if value > node.value {
            // 连接起来形成树
            if node.right == nil {
                node.right = newNode(value)
            } else { 
                node.right.Add(value)
            }
        // 3. 添加的元素 == 当前节点元素
        } else if value == node.value {
            node.times ++
        }
    }
    ```

    

* 优化

    ```go 
    // 分开
    func (tree *BSTreee) Add (value int) {
        tree.root.Add(value)
    }
    
    // 结点迭代添加
    func (root Node) Add (value int64) {
        if root == nil {
            root = newNode(value)
            return 
        }
        if value < root.value {
            root = root.left 	// 1
            root.Add(value)
        } else if value > root.value {
            root.right.Add(value)  // 2  {1 和 2 形式都可以，你感觉那种好就用哪一种，2333}
        } else if value == root.value {
            root.times++
        }
    }
    
    
    // 合体
    func Add(root Node,value int64) {
        if root == nil {
            root = newNode(value)
            return
        }
        if value < root.value {
            Add(root.left,value)
        } else if value > root.value {
            Add(root.Right,value)
        } else if value == root.value {
            root.times++
        }   
    }
    ```

```
### 转化构造排序树

*   一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列

​```go
// 这个是给你一个数组 [1 , 2 , 3 , 5] 写成排序二叉树
// arrytobisorttree
func ArrytoBSTree (arry []int) *BSTree {
    tree := NewTree()
    for i:=0; i<len(arry); i++ {
        tree.Add(arry[i])
    }
    return &BSTree
}
```



### 查找结点

*   查找普通结点
*   查找父结点

```go
// 找到返回 true  否则返回 false

func (treet *BSTree) Search (value int) (node , bool) {
    
    node, ok := search(tree.root,value)
    if ok == false {
        return nil , false
    } 
    return node , true  
    //return search(bst.root,value)
}
// 结点循环
func search(root node,value int) (node , bool) {

    // 查不到
    if node == nil {
        return nil ,false
    }
    
    // value 属于 左边
    if value < node.value {
        return search(node.left,value)
    	  // value 应该属于右边
    } else if key > node.value {
        return search(node.right,value)
          // value 查找到
    } else if value == node.value {
        return node, true
    }
}

// 查找结点的父节点

func (tree *BSTree) FindPNOde(value) (node, false) {
    node := tree.root
    if node == nil {
        return nil,false
    }
    
    if value.
}

```



### 删除元素

```go
// 没有写完

func (tree *BSTree) Delete(value int) bool {
    // 查找要删除的结点
    node,ok := search(tree.root,value)
    if ok == false {
        return false
    }
    // 要删除节点的父节点
    pnode := 
    // 要删除的结点 没有孩子结点
    
}




func deleteBST (bt *BiNode, value int ) bool {
    if bt  == nil {
        return false
    }
    if value == bt.value {
        deleteNode(node)
    } else if value < bt.value {
        deleteBST(bt.lchild,value)
    } else if value > bt.value {
        deleteBST(bt.rchild,value)
    }
}
// 查找双亲结点
func (tree *BSTree) FindPNode(value) {
    root := tree.root
    if root == nil {
        return nil ,false
    }
    if value == root.value {
        return node ,false
    }
    
}

func deleteNode(bt *BINode) {
    if bt.lchild == nil && bt.rchild == nil { // 叶子结点为
        
    } else if bt.lchild == nil {
        
    } else if bt.rchild == nil {
        
    }
}
```



