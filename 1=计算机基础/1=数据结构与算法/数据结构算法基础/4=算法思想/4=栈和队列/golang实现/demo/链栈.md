```go
package main

import "fmt"

type data interface{}

type Node struct {
	data data
	next *Node
}
type List struct {
	head *Node
	len  int
}

func CreateNode(data data) *Node {
	return &Node{
		data: data,
		next: nil,
	}
}

// 创建链栈
func CreateList() *List {
	return &List{
		head: nil,
		len:  0,
	}
}

// 判空
func (l *List) IsEmpty() bool {
	// 也可以直接使用 l.len == 0, 用 nil 更能心事没有头节点
	if l.head == nil {
		return true
	}
	return false
}

// 进栈 ,添加元素
func (l *List) Push(data data) {

	node := CreateNode(data)
	// 第一个数据点儿指向
	cur := l.head

	// 空链表时 cur 为 nil,它是没有 next 属性
	if l.head == nil {
		l.head = node
		return
	} else {

		// 遍历最后一个元素
		for {
			// 最后一个元素的 next 是 nil
			if cur.next == nil {
				cur.next = node
				l.len++
				return
			}
			// 游标后移
			cur = cur.next
		}

	}

}

// 出栈 ， 删除元素
func (l *List) Pop() {

	// 空链栈跳出
	if ok := l.IsEmpty(); ok {
		fmt.Println("空栈，无法弹出")
		return
	}

	cur := l.head
	// 只有一个节点的时候，没有前节点的
	if cur.next == nil {
		l.head = nil
	} else {
		// 两个以上的节点的有前节点

		prev := cur    // 头节点。第一个数据点
		cur = cur.next // 第二个数据点儿

		for {
			if cur.next == nil {
				prev.next = nil
				return
			}
			prev = cur
			cur = cur.next
		}
	}
}

// 遍历元素
func (l *List) TravelPrint() {
	if ok := l.IsEmpty(); ok {
		fmt.Println("空链表，没有元素")
		return
	}

	// 非空链表
	cur := l.head

	for {
		// 先把当前元素 的 data 打印出来，然后在进行判断其后面是否为 nil
		fmt.Printf("%5v", cur.data)
		if cur.next == nil {
			return
		}
		cur = cur.next
	}
}

func main() {
	l := CreateList()
	fmt.Println(l.IsEmpty())

	l.Push(1)
	l.Push(2)
	l.Push(3)
	l.TravelPrint()

	fmt.Println("------")

	l.Pop()

	l.TravelPrint()
}

// func (l *List) Pop() {

// 	// 空链栈跳出
// 	if ok := l.IsEmpty(); ok {
// 		fmt.Println("空栈，无法弹出")
// 		return
// 	}

// 	cur := l.head

// 	for {
// 		if cur.next == nil {
// 			fmt.Println("最后一个元素", cur.data)
// 			cur = nil
// 			fmt.Println(cur) // cur 的确是nil ,但是就是遍历不出来
// 			l.len--
// 			return
// 		}
// 		cur = cur.next
// 	}
// }

```

