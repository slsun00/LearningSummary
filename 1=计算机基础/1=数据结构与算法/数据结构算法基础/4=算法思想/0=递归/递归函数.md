```go
https://www.zhihu.com/question/31412436
https://www.zhihu.com/question/20507130/answer/15551917
```

## 6.递归

## 1.概念

*   Recursion 
    *   re-  (again) +  curs- （come, happen）
*   值一个对象部分地包含他自己，一个过程直接或间接调用自己
*   中文翻译 ”递归“ 表达了两个意思：递＋归
    *   递是
        *   就是进行的操作
    *   归是
        *   归的是结果，就是你要的东西
        *   归的当层是什么，当层下面的操作是什么

## 2实质

*   就是归纳的思想

    ```go
    要解决 p(n) , 首先要解决 基础 P(1) ,然后假定 p(n-1) 已经解决，则 p(n) 解决
    ```

    

## 2.程序框架

```go
// 解决问题的方法
1. 在递过去的过程
	将子问题转化为子问题的每一步，解决该不中剩余的问题
	递归到深处后，不断归来
2. 在归来的时候
	先将问题全部描述展开，再由尽头依次解决每个问题
	递去，归来

// 递归三要素
1. 定义描述问题
	接收什么参数、返回什么值、代表什么意思，设计好首部
	原问题拆解为和原问题相同但是规模更小的子问题
	
2. 解决最小问题
	确定递归边界，直接解决小问题
3. 分解大问题、小问题的解构造出函数首部定义的原问题的解




if  (问题规模适合直接求解 即递归结束条件) {
    // 结束递归， 直接求解
    // 基本条件
} else if {
    // 递归便是问题的解
}

func  recursion( 大规模 ) {
    
    if (end_condition) {  // 问题规模适合直接求解 即递归结束条件
        // 结束递归， 直接求解表达式 , 基本条件
        end;
    } else {
        // 步进表达式，使问题蜕变成子问题的表达式
        // solve  注意是否需要 f(n) f(n-1)
        recursion( 小规模 )
    }
}
```





## 2.分类

### Cata 型递归

*   利用子结构的计算结果，直接构造出父亲结构的计算结果，通常沿着某个递归数据结构进行

*   总结

    ```go
    Cata型递归 可以认为是 直接递归 的一种特殊情形, 你完全可以用 直接递归 来解决 cata型递归 可以解决的问题, 另一方面你也可以通过构造(或者想象)递归结构来把 直接递归 转化为 cata型递归.
    ```

    

### 直接递归

*   概念
    *   direct  cursin
    *   直接利用递归子调用的返回结果，构造当前调用的返回结果
*   分类
    *   分类标准
        *   按照递归数量
    *   分类
        *   线性递归
        *   树形递归
*   复杂度
    *   线性递归
        *   如果是线型递归那么一般可以预期它的最坏复杂度上限是线性复杂度
    *   树形递归
        *   最坏复杂度上限则是指数的, 
        *   其底数是多少其实取决于所有逻辑分支中, 递归分支最多的递归分支数量,

### 间接递归

*   概念
    *   indirect recursion
*   目标函数（用来递归的函数）
    *   目标函数用来递归
        *   向下传递一些额外的状态参数
        *   向上传递一些额外的返回值

### 尾递归

*   概念

    *   tail recursion
    *   只有到达特定状态的时候, 再去构造返回结果, 而其它时候, 只需要更新一些状态变量即可

    

*   形式

    ```go
    function story() {
    前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。
        } 
    function story() {
            从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。
        } 
    ```

    

*   优化

    ```go
    // 不是尾递归了。自然就不会有优化了 
    
    
    // 形式上只要最后一个return语句是单纯函数
    	return tailrec(x+1);
    //以下形式就不是
    	return tailrec(x+1) + x;
    ```

    

    

*   待整理

    ```go
      在每一步维护状态变量, 然后当循环结束的时候, 再根据之前构造的状态变量去构造最终结果.
      尾递归和循环这两种形式的代码是等价的, 它们可以很容易地进行互转
    
        尾递归是一种形式,只是用这种形式表达出的概念可以被某些编译器优化.尾递归的特殊形式决定了，这种弟归代码在执行讨程中是可以不需要回溯的(诵常的递归都是需要回潮的)。
    
        重要性在于当进行尾递归调用时，调用者的返回位置不需要被存在调用栈里。当递归调用返回时，它直接分支到先前已保存的返回地址。因此，在支持尾递归优化的编译器上，尾递归在时间和空间上都比较划算。迭代算法需要一个临时变量，这无疑导致了程序的可读性降低，迭代函数不像递归函数那样需要考虑函数调用的支出，而且对一个线程来说可用的栈空间通常比可用的堆空间要少得多，而递归算法则相对迭代算法需要更多的栈空间！
    ```



## 使用

*   按照递归定义的

    *   阶乘

*   数据结构是递归

    *   树、链表

*   解法是递归的（比较扯...）

*   情况

    ```go
    写出来分段状态函数
    
    ```

    



## 区别

*   递归
*   迭代
*   循环















## //========================================================================

## 1.本质

*   栈
*   凡是使用深度优先都是使用递归算法，凡是使用层次遍历的使用的都是队列 

## 2.分类

*   单支递归

    *    一个递归调用 
    *    指递归的过程总是朝着一个方向进行，如果函数１调用了函数２,而函数２又调用了函数１ 就不是
    *    一个递归调用，他可以通过普通循环来实现，并且不用进行回溯，它用临时变量来保存结果的,普通循环可以完成的。（但是递归底层运行时候，是进行自底向上的） 

*   多支递归

    *    多个递归调用 
    *    多支递归是要进行回溯的，它使用栈来保存中间结果的，需要通过循环栈来实现。 

* 尾递归

* 迭代循环实现

    

    

    ## 3. 分析

*    在外部看来是由上至下，从内部看是由下至上的，我们分析问题时，和写代码都是站在外部看。 

## 条件

1.使用递归的三个条件

* 问题可以分解为遵循重复式的多个过程
    * 每步自己完成一点儿，剩下的交给下一个自己，利用下家返回的结果
* 最后一个下家必须要满足一定的终止条件，无需再向下交付，终结并返回
* 递归不能太深，防止堆栈溢出 

## 2.思路分析

1.从上层到下层的递归

* 这个就是分析函数的过程，通过一两个迭代的过程，了解整个迭代是如何运行
* 了解运行机制，写出跌代的入口（就是通过这个入口进行下一步跌代） 
* 找到递归终止条件：这个就在最核心的一层

## 缺点

*    递归算法的执行效率通常比较差。因此，在求解某些问题时，常采用递归算法来分析问题，用非递归算法来求解问题； 

## 递归转化为非递归

*    直接求值（迭代/循环），不需要回溯 
     *    使用一些变量保存中间结果，称为直接转换法 
     *    消除尾递归和单向递归，将递归结构用循环结构来替代 

*    间接转换法 
         
     *   不能直接求值，需要回溯  

     *   方法使用栈保存中间结果，一般需根据递归函数在执行过程中栈的变化得到 





## 需要整理

```go
递归是静中有动，有去有回。
循环是动静如一，有去无回。

递归：你打开面前这扇门，看到屋里面还有一扇门（这门可能跟前面打开的门一样大小（静），也可能门小了些（动）），你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开，。。。， 若干次之后，你打开面前一扇门，发现只有一间屋子，没有门了。 你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这钥匙开了几扇门。

循环：你打开面前这扇门，看到屋里面还有一扇门，（这门可能跟前面打开的门一样大小（静），也可能门小了些（动）），你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，（前面门如果一样，这门也是一样，第二扇门如果相比第一扇门变小了，这扇门也比第二扇门变小了（动静如一，要么没有变化，要么同样的变化）），你继续打开这扇门，。。。，一直这样走下去。 入口处的人始终等不到你回去告诉他答案。

有些问题的定义本身就是递归形式的时候，最是适合用递归来解决。

```





## 参考

```go
1.https://blog.51cto.com/1464490021/1894666
2.http://www.linuxidc.com/Linux/2014-06/102934.htm
3.https://baike.baidu.com/item/%E5%B0%BE%E9%80%92%E5%BD%92
```

