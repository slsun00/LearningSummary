## 需百度

```java
多线程怎么同时进入一个类 ，去拿属性值
```



## 懒汉式，线程不安全

```java
package cn.it.day02;

public class Demo2 {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2);
    }
}


class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的共有方放，当使用该方法的时候， 才创建 instance
    // 取得getinstance 的时候，会有多个线程同时得到这个方法进行访问
    public static Singleton getInstance(){
        if (instance == null) {
            instance = new Singleton();
        }
        return  instance;
    }
}

```

## 线程安全，同步方法

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公有方法， 加入同步处理的代码，解决线程安全的问题
    // 懒汉模式
    public static synchronized Singleton getInstance(){
        if (instance == null) {
            instance = new Singleton();
        }
        return  instance;
    }
}

// 问题

1. 解决线程不安全的问题
2. 效率太低了， 每个线程要想获得类的实例的时候， 执行 getInstance 方法都要进行同步，
    但是这个方法只用执行实例化一次就够了，后面向获得该类的实例， 直接 return 即可
3. 不推荐使用
```

## 线程安全，同步代码块

```java
// 同步机制放到了代码块中
// 无法实现线程安全， 没有意义
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公有方法， 加入同步处理的代码，解决线程安全的问题
    // 懒汉模式
    public static  Singleton getInstance(){
        if (instance == null) {
            synchronized (Singleton.class){
                            instance = new Singleton();
            }
        }
        return  instance;
    }
}
// 优缺点

1. 这种方法是对第四种方法的改进， 因为前面同步方法效率太低
2. 但是这种方法并不能实现线程同步的作用 ， 
    一个线程进入 if 代码块， 还没有来的及往下执行， 其他线程也会通过这个判断语句产生更多的实例
```

