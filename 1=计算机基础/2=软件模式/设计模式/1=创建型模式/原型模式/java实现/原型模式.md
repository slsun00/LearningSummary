## 优势

* [Java](http://c.biancheng.net/java/) 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
* 使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

## 缺点

* 需要为每一个类都配置一个 clone 方法
* clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
* 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦
* 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 

## 使用

```java
原型模式 + 工厂模式 ==》 new  <==> 原型模式
```



## 浅拷贝

### 实现 Cloneable 接口

```java
// 注意是值传递， 引用类型传递的是地址值，所以新对象的修改会修改原对象
public class Person implements Cloneable{
    public int age;
    public Date date;

    public Person(int age, Date date) {
        this.age = age;
        this.date = date;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    // 注意重写下 toString 方法，这是非关键代码，这里就不写了
}

// 调用
public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date();
        //new 方式创建：
        Person student = new Person(15, date);
        System.out.println(student); // Person{age=15, date=Sun Feb 21 00:58:05 CST 2021}
        // 原型模式创建
        Object lisi = student.clone();
        System.out.println(lisi);  // Person{age=15, date=Sun Feb 21 00:58:05 CST 2021}
        
    }
}
```

### 个人理解

```java
其实就像
    Person student = new Person(23,date);
	Person lisi = student;
```



## 深克隆

### 对象流

```java
方式一
    // 对于浅克隆的克隆方法进行稍微改变
    @Override
    protected Object clone() throws CloneNotSupportedException {
    	Object obj = super.clone();
    	// 进行深克隆
    	Person p = (Person)obj;
    	// 把对象的属性一一重新生成为新的属性，不是原来的对象了，确是重新生成，被层层复制。 
    	// 相当于 p.date = new Date(this.date)
	    p.date = (Date)this.date.clone(); // 当前属性进行克隆
        return p;
    }
```

