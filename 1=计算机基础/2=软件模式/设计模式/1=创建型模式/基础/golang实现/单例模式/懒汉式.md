## 需要总结

```go
https://www.liwenzhou.com/posts/Go/singleton_in_go/
```





## 介绍

    * 懒汉式就是创建对象时比较懒，先不急着创建对象，
    * 在需要加载配置文件的时候再去创建


## 非线程安全

```go
// 在多线程下可能会创建多次对象

// 类
type Tool struct {
    value int
}

// 私有变量
var instance *Tool

func GetInstance() *Tool {
    if instance == nil {
        instance = new(Tool)   // not thread safe
        instance.value = 666
    }
    return instance
}

```

## 加锁
* Sync.Mutex进行加锁,保证线程安全，但由于每次调用该方法都进行了加锁操作，在性能上相对不高效

```go

// 类
type Tool struct {
    value int
}

// 私有变量
var instance *Tool

// 锁对象
var m sync.Mutex

func GetInstance() *Tool {
    m.Lock()
    defer m.Unlock()
    if instace == nil { 
        instance = new(Tool)  // unnecessary locking if instance already created
    }
    // m.Unlock()
    return instance
}

```
## 双重检查模式
* 不懂为什么需要判断两次
* 是安全懒汉式的基础上进行改进,
```go
// 判少加锁的操作,保证线程安全同时不影响性能 

type Tool struct {
    value int
}

var instance *Tool
var m sync.Mutex

// 还并不是很完美。因为编译器优化没有检查实例存储状态
func GetInstance() *Tool {
    if instance == nil {   // <-- Not yet perfect. since it's not fully atomic
        m.Lock()
        if instace == nil {
            instance = new(Tool)
        }
        m.Unlock()
    }
}

// 另一种标记优化 -----------------------------

// 用sync/atomic包的话 就可以自动帮我们加载和设置标记。

// 标记设置
var initialized uint32

func Getinstance() *Tool {
    
    if atomic.LoadUint32(&initalized) == 1 {
        return instance
    }

    m.Lock()
    if instance == nil {
        instance == new(Tool)
        atomic.StoreUint32(&initialized,1)
    }
    m.Unlock()
    return instance
}


```


## sync.Once
* sync.Once结构体，该结构体提供了一个Do方法，
* Do函数里面的函数只有在第一次才会被调用，该方法只会生成一个实例，且也是线程安全的。 
* Do 内部本质上也是双重检查的方式，但在写法上会比自己写双重检查更简洁

```go

type Tool struct {
    value int
}

var instance  *Tool
var once sync.Once

func GetInstance() *Tool {
    
    once.Do(
        func(){
            instance = new(Tool)
        }
    )
    return instance
}

// Do 函数-----------------------

func (o *Once) Do(f func()) {
　　　//判断是否执行过该方法，如果执行过则不执行
    if atomic.LoadUint32(&o.done) == 1 {
        return
    }
    // Slow-path.
    o.m.Lock()
    defer o.m.Unlock()
　　//进行加锁，再做一次判断，如果没有执行，则进行标志已经扫行并调用该方法
    if o.done == 0 {
        defer atomic.StoreUint32(&o.done, 1)
        f()
    }
}


```

## 参考
```go
https://www.jianshu.com/p/d2fc1c998fc9

```