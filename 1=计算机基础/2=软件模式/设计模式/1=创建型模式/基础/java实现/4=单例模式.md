# 执行逻辑

```java
懒汉式
    代码块 - 线程不安全
    同步方法 - 线程安全
    代码块同步 - 线程安全
    //===================== 
    静态内部类
    双重检查
饿汉式
    静态常量
    静态代码块
    枚举类
//===========================================================
流程    
    // 流程都一样，关键在于 在什么时候，什么地方进行 new 自身实例
    0. 首先私有化构造方法， 不能外部进行创建
    1. 创建一个自身的静态成员， 
    不同方式的区别在于： new 自身实例的时候是在：什么地方进行成员赋值
    2. 提供一个静态方法获取静态变量的实例
    
    
懒汉式
    在获取实例的方法中： 调用 获取方法的时候 new
    // 代码块
	     在 if 代码块中判断该实例不存在，则进行 new
    // 同步方法
		 对获取方法加一个 synchronized 关键字
	// 代码块同步            
    	 if 内部对类进行 synchronized 修饰限制，然后再进行创建
	// 静态内部类            
		 再创建一个静态内部类， 在这个静态内部类中进行成员声明，初始化 new             
	// 双重检查  
          代码块同步的基础上，对 new 实例再进行一次非空判断
饿汉式
	在获取实例方法之前: 在调用 获取方法之前就 new
    //  静态常量    	
        静态变量声明处： new 自身实例赋值
    // 静态代码块
        静态代码块中： new 自身实例赋值
```



# 懒汉式

## 代码块 -- 线程不安全

```java


public class Main {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2);
    }
}


class Singleton {
    
    private Singleton() {}  
    
    
    private static Singleton instance;

    // 提供一个静态的共有方放，当使用该方法的时候， 才创建 instance
    // 取得getinstance 的时候，会有多个线程同时得到这个方法进行访问
    public static Singleton getInstance(){
        if (instance == null) {
            instance = new Singleton();
        }
        return  instance;
    }
}


理解
    1. 在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，
    2. 当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果
    3. 但是，如果是多线程环境，会出现线程安全问题。
```

## 同步方法 -- 线程安全

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公有方法， 加入同步处理的代码，解决线程安全的问题
    // 懒汉模式
    public static synchronized Singleton getInstance(){
        if (instance == null) {
            instance = new Singleton();
        }
        return  instance;
    }
}

// 问题

1. 解决线程不安全的问题
2. 效率太低了， 每个线程要想获得类的实例的时候， 执行 getInstance 方法都要进行同步，
    但是这个方法只用执行实例化一次就够了，后面向获得该类的实例， 直接 return 即可
3. 不推荐使用
```

## 代码块同步 -- 线程安全

```java
// 同步机制放到了代码块中
// 无法实现线程安全， 没有意义
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公有方法， 加入同步处理的代码，解决线程安全的问题
    // 懒汉模式
    public static  Singleton getInstance(){
        if (instance == null) {
            synchronized (Singleton.class){
               instance = new Singleton();
            }
        }
        return  instance;
    }
}
// 优缺点

1. 这种方法是对第四种方法的改进， 因为前面同步方法效率太低
2. 但是这种方法并不能实现线程同步的作用 ， 
    一个线程进入 if 代码块， 还没有来的及往下执行， 其他线程也会通过这个判断语句产生更多的实例
```

## // ===

## 静态内部类

```java
// 静态内部类
class Singleton {
    private Singleton() {}

    // 类装载的时候 ， 方法使用到该类，使用 jvm 内部装载类的线程安全机制 ，来控制线程安全
     public static  class Singleton_Instance {
         // final 进行底层优化
         private static final Singleton INSTANCE  = new Singleton();
     }
    
    // 提供一个静态的公有方法， 加入同步处理的代码，解决线程安全的问题
    // 懒汉模式
    public static  Singleton getInstance(){
        return  Singleton_Instance.INSTANCE;
    }
}
// 优缺点
1. 使用类装载的机制来保证初始化实例的时候只有一个线程
2. 静态内部类在 Singleton 类装载的时候不会被立即实例化， 在需要的时候进行装载，完成实例化
3. 类的静态属性只会在第一次加载类的时候进行实例化， 利用 JVM 保证线程安全，保证其他线程无法进入
4. 利用静态内部类的特点实现延迟加载， 效率高 ，表面线程不安全
    推荐使用
```



## 双重检查



```java
// 解决线程安全、懒加载、同时保证了效率
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    }

    // 提供一个静态的公有方法， 加入同步处理的代码，解决线程安全的问题
    // 懒汉模式
    public static  Singleton getInstance(){
        if (instance == null) {
            // 只能有一个线程进来
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();                       
                }
            }
        }	
        return  instance;
    }
}

// 
1. 常用方法 ，两次 instance == null 判断， 这样保证线程安全
2. 实例化代码只执行一次 ，后面再访问 ， 判断后直接返回实例
```



# 饿汉式

## 静态常量

```java
/**
 * 饿汉式
 *      静态变量创建类的对象
 */
public class Singleton {
    //私有构造方法
    private Singleton() {}

    //在成员位置创建该类的对象
    private static Singleton instance = new Singleton();

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return instance;
    }
}

介绍
    instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。
```





## 静态代码块

```java
package cn.it.day02;

public class Single {
    public static void main(String[] args) {
        //
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance2 == instance);
    }
}

class Singleton {
    // 构造器私有化， 不能够 new 
    private Singleton(){}

    // 成员属性 , 本类内部创建对象实例
    private static final Singleton;
    // 实例对象化
    static {
         instance = new Singleton();
    }

    //3. 提供一个静态方法 ， 返回实例
    public static final Singleton getInstance() {

        return instance;
    }
}
```







## 枚举类

```java
public class Single {
    public static void main(String[] args) {
        //
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance2 == instance);  // true
    }
}

enum Singleton {
    INSTANCE;
    public void method(){
        // 方法体
    }
}

// 推荐使用
1. jdk1.5 进行单例模式 ， 避免多线程问题， 而且能防止反序列化重新创建对象的问题
```



