## 三种工厂模式的区别

* 工厂模式

    ```java
    个人理解
        是把对象的创建集中起来的一种模式
        你仍可以单独进行对象创建，但是你把对象创建集中到一个类当中，方便查看管理
    工厂
        无分类： 
        	简单工厂模式（不属于GOF的23种经典设计模式）
        有分类：
        	 工厂模式
              抽象工厂模式
    ```

*   简单工厂模式
    *   将所有对象的创建都集中到一个类中：
    *   在类的一个方法中，通过传参，返回不同的实例
    *   更多是一种编程习惯
    
*   工厂模式
    
    *   一个集合类只创建一个对象
    
*   抽象工厂
    
    *   一个集合类创建多个对象
    
* 扩展
    * 静态工厂
        *   创建对象的方法是静态方法



## 简单工厂

### 概念

```java
英文
   simple factory pattern
个人理解
    将对象的创建集中到一个类中的方式
```

### 模式结构

```java
角色定义
    抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。
    具体产品 ：实现或者继承抽象产品的子类
    具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。  

// 抽象产品 interface  具体产品 class
    需要的实例类
// 具体工厂 class
	进行实例创建的类
// 运行逻辑
	在 工厂类的方法中， 返回创建的实例 return new xxx();
```



### 应用场景

  *  工厂类负责创建的对象比较少：
     * 由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 
  *  客户端只知道传入工厂类的参数，对于如何创建对象不关心：
     * 客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 

### 优点

*   可以通过参数直接获取对象
    *   把对象的创建和业务逻辑层分开, 降低耦合
*   新建其他类容易
    *   直接修改工厂类，而不需要在原代码中修改

### 缺点

*   工厂集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
*   产品类型较多时，一定程序上增加了系统的复杂度和理解难度，工厂方法代码将会变得非常复杂 ，不利于系统的扩展和维护。
*   增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。



## 工厂模式

### 概念

```java
英文：Factory Pattern
个人理解： 一个类创建一个实例
    
```

### 模式结构

```java
// 抽象工厂 interface  具体工厂 class
用来创建对象，
    
// 抽象产品 interface  具体产品  class
对象的业务逻辑
    
// 运行逻辑
    在 工厂类的方法中， 返回创建的实例 return new xxx();
	但是一个工厂只能产生一个实例，
    需要返回多个不同的实例，就需要多个工厂类
 
        
// 角色定义
1.  抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
2.  具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
3.  抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
4.  具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。        
```



### 应用场景

* 我们明确地计划不同条件下创建不同实例时。

* 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方

* 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口

* 数据库访问：当用户不知道最后系统采用哪一类数据库

    

    



### 优点

*   一个调用者想创建一个对象，只要知道其名称就可以了。  
*   扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
*   屏蔽产品的具体实现，调用者只关心产品的接口。

### 缺点

*   每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，同时也增加了系统具体类的依赖
*   使用工厂就要引入一个工厂类,增加系统的复杂度



## 抽象工厂模式

### 概念

```java
名称
    Abstract Factory Pattern 
    别称： kit 模式
个人理解
    一个类可以创建多个不同的实例（手机、手表）
```

### 模式结构

```java
// 抽象工厂 interface  具体工厂 class
用来创建对象，
    
// 抽象产品 interface  具体产品  class
对象的业务逻辑
    
// 运行逻辑
    在 工厂类的方法中， 返回创建的实例 return new xxx();
	但是一个工厂中：可以含有多个创建实例的方法，即可以创建多个实例


角色定义
1.  抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
2.  具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3.  抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4.  具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。    
```

### 优点

* 产品族聚集设计，能保证客户端始终只使用同一个产品族中的对象。

* 产品族管理 -- 共同管理，而不必专门引入多个新的类来进行管理。

    

*   当增加一个新的产品族时不需要修改原代码，扩展有一定的“开闭原则”倾斜性
    *   当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
    *   当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。

### 缺点

*   当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

### 使用场景

* 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。

* 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。

* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

## 静态工厂

```java
就是简单工厂产生对象的方法是静态的
```







