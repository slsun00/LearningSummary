## 三种工厂模式的区别

*   简单工厂模式
    *   一个工厂类生产所有的产品
    *   工厂根据参数决定生产哪一个产品
*   工厂模式
    *   抽象出来一个工厂类，多个工厂继承(实现)这个抽象工厂类
    *   一个工厂只负责一个产品
*   抽象工厂
    *   在工厂模式的基础上
    *   一个工厂可以创建多个产品，这样的多个产品构成一个产品族
*   三种结构是可以相互转化的



## 简单工厂

### 概念

* 英文
    * simple factory pattern
* 别称
    *   静态工厂方法（ static factory method ）
* 实质
    * 一个工厂生产所有的产品，
    * 一个工厂对象决定创建出哪一个产品类的实例
    * 定义了一个可以创建对象类， 这个类来封装实例化对象的行为

### 应用场景

  *  工厂类负责创建的对象比较少：
     * 由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 
  *  客户端只知道传入工厂类的参数，对于如何创建对象不关心：
     * 客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 

### 优点

*   工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可 
*   现对象的创建和对象的使用 ( 对象本身业务处理 ) 分离
    *   降低系统的耦合度，使得两者修改起来都相对容易

### 缺点

*   工厂集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
*   产品类型较多时，一定程序上增加了系统的复杂度和理解难度，工厂方法代码将会变得非常复杂 ，不利于系统的扩展和维护。
*   增加新产品时会违背“开闭原则”



## 工厂模式

### 概念

*   英文
    *   Factory Pattern
*   实质
    *   一个工厂可以生产多个产品



### 意图

*   定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类
*   工厂模式使其创建过程延迟到子类进行。
*   让其子类实现工厂接口，返回的也是一个抽象的产品。

### 关键代码

*   创建过程在其子类执行。

### 应用场景

*   我们明确地计划不同条件下创建不同实例时。

*   日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方

*   设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口

*   数据库访问：当用户不知道最后系统采用哪一类数据库

    

    



### 优点

*   一个调用者想创建一个对象，只要知道其名称就可以了。  
*   扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
*   屏蔽产品的具体实现，调用者只关心产品的接口。

### 缺点

*   每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，同时也增加了系统具体类的依赖
*   使用工厂就要引入一个工厂类,增加系统的复杂度

### 模式结构

1.  抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
2.  具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
3.  抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
4.  具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。



## 抽象工厂模式

### 概念

*   Abstract Factory Pattern 
*   别称

    *  Kit 模式 
*   属于：对象创建型模式
*   就是在工厂模式的基础上，实现一个工厂介意生产一个产品族，让一个工厂综合了起来

*   提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类 



### 应用场景

*   使用条件

    ```go
    一个工厂里聚合多个同类产品,构成一个产品族
    
    系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
    系统一次只可能消费其中某一族产品，即同族的产品一起使用。
    ```

    

*   最早的应用是用于创建属于不同操作系统的视窗构件

    ```go
        当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
        系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
        系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。
    ```

    

    

### 模式

1.  抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
2.  具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3.  抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4.  具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。



### 优点

*   可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
*   当增加一个新的产品族时不需要修改原代码，扩展有一定的“开闭原则”倾斜性
    *   当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
    *   当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。

### 缺点

*   当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。





