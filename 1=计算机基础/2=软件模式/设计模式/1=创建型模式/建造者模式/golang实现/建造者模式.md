```go
1.Product 需要创建的复杂对象    : 电脑

2.Builder 用来规范建造者  		： 电脑组装方式

3.ConcreteBuilder 具体的Builder实现，主要用来根据不用的业务来创建对象的所有组件。   ： 具体电脑配置

4.Director 用来规范复杂对象的创建流程。    ：组装人员

5.组装人员拿着电脑组装方式，就可以进行电脑配置

struct computer    :Product
	Lenove struct
	Asus struct
interface  IPCFactory    :Builder
 Workman struct
```





```GO

// 产品
// computer 有好多个参数
type Computer struct {
	Mainframs string
	Screen    string
	Mouse     string
}

// 抽象工厂,包含产品各个不仅的抽象方法，通常还有一个返回产品的方法
// 没有 set 生产组件的方法 , 跟工厂方法无异
type IPCFactory interface {
	SetMainframes() string
	SetScreen() string
	SetMouse() string
	ProduceComputer() *Computer
}

// 具体的工厂, 就是 concretebuilder
// 联想工厂专门生产联想电脑
type Lenove struct{}

// 部件生产
func (l *Lenove) SetMainframes() string {
	return "联想的主机"
}

func (l *Lenove) SetScreen() string {
	return "联想屏幕"
}

func (l *Lenove) SetMouse() string {
	return "联想鼠标"
}

// 联想电脑组装
func (l *Lenove) ProduceComputer() *Computer {
	pc := new(Computer)
	pc.Mainframs = l.SetMainframes()
	pc.Mouse = l.SetMouse()
	pc.Screen = l.SetScreen()
	return pc
}

// 华硕电脑
type Asus struct{}

// 电脑配件生产
func (a *Asus) SetMouse() string {
	return "华硕的鼠标"
}

func (a *Asus) SetScreen() string {
	return "华硕的屏幕"
}

func (a *Asus) SetMainframs() string {
	return "华硕的主机"
}

// 电脑组装
func (a *Asus) ProduceComputer() *Computer {
	pc := new(Computer)
	pc.Mainframs = a.SetMainframs()
	pc.Mouse = a.SetMouse()
	pc.Screen = a.SetScreen()
	return pc
}

// 装机人员掌控者抽象工厂进行组装
// 拿着抽象工厂中的组装方法进行组装
type Workman struct {
	method IPCFactory
}

// combination computer
func (w *Workman) ComComputer() *Computer {
	return w.method.ProduceComputer()
}

func main() {

	// 具体牌子的电脑,但是没有零件，这只是个空壳
	// 也可以理解成，需要进行组长的电脑，需要装机人员来填充零件
	lenove := new(Lenove)
	fmt.Println(lenove)  // &{}

	// 装机人员根据电脑牌子进行具体的装机
	Works := &Workman{lenove}
	fmt.Println(Works.ComComputer()) // &{联想的主机 联想屏幕 联想鼠标}

}

```

