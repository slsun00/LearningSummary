## 介绍

* 从程序结构上实现松耦合
* 扩大整体类结构

## 分类

*   类结构型模式
    *   采用继承机制来组织接口和类
        *   适配器模式
*   对象结构型模式
    *   采用组合和聚合来组合对象
        *   所有模式

## 介绍

*   代理（Proxy）
    *   复制一份原对象
    *   为某对象提供一种代理以控制对该对象的访问
    *   即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
    
*   适配器（Adapter）
    *   将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

*   桥接（Bridge）
    *   将抽象与实现分离，使它们可以独立变化。
    *   它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。

*   装饰（Decorator）
    *   动态地给对象增加一些职责，即增加其额外的功能。

*   外观（Facade）
    *   为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

*   享元（Flyweight）
    *   运用共享技术来有效地支持大量细粒度对象的复用。

*   组合（Composite）
    *   将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。



```go
和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 
```





## 小结

*   即：怎么处理两部分进行连接，解决复用的问题  

代理模式 ： 

*   复制
*   代理者和被代理者都实现了相同的接口
*   加以控制
*   一对一，这个代理只能代表一个对象；
*   只能代理一方，也就是 PB 是B的代理，A能够通过PB访问B，但是B不能通过PB访问A；



适配器模式：

*   配适器模式： 创造中间件，连接两部分，引用封装不适应的部分

桥接模式;

*     一对多的关系，一个类可以有很多其他属性；
*   桥接夸大不是对象之间的通信，而是拥有某些属性；

中介模式

*   对多，这些被管理的对象之间都可以通信，它们的业务关系应该是交织在一起的
*   A能够通过中介访问B，B也能够通过中介访问A；

```go

中介者模式和代理模式比较相似，他俩夸大的是通信，桥接模式夸大的时候拥有属性；

    

2. 中介者模式是多对多通信，代理是一对一通信，桥接是一对多；

    

3. 代理是通信只能从一方到另外一方，中介者是双向都可以通信；
```



*   适配器、桥接模式、外观模式

    ```go
    桥接和适配器都是让两个东西配合工作
    
    1）适配器改变已有的两个接口，让他们相容。
    		先有两边的东西，才有适配器
    		如果你拿到两个已有模块，想让他们同时工作，那么你使用的适配器
    
    2）桥接模式：分离抽象化和实现，使两者的接口可以不同，目的是分离。
    		先有桥，才有两端的东西
    		如果你还什么都没有，但是想分开实现，那么桥接是一个选择。
    
    1. Facade 模式使用在给一个复杂的系统提供统一的门面(接口),目的是简化客户端的操作,但并没有改变接口.
    2. Adapter 模式使用在两个部分有不同的接口的情况,目的是改变接口,使两个部分协同工作
    3. 桥接模式 是为了分离抽象和实现
    
    1. Facade的需求程度是  "中等"  ,因为你不提供Facade程序照样能工作,只是不够好.
    2. Adapter的需求程度是  "必须"  ,因为你不这么做就不能工作,除非你自己从头实现一个.
    3. Bridge的需求程度是  "一般"  ,适合精益求精的人,因为你可以写三个程序给客户.
    
    1. Facade出现在项目中期,再优化
    2. Adapter出现在项目后期,大部分都有了,差的仅仅是接口不同
    3. Bridge出现在项目前期,你想让你的系统更灵活,更cool
    ```

    



*   代理模式 适配器模式 门面模式

    ```go
    https://blog.csdn.net/Xiaowu_First/article/details/97346398
    
    适配器
    	适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，但是，由于旧的接口是不能被完全重构掉的，因为我们还想使用实现了这个接口的一些服务。那么为了使用以前实现旧接口的服务，我们就应该把新的接口转换成旧接口；实现这个转换的类就是抽象意义的转换器；
    
    代理模式
    	代理提供的接口和原本的接口是一样的，代理模式的作用是不把实现直接暴露给client，而是通过代理这个层，代理能够做一些处理；
    	为其他对象提供一种代理以控制对这个对象的访问。客户访问不到被代理对象，可以通过代理对象间接的访问；代理对象可以对上次的访问结果进行缓存，下次有相同的请求时可以直接返回缓存而不用去访问被代理对象；代理对象可以拒绝没有访问权限的用户，使其不能访问被代理对象；
    
    门面模式
    	为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，简化了系统的使
    ```

*   装饰器  代理

    ```go
    装饰器模式
    	关注于在一个对象上动态的添加方法，
    	使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。
    	装饰者能够在运行时递归地被构造
    
    
    代理模式
    	关注于控制对对象的访问
    	代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例
    	，代理和真实对象之间的的关系通常在编译时就已经确定了
    ```

    

## 参考

```go
https://blog.csdn.net/xiefangjin/article/details/51056411
```



## 总结

```java
适配器模式：类转换（两个不同类的间接转换）

装饰器模式：类方法（每个方法的功能，而不是数量的扩充）
代理模式： 类访问（类访问控制），类替代，没有其他操作
    
桥接模式： 使用接口
外观模式： 使用组合

组合模式：集合中存放以后创建的对象
享元模式：集合中存放创建好复用的对象
    
```







































代理模式：类访问控制

适配器模式：两个不同类的间接转换

装饰器模式：类方法宽度(单个方法的功能，而不是数量)的扩充

桥接模式： 使用接口

外观模式：使用组合

组合模式： 

享元模式：实例对象复用