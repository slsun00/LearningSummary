## 定义：

* 又叫调停模式，

* 定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。

* 改变网状结构为星状结构

    ![image-20200214110924010](image-20200214110924010.png)



## 结构

```java
1. 网状结构转变为形状结构
// 抽象中介者 interface  具体中介者 class
房屋中介：
// 抽象同事类 interface   具体同事类 class
房东 租客    

// 运行逻辑
房屋中介
    联系： 将租客、房东内嵌进来，让其交互在该类内部进行
租客、租客
	// 房东和租客进行信息交互， 但是 两个类的通信逻辑 是在 中介者内部执行的
    联系中介： 
    	内嵌中介成员变量，调用中介的方法    
    传递自己：
    	在调用响应的的方法的同时，
    	将自己传递到中介中，在中介中执行，实现在中介中交互
```

* 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。

* 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
* 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
* 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

## 优缺点

**1，优点：**

* 松散耦合

    中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。

* 集中控制交互

    多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。

* 一对多关联转变为一对一的关联

    没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。

**2，缺点：**

当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。



## 使用场景

* 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。
* 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。

