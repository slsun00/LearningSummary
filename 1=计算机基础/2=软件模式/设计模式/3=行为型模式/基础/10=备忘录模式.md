##  备忘录模式

*  Memento
*  别名
    *  快照模式（Snapshot Pattern） 
    *  Token模式 
*  属于行为型模式。 
*  保存一个对象的某个状态，

## 模式应用

*  需要保存/恢复数据的相关状态场景
*  提供一个可回滚的操作。 
*  多状态的 
    *  一个对象有一个对应的备忘对象，记录对象中要备忘的字段，而多个对象的备忘，同一由同一个负责人进行管理，可以用 `map` 来做到这一点 
    *  负责人中的备忘容器是一个`map`类型的数据，值是一个实现备忘接口的数据结构即可。 
*  实例
    * 后悔药。 
    * 打游戏时的存档。 
    * Windows 里的 ctri + z。
    * IE 中的后退
    * 数据库的事务管理。 

## 模式扩展

1、为了符合迪米特原则，还要增加一个管理备忘录的类。 

2、为了节约内存，可使用原型模式+备忘录模式。 

## 模式结构

```java
// 备忘录
	一个结构体，可以理解为一个对象，用来存储一个对象的数据信息
    这个数据信息记录的就是一个状态
    // 有两个接口
        Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。
        Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据

// 发起人
	需要被记录的主体        
	
// 管理者
	用来处理备忘录，进行备忘录的增删改查    
        
// 分类
// 黑箱中 备忘录是在 记录着内部的，        
“白箱” 备忘录模式
	 备忘录是一个类，内涵发起人的具体信息
      管理者是可以直接管理这个具体的备忘录类，
“黑箱” 备忘录模式        
     备忘录是发起人的内部类，但是仍实现了了备忘录接口
	 管理者只是管理一个备忘录接口，并不知道具体类的实现在哪里
```

* 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
* 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
    * 备忘录有两个等效的接口：

    * **窄接口**：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。
    * **宽接口**：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。
* 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进

* 调用流程

    ```go
    originator 将自身的一个状态存入 memento(状态对象化) ， 然后 caretaker 拿到这个状态存入自身
    其实就是 originator 到 caretaker 之间通信，将通信信息封装成一个 struct 进行传递
    ```





## 分析

### 模式动机

*  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便在适当的时候恢复对象。
*  记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。 
*  通过一个备忘录类专门存储对象状态。  

## 优缺点

**1，优点：**

- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。

**2，缺点：**

* 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。



## 使用场景

* 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。

* 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。

