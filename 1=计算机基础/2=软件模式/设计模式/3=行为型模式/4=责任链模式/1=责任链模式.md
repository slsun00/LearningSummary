## 责任链模式

* Chain Of Responsibility
* 属于行为型模式。 
* 为请求创建了一个接收者对象的链，每个接收者都包含对另一个接收者的引用，当某个接受者不能处理该请求时，会将该请求转给下一个接受者处理 
* 类似职责链模式的例子，比如我们在公司请假需要填写电子流给各个领导审批，如果请假时长比较短的时候，你的直属领导就有权力决定是否同意你请假，但是如果时间比较长的话，那就要给更高一层的领导审批了，类似的还有加薪申请也是一样的情况。 

## 分析

  ### 动机

  *   使多个对象都有机会处理请求，,避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求
  *   职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 
      *   在处理消息的时候以过滤很多道。 
      *   拦截的类都实现统一接口。 
  *   关键点
      *  Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。
      *  责任链可能是一条直线，一个环链甚至一个树结构的一部分  

### 优点

  *  降低耦合度。它将请求的发送者和接收者解耦。
  *  简化了对象。使得对象不需要知道链的结构。 
  *  增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
  *  增加新的请求处理类很方便。 

### 缺点

  * 不能保证请求一定被接收。
  * 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
  * 可能不容易观察运行时的特征，有碍于除错。
  * 当责任链的链结构比较长比较复杂的话，会产生很多内存垃圾对象，他们在实际处理中，并没有发挥任何的作用。  

## 模式使用

  * 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 
  * 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 
  * 可动态指定一组对象处理请求。 
  * 实例
    *  报销流程，项目经理<部门经理<总经理 
    *  红楼梦中的"击鼓传花"。 

## 模式扩展

* 链表结构结合

## 模式结构

*   调用流程

    ```js
    处理消息的时候，进行链式调用,链式处理
    ```

![责任链(1)](%E8%B4%A3%E4%BB%BB%E9%93%BE(1).jpg)

## 实现

### golang实现



```go
type Manager interface{
    Setnext(manager *Manager)    //  设置责任链的下一个对象，保证责任链的连续
    RequestHandler(request *Request)	// 消息处理过滤
}

type CommonManager struct {
    next *Manager   // 可以直接使用 Manager ，
}

func (c *CommonManagerr) SetNext(manager *Manager) {
    m.next = manager
}
func (c *CommonManager) RequestHandler(request *Request) {
    if request.RequestType == "请假" {
        fmt.Println("组长批准请假")
         m.next.RequestHandler(request)	// 传给责任链的下一个
    } else if request.RequestType == "加薪" {
        fmt.Println("组长批准加薪")
        m.next.RequestHandler(request)	// 传给责任链的下一个
    } else if request.RequestType == "辞职" {
        if request.content == "回家玩" {
              fmt.Println("组长拒绝跟你说话，不让你回家玩")
        } else {
            fmt.Println("组长批准辞职")
            m.next.RequestHandler(request)  // 传给责任链的下一个
        }   
    }
}
  
type GeneralManager struct {
    next *Manager   
}

func (g *GeneralManager) SetNext(manager *Manager) {
    g.next = manager
}
func (g *GeneralManager) RequestHandler(request *Request) {
	
    if request.RequestType == "加薪" {
        fmt.Println("经理批准加薪")
        g.next.RequestHandler(request)	// 传给责任链的下一个
    } else if request.RequestType == "辞职" {
         fmt.Println("经理批准辞职")
        g.next.RequestHandler(request)  // 传给责任链的下一个
        }   
    }
}

type MaforlManager struct {
    next *Manager   
}

func (m *MaforlManager) SetNext(manager *Manager) {
    m.next = manager
}
func (m *MaforlManager) RequestHandler(request *Request) {
	 if request.RequestType == "辞职" {
         fmt.Println("主管批准辞职")
         g.next.RequestHandler(request)  // 传给责任链的下一个
        }   
    }
}


type Request struct {
    RequestType string
    RequestContent string
}
```

*   调用

    ```go
    func main(){
        a := new(CommonManager)
        b := new(GernerManager)
        c := new(MajorManager)
        // 创建责任链
        a.SetNext(b)
        b.SetNext(c)
        // 创建请求
        request := new(Request{"辞职","回家玩儿"})
        a.RequestHandler(request)
        
    }
    ```

    

## 出现错误

```go
package main

import (
	"fmt"
)

type Manager interface {
	Setnext(manager Manager)        
	RequestHandler(request *Request) // 消息处理过滤
}

type CommonManager struct {
	next Manager // 可以直接使用 Manager ，
}

func (c CommonManager) SetNext(manager Manager) {
	c.next = manager
}

func (c CommonManager) RequestHandler(request *Request) {
	if request.RequestType == "请假" {
		fmt.Println("组长批准请假")
		c.next.RequestHandler(request) 
	} else if request.RequestType == "加薪" {
		fmt.Println("组长批准加薪")
		c.next.RequestHandler(request) 
	} else if request.RequestType == "辞职" {
		if request.RequestContent == "回家玩" {
			fmt.Println("组长拒绝跟你说话，不让你回家玩")
		} else {
			fmt.Println("组长批准辞职")
			c.next.RequestHandler(request) // 传给责任链的下一个
		}
	}
}

type GeneralManager struct {
	next *Manager
}

func (g *GeneralManager) SetNext(manager Manager) {
	g.next = manager
}

func (g *GeneralManager) RequestHandler(request *Request) {

	if request.RequestType == "加薪" {
		fmt.Println("经理批准加薪")
		g.next.RequestHandler(request) // 传给责任链的下一个
	} else if request.RequestType == "辞职" {
		fmt.Println("经理批准辞职")
		g.next.RequestHandler(request) // 传给责任链的下一个

	}
}

type MaforlManager struct {
	next *Manager
}

func (m *MaforlManager) SetNext(manager *Manager) {
	m.next = manager
}
func (m *MaforlManager) RequestHandler(request *Request) {
	if request.RequestType == "辞职" {
		fmt.Println("主管批准辞职") // 主管是最后一个，不用设置下一个，
	}
}

type Request struct {
	RequestType    string
	RequestContent string
}

func main() {

}

```



