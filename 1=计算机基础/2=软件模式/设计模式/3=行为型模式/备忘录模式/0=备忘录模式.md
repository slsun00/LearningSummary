##  备忘录模式

*  Memento
*  别名
    *  快照模式（Snapshot Pattern） 
    *  Token模式 
*  属于行为型模式。 
*  保存一个对象的某个状态，

## 模式应用

*  需要保存/恢复数据的相关状态场景
*  提供一个可回滚的操作。 
*  多状态的 
    *  一个对象有一个对应的备忘对象，记录对象中要备忘的字段，而多个对象的备忘，同一由同一个负责人进行管理，可以用 `map` 来做到这一点 
    *  负责人中的备忘容器是一个`map`类型的数据，值是一个实现备忘接口的数据结构即可。 
*  实例
    * 后悔药。 
    * 打游戏时的存档。 
    * Windows 里的 ctri + z。
    * IE 中的后退
    * 数据库的事务管理。 

## 模式扩展

1、为了符合迪米特原则，还要增加一个管理备忘录的类。 

2、为了节约内存，可使用原型模式+备忘录模式。 

## 模式结构

*   Originator

    ```go
    // 发起人
        负责创建一个备忘录Memento，用以存储当前时刻自身的内部状态，并可以使用备忘录恢复内部状态
        Originator可根据需要决定Memento存储Originator的那些内部状态
    ```

* memento

    ```go 
    // 备忘录
    负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。
    包含了要被恢复的对象的状态
    有两个接口
    	Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。
    	Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。
    ```
    
* caretaker

    ```go
    // 管理者
    负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。
    负责从 Memento 中恢复对象的状态。
    ```

* 调用流程

    ```go
    originator 将自身的一个状态存入 memento(状态对象化) ， 然后 caretaker 拿到这个状态存入自身
    其实就是 originator 到 caretaker 之间通信，将通信信息封装成一个 struct 进行传递
```
    

### golang实现

![备忘录模式](%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png)

*   originator

    ```go
    type Originator struct {
        state string
    }
    
    func (o *Originator) setstate(state string){
        o.state = state
    }
    
    // 保存自身的一个状态，结构化为 Memento
    func (o *Originator) SavaStateToMomento(mememto *Memento) *Memento {
        memento.sate = o.state
        return memento
    }
    
    // 回复状态
    func (o *Originator) GetStateFromMomento(memento *Memento){
        o.State = memento.state
    }
    ```

*   memento

    ```go
    // 这个结构是记录 originator 的状态的，所以其字段应该能详细描述应该存储的状态
    type Memento struct {
        state string
    }
    
    // 这个是否需要有对应的方法，看具体怎么设计把，为了体现 memento 不操作状态，就不涉及方法了
    // 这个说白了就是一个存储消息的结构
    ```

*   caretaker

    ```go 
    type CareTaker struct {
        mementors []*Memento
    }
    
    // AddMemento 记录新的状态
    func (c *CareTaker) AddMento(memento *Memento) {
        c.mementors = append(c.mementors,memento)
    }
    ```

*   调用

    ```go
    // 注意调用流程
    func main(){
        orignator := new(Orignator)
        careTaker := new(CareTaker)
        // 开始流程
        orignator.SetSate("666")
        // 记录状态
        memento := new(Memento)
        orignator.SaveSateToMento(memento)
        // 管理者记录状态
        careTaker.AddMemento(memento)   
    }
    ```

    

## ------------------------------------

## 分析

### 模式动机

*  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便在适当的时候恢复对象。
*  记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。 
*  通过一个备忘录类专门存储对象状态。  

### 优点

*  给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。

* 实现了信息的封装，使得用户不需要关心状态的保存细节。

*  客户不与备忘录类耦合，与备忘录管理类耦合。   发起人只需要提供备忘数据，不需要对其进行管理 

* 备忘录模式仅做数据备忘，不论该数据是否正确。

    ```go
    1、有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，
    使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。
    2、本模式简化了发起人。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需
    要的这些状态的版本。
    3、当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原
    ```




### 缺点

*  消耗资源。

    * 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 

* 备忘录模式大多是多状态的，如果进行大量备忘的话，会占用大量内存，当然，如果持久化在磁盘中的话，会减少内存占用，但会增加IO操作，这就需要开发者根据实际业务情况进行取舍了。

    ```go
    1、如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。
    2、当负责人角色将一个备忘录 存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。
    3、当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。
    ```

    

