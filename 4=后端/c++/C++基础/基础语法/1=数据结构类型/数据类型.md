## 数据类型

*   不同的标准分类就不一样，详细看类型分类

## 注意

```go
所有的语法中
	// 只是方便记录，用于文档书写
	Type  表示 go 中的所有数据类型，就是下面基础+复杂数据结构中的类型

```

## 分类

### 介绍

```js
变量类型和数据类型是一样的，只不过看的角度不一样而已
```

### 数据类型

*   基础数据类型

    ```go
    // 数值 
        整数(IntegerType)
            int int8 int16 int32 int64 
            uint uint8 uint16 uint32 uint64
        浮点(floatType)  
            float32 float64
        复数(complexType)
            complex32 complex64
    // 文本
        字符型		
    		byte
        字符串 ：中英文字        
    		string 
    // 布尔
        布尔型：真假            
            bool
    // 注意
    	uint8别称        byte          强调数值是一个原始的数据而不是一个小的整数
        int32别名        rune          Unicode字符  
    ```

*   高阶数据类型

    ```js
    // 面向对象(代码块在{})
    	函数		func
    	结构体		struct
    	接口		interface
    // 并发
    	通道/管道(channel)	chan Type
    
    // 其他类型
        指针		*Type
        数组       []Type                
        切片		[size]Type
        集合		map[]Type      
    ```

### 变量类型

| 类型     |                             作用                             | 内存分配 |                                                              |
| -------- | :----------------------------------------------------------: | -------- | ------------------------------------------------------------ |
| 值类型   |      变量直接存储值，<br>都有对应的指针类型(*数据类型)       | 栈中分配 | 数值型      字符型      布尔型      字符串           结构体    数组 |
| 引用类型 | 变量存储的是一个地址，这个地址<br/>对应的空间才真正存储数据(值)，<br/>内存通常在。当没有任何变量引用这个地址时，<br/>该地址对应的数据空间就成为一个垃圾，由GC来回收 | 堆上分配 | 指针  slice   map(映射)   chan    interface 函数             |



## 类型检测c

```c++
sizeof 关键字
	检测数据类型占用内存的大小
	语法
		sizeof(数据类型/变量) : sizeof(a)
```





## 类型转换

```go
注意
	Go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：
语法
    // 将 类型 A 的值转换为类型 B 的值
	Type_B = Type_B(Type1_A_variable)
	Type_B = Type_B(Type1_A_value)
	// 注释
		Type 和 Type1 ：表示go中的任意两种变量，Type1不同于Type
		Type_B  : 一种类型的变量
		Type1_A_variable：一种类型的变量的字面值


//注意
1.类型转换可以从大范围到小范围，也可以从小范围到大范围
2.被转化的是变量储存的数据（即值）。变量本身的数据类型没有变化
        var i int32 = 100
        var n3 int64 = int64(i) //i 的数据类型没有发生变化，知识它存的值转化为int64,并给了n3
3.小范围转大范围没有问题
  大范围转小范围可能导致数据溢出
        var n1 int32 = 12
        var n3 int8
        var n4 int8
        n3 = int8(n1)+127 // 编译通过，但是结果不是127+12，按照溢出处理
        n4 = int8(n1)+128 //编译不通过？为啥
4.只有相同底层类型的变量之间可以进行相互转换
	int 和 int32
  不同底层类型的变量相互转换时会引发编译错误
	bool 类型转换为 int 类型

5.浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。
```

## 类型别名

```go
// 别名：使用name和string相同。二者仍当做同一种类型运算。
// 别名只在源码中存在，编译完成后，不会有别名类型。

    type name = string // 类型别名（别名）,这是1.9版本之后的写法
    var myName name    // 变量声明使用 （%T,myName) ——>  string

// ---------------------------
1.注意 这里有等号
```



## 自定义数据类型

### 介绍

*   所有的数据类型都可以进行自定义类型

### 自定义类型

*    Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题 
*    Go语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。

```go
// 声明：将name定义为一个新的类型，该类型拥有和string一样的特性
    type name string   // 类型定义（声明）
    var myName name    // 变量声明使用  (%T,myName)  ——>  main.name	
    但是两者是不用的类型，不可用+进行拼接等运算。
注意
	所有数据类型均支持自定义数据类型
	与起别名不一样的地方 就是这里没有等号
    // 1.函数是一种数据类型，所以也可以自定义数据类型使用
    type  myFunType  func( int ,int ) int
   
```

## 方法绑定

*   方法绑定

    ```go
    类型起的别名 、 自定义类型均支持绑定方法
    	// go 中的数据类型均实现了空接口 ，相当于结构体 ， 可以绑定方法
    ```

*   非本地类型不能定义方法

    ```go
    介绍
    	 能够给各种类型起名字,但是不意味着可以在自己的包里为这些类型添加方法，
    	 就是在其他包中定义过了，不能在自己的包里重复定义
    例子
    	package main
        import ("time")
             // 定义time.Duration的别名为MyDuration,起别名
        type MyDuration = time.Duration	
            // 为MyDuration添加一个函数，为这个别名添加一个方法。
        func (m MyDuration) EasySet(a string) {}
        func main() {}
    
        * 编译出现错误
        cannot define new methods on non-local type time.Duration
    
        * 分析
        编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法，
    
        // 非本地类型指的就是 time.Duration 不是在 main 包中定义的，而是在 time 包中定义的，与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。
    
        !!!
        // 就是在其他包中定义过了，不能重复定义
        * 更正
        1.将 type MyDuration = time.Duration 修改为 type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型；
        2.将 MyDuration 的别名定义放在 time 包中。
    ```




## 特点

*   起别名和自定义类型区别

    ```go
    // 形式上在于有没有等号
    type name = string // 类型别名（别名）,这是1.9版本之后的写法
    type name string   // 类型定义（声明）
    ```



# 