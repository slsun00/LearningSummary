## 概念

```go
写入channel    就是 goroutine 发送数据给 channel , 简称： 发送数据
写出channel	 就是 goroutine 接收数据从 channel ，简称： 接收数据
```



## 1.介绍

*   Go语言在语言级别提供的 goroutine 间的通信方式
*   阻塞
    *   由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足才解除阻塞。
*   同步
    *   两个或多个协程（线程）之间，保持数据内容一致性的机制。

*   类型
    * 就是一段内存, 打印出来就是地址
    * 引用类型，存放的是数据的地址，自身是有数据类型的
*   本质：
    * 队列
*   安全性
    * 线程安全，多goroutine访问时，不需要加锁，channel本身是协程安全的
    * 多个goroutine访问同一个管道，不会出现资源竞争的问题
*   channel 有数据类型



## 比较

*   可以使用 == 对相同类型的管道进行比较

## 1.声明/定义、初始化

### make

```go
var channame chan type   // var intchan chan int ,intchar用于存放int数据类型

1. type : 通道内传输的数据的类型
2. 必须使用 make 初始化才能写入数据，否则永远阻塞
	通道实例 := make(chan int,10)

通道实例：通过make创建的通道句柄。	
创建一个容量为 10  的通道类型，通道内传输的数据类型是 int      

// 无缓冲的通道
ch := make(chan int)

// 有缓冲的通道
通道实例 := make(chan 通道类型, 缓冲大小)

    通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。
    缓冲大小：决定通道最多可以保存的元素数量。
    通道实例：被创建出的通道实例
```

### 单向通道

```go
// 单向通道的类型还是通道，只不过读写的存在限制

var 通道实例 chan <- 元素类型    // 只能写入数据的通道 
var 通道实例 <-chan 元素类型    // 只能读取数据的通道 

    元素类型：通道包含的元素类型。
    通道实例：声明的通道变量。
//---------------------------------------------------
    ch := make(chan int)
    // 声明一个只能写入数据的通道类型, 并赋值为ch
    var chSendOnly chan<- int = ch
    //声明一个只能读取数据的通道类型, 并赋值为ch
    var chRecvOnly <-chan int = ch
//---------------------------------------------------


1. 一个不能写入数据只能读取的通道是毫无意义的
2. 单向通道有利于代码接口的严谨性。
3. 注意 <- 和 chan 之间没有空格
```

### 无缓冲的通道

*   英文：unbuffered channel

*   无缓冲通道可以看作是长度永远为 0 的带缓冲通道

*   在接收前没有能力保存任何值的通道

*   有发送，同时必须要接收

    *   要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。
    *   没有的话，就会造成阻塞，直到对面准备完全，才会解除阻塞

*   这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。

    


### 带缓冲的通道

*   英文 ： buffered channel
*   被接收前能存储一个或者多个值的通道
*   不强制要求 goroutine 之间必须同时完成发送和接收
*   阻塞条件

    *   只有在通道中没有要接收的值时，接收动作才会阻塞。
    *   只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。

*   一个满的 channel 无法在进行数据写入 ； 一个空的 channel 无法进行数据读出

### 通道限制长度

```go
通道（channel）是在两个 goroutine 间通信的桥梁。使用 goroutine 的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。
```





注意

```go
type Cat struct{
	Name string
	Age int
}

func main(){
	var allchan chan interface{}
	allchan := make(chan interface{},3)

	allchan <- 10
	allchan <- "tom jack"

	cat := Cat{"小花猫"，4}
	allchan <- cat

	// 取出前面两个元素才能访问第三个元素
	<- allchan
	<- allchan
	// 访问第三个元素
	mewcate := <- allchan
	//直接使用print打印newcat.name是不出对的，要使用类型断言才能访问
	a := newcate.(cat)
	fmt.Print("newcate.mame =%v",a.name)

}
```



## 3.数据操作

### 特性

* 数据先进先出
* 一个 channel 只能传递一种类型的值，这个类型需要在声明 channel 时指定
* 在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。
* 管道操作是成对存在的，有写入肯定跟着有写出

### 数据写入通道

*   就是 ： 使用通道发送数据，将数据写入通道，等待发送

```go
// 数据写入管道，不能超过管道容量
channel <- 10 // intchan <- 10

channel 需要是一个通道实例
值的类型 要和通道的元素类型一致


1. 会自动扩容，满了就没法取了，所以长度过多会报错
2. 把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。
```



### 数据写出通道

#### 介绍

*   就是：从通道中接收收据
*   特性
    *   通道的收发操作在不同的两个 goroutine 间进行。
        *   由于通道的数据在没有接收方处理时，数据发送方会持续阻塞
        *   因此通道的接收必定在另外一个 goroutine 中进行。
    *   接收将持续阻塞直到发送方发送数据。
        *   如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。
    *   每次接收一个元素。
        *   通道一次只能接收一个数据元素。

#### 写出方法

*   阻塞接收通道的数据

    ```go
    data := <-ch
    // 执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。
    ```

*   非阻塞接收通道的数据

    ```go
    data, ok := <-ch
    
        data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。
        ok：表示是否接收到数据。
    
    1. 从通道接收数据时，语句不会发生阻塞
    2. 可能造成高的 CPU 占用，因此使用非常少。
    ```

*   忽略接收的数据

    ```go
    <-ch
    
    1. 执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。
    2. 这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。
    3. 相当于读到的数据不要了，扔掉
    
    // ---------------
    func main(){
        // 构建一个通道
        ch := make(chan int)
        // 开启并发匿名函数,开启一个同步通道
        go func(){
            fmt.Println("start goroutine")
            // 通过通通道通知 main 的 goroutine
            ch <- 0
            fmt.Println("exit goroutine")   
        }()
        fmt.Println("wait goroutine")
        // 主函数执行到这里无法执行，
        // 会一直等待从通道中接收数据，知道匿名函数向执行接收,给 ch 中写入了值,然后在执行
        <- ch
        
        fmt.Println("all done")
    }
    
    wait goroutine
    start goroutine
    exit goroutine
    all done
    ```

*   循环接收通道中的数据

    ```go
    for data := range ch { ... }
    // 通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。
    
    func main() {
        // 构建一个通道
        ch := make(chan int)
        // 开启一个并发匿名函数
        go func() {
            // 从3循环到0
            for i := 3; i >= 0; i-- {
                // 发送3到0之间的数值
                ch <- i
                // 每次发送完时等待
                time.Sleep(time.Second)
            }
        }()
        // 遍历接收通道数据
        for data := range ch {
            // 打印通道数据
            fmt.Println(data)
            // 当遇到数据0时, 退出接收循环
            if data == 0 {
                    break
            }
        }
    
    ```

    

```go
1. 读取了一个数据，这个数据在管道里就没了
2. 在没有使用协程的情况下
	若:管道数据已经全部取出，再取就会出现 deadlock
```



## 2.关闭

### 介绍

*   通道也可以被垃圾回收，但是通道也可以被主动关闭。

```go
1. 使用内置函数close关闭通道
2. 被关闭的通道不会被置为 nil 


// 关闭通道
close(ch)
```

### 特性

*   不能向管道写入数据
    *   向关闭的通道写入数据，会触发 panic
*   可以从关闭的通道中读取数据
    *   关闭的通道可以被访问，读取出没有被读取的消息
    *   管道关闭且读空，则会读到该类型的零值
    *   关闭通道中人获取数据时，永不会发生阻塞
*   触发 panic
    *   关闭一个未初始化 (nil) 的channel 
    *   重复关闭同一个 channel
*   产生一个广播机制
    *   所有向 channel 读取消息的 goroutine 都会收到消息

### 判断关闭

```go
// 判断是否关闭
x , ok := <- ch

ok 为 true  : 管道数据正确读出
ok 为 false : 管道里面数据已经读空 。 x 为 对应管道类型的零值


// 例子
	intchan := make(chan int,3)
	intchan <- 10
	close(intchan)
	intchan <- 300
	fmt.Println("ok!")
------------------------------
panic: send on closed channel

goroutine 1 [running]:
main.main()
        F:/go_project/src/test/main/main.go:11 +0xa2
exit status 2
```





## select 句法

### 超时机制

*   Go语言没有提供直接的超时处理机制

*   问题

    *   在运行比较快的机器或者高速的网络上运行正常的程序，到了慢速的机器或者网络上运行就会出问题，从而出现结果不一致的现象
    *   从根本上来说，解决死锁问题的价值要远大于所带来的问题。

    ```go
    select {
        case <-chan1:
        // 如果chan1成功读到数据，则进行该case处理语句
        case chan2 <- 1:
        // 如果成功向chan2写入数据，则进行该case处理语句
        default:
        // 如果上面都没有成功，则进入default处理流程
    }
    
    1. Go语言会按顺序从头至尾评估每一个发送和接收的语句。
    2. 如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。
    3. 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有如下两种可能的情况：
    
        如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复；
        如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。
    
    //----------------
    func main() {
        ch := make(chan int)
        quit := make(chan bool)
        //新开一个协程
        go func() {
            for {
                select {
                case num := <-ch:
                    fmt.Println("num = ", num)
                // ime.After 返回一个通道，这个通道在指定时间后，通过通道返回当前时间
                case <-time.After(3 * time.Second):
                    fmt.Println("超时")
                    quit <- true
                }
            }
        }() //别忘了()
        for i := 0; i < 5; i++ {
            ch <- i
            time.Sleep(time.Second)
        }
        <-quit
        fmt.Println("程序结束")
    }
    
    ```

### 通道多路复用

*   时处理接收和发送多个通道的数据

*   可以同时响应多个通道的操作

    ```go
    select{
        case 操作1:
            响应操作1
        case 操作2:
            响应操作2
        …
        default:
            没有操作情况
    }
    
    case 语句
    	1. 后面并不带判断条件，而是直接去查看 case 语句。
    	2. 每个 case 语句都必须是一个面向 channel 的 IO 操作 ， 包含通道收发语句 
    	3. 可以接收的样式
    		接收任意数据 	 case <- ch;
    		接收变量 	  case d :=  <- ch;
    		发送数据 	  case ch <- 100;	
    	4. 当操作发生时，会执行对应 case 的响应操作。
    
    default ：当没有任何操作时，默认执行 default 中的语句。
    ```





## 3.遍历

* channel 支持for - range 循环进行遍历

    * channel 没有关闭，会出现deadlock错误
    * channel 已经关闭，正常遍历，结束后，就会退出遍历

    ```go
    // 队列没有索引下标，所以只能取完前面的，才能找到要找的值
    
    close(intchan)
    for v := range intchan{
    	fmt.Println(v)
    }
    ```

    

* 最好不要使用 for 进行遍历，

    * 有人说：可以用  for 进行遍历，但是前提关闭channel

    ```go
    for i:=0; i<len(channel); i++{
        每读取一次数据，channel的长度都会减 1 ，所以最后值取到一半数据
    }
    
    -------------------------------
    for{
        v,ok := <- intchan
        if !ok{
            break
        }
        fmt.Printf("readData 读取的数据 =%v\n",v)
    }
    exitchan <- true 
    close(exitchan)
    ```


## 4.多通道

### 1.多协程读取

* 设计

```go
//（需要进行四个协程）
// 单个读取通设计
设置的参数有三个：( intChan chan int, 	：源数据通道
         		 primeChan chan int,   ：接收数据的通道
          		 exitChan chan bool)   ：退出协程通道
num,ok := <- intChan
if !ok{
	break // intchan 取不到
}
// 在设计单个协程的时候，就需要考虑，协程结束的情况,并在此做上结束的标记
exitChan <- true
```



* 开启

```go
//比如开启4个通道
for i:=0; i<4; i++{
	go primeChan(intChan,primeChan,exitChan)  // 就是同一个函数执行四个协程
}
```

* 关闭
    * 在主线处理关闭多协程，确保主线程最后关闭

```go
// exitChan 是在设计单个读取通道的时候， 在单个通道操作结束就已经设置的通道，
go func(){
	for i:=0; i<4; i++{
		<- exitChan
	}
// 从exitChan 取出4个结果，就可以放心的关闭读取的通道primeChan
	close(primeChan)
}()
```

### 2.通道写出

```go
	for{
		res,ok := <-primeChan
		if !ok{
			break
		}
	}
```

### 3.单通道写入

```go
// 记得关闭通道，这个有点儿不同于多协程读取，这个运行完要直接关闭
func putNum(intchan chan int){
	for i:=0; i<=8000; i++{
		inchan <- i
	}

	close(intchan)
}
```

## 5.性质

### 1.默认可读可写

```go 
// 直接声明的就是默认双向的，可读可写
var intChan chan int

//使用
1、处理数据
```

### 2.只写

```go
var intChan chan<- int //注意声明
make(chan int,3)  // 注意这个地方没有 <-

// 使用
1、发送信息之类
2、防止出现失误
```

### 3.只读

```go
var intChan <-chan int //注意声明
make(chan int,3)  // 注意这个地方没有 <-

//使用
1、接收数据
```

## 6.阻塞

### 1.select   多路复用

* 可以解决从管道阻塞问题
* 实际生产过程中很难确定什么时候要关闭通道，
* 随机选择一条能走通的 case , 直到所有 case 都走不通时，走 default 跳出

```go
default 跳出 for select 循环
    break //结束当前 select
		break lable
    continue // 继续下一轮 select
    return  // 跳出 for 循环
	

//-------------------------------------------------------------------

	intChan := make(chan int,10)
	for i:=0; i<10; i++{
		intChan <-i
	}

	stringChan := make(chan string,5)
	for i:=0; i<5;i++{
		stringChan <- "hello" 
	}
	for{
        // 
		select{
            // 如果管道一直没有关闭，也不会一直阻塞而死锁
			// 会自动到下一个case匹配
			case v := <-intChan : 
				fmt.Printf("intChan  %d\n",v)
			case v := <- stringChan:
				fmt.Printf("stringChan %s\n",v)
			default:
				fmt.Printf("可以加入逻辑\n")
            	 return

		}
        
        
 // 使用 break-lable 结束无限循环
        
 lable:
 for{
	select{
		//如果管道一直没有关闭，也不会一直阻塞而死锁
		// 会自动到下一个case匹配
		case v := <-intChan : 
			fmt.Printf("intChan  %d\n",v)
		case v := <- stringChan:
			fmt.Printf("stringChan %s\n",v)
		default:
			fmt.Printf("可以加入逻辑\n")
			return lable   // 注意 lable 的位置，是放在for前面，还是程序后面
		}
        
```

### 2.def - recover

* 只让出问题的协程报错，而不影响其他协程的进行

```go
// 直接在函数下面设置捕获 panic 函数

func test(){
    defer func(){
        // 捕获 其所在函数抛出的 panic
        if err:=recover();err != nil{
            fmt.Printlb
        }
    }()
}
```

### 3. 定时器

```go
注意没有 <- ,就不会产生阻塞

// 提供两种不同方式的计时器
1.  定时执行任务的计时器
2.  周期性执行任务的计时器

// 固定时间定时器
使用定时器延迟 2 s 执行一项任务

func main() {
	// 创建 2 s 的定时器,即管道阻塞两秒
	timer := time.NewTimer(2 * time.Second)
	// 当前时间
	// 当前时间 2020-09-14 09:53:37.5515893 +0800 CST m=+0.020994101

	fmt.Println("当前时间", time.Now())

	//  2 秒后，从单向时间管道中读出内容（当前时间）
	// timer.C 是一个单向时间管道，能读出来，说明，时间过了两秒
	t := <-timer.C
	// t = 2020-09-14 09:53:39.5520081 +0800 CST m=+2.021412901
	fmt.Println("t =", t)
}
//--------------------------------------------------
timer := time.NewTimer(2 * time.Second)
t := <-timer.C

等价于
t := <- time.After(3 * time.Second)
//--------------------------------------------------

// 停止计数器
// 必须要在计时器结束之前进行通知
timer.Stop()

// func (t *Timer) Stop() bool
1. 停止timer 的执行，永远不会向 timer.C 中写入数据
2. bool  为 true : 停止
		为 false ： 已经停止挥着过期了
3.不会关闭通道 t.c  ,防止从钙通道读取不正确的成功



//----------------------------------------------
// 计数器重置 ， 以当前时间为基准，将定时器重置为 3 秒
timer.Reset(3 * time.Sencond ) // 重置为 3s

```



### 4. 秒表

```go
// 周期性的计时器
ticker := time.NewTicker(1 * time.Second)
<- ticker.C //时间管道读取数据，每秒钟从时间管道读取一个时间数据，周期性
ticker.Stop() // 关闭秒表
```

### 5.等待组

*   原理 ： 
    *   每增加一个字协程，就像等待组中 +1 ，
    *   每结束一个子协程，就从等待组中 -1
    *   主协程等待直到组中的协程数等于 0 为止
    *   令主协程阻塞到最后一个字协程结束的时间点上
*   就是让子线程在主线结束之前结束
*   对于大规模访问写操作，也会出现问题，所以可以搭配锁使用



### 6. 互斥锁

*   原理
    *   对于与必要强制同步串行的任务，我们规定它只有得到互斥锁才有执行权，而全局只有一把互斥锁，谁先先抢到，谁就获得任务执行权，任务进行过程中，如果有其他协程想要得到执行权，就必须阻塞等待当前任务谢传给你释放同步资源





## 调度作用

* 用来做协程的调度
* 并不是说协程越多效率越高，开的跟CPU数目保持一致就行了，能够跑到100%，就已经很恐怖了



### 管道控制并发数

*   需要并发的协程，协程并发之前，需要在管道中注册，达到控制并发

    ```go
    /*
    100 条协程并发求 1-10000 平方根
    最大并发数控制在 5
    管道实现
    */
    
    
    
    func GetSqrt(name string, n int, chSem chan string) {
    
    	// 要执行，先注册
    	// 能写就执行，写不进去就阻塞到能写入为止
    	chSem <- name
    
    	result := math.Sqrt(float64(n))
    	time.Sleep(time.Second)
    	fmt.Printf("%d的平方根是 %.2f\n", n, result)
    	// 执行完毕，从信号量控制管道注销自己，为其他管道腾出空间
    	<-chSem
    }
    
    func main() {
    
    	// 信号量控制管道，凡要执行协程，必须将协程名字注册到这里
    	chSem := make(chan string, 5)
    
    	// 开辟 100 条协程
    	for i := 0; i <= 100; i++ {
    		go GetSqrt("协程"+strconv.Itoa(i), i, chSem)
    	}
    
    	for {
    		time.Sleep(time.Second)
    	}
    }
    
    ```

    

