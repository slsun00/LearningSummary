## 模板

### 介绍

* C++ 的编程思想就是泛型编程 ， 主要利用基础就是模板
* C++ 提供两种模板机制 ： 函数模板 + 类模板

### 类型

```c++
两种机制
    函数模板	
        template<typename T>  
        template<class T>  

    类模板
        template<class T>  

```







## 函数模板

### 介绍

```c++
作用
    建立一个通用函数 ， 器函数返回值类型和参数类型不具体定制
    用一个虚拟的类型来代表
语法
    template<typename T> 正常的函数声明、定义 
    
        关键字 template : 声明创建模板
        typename       : 表示其后面的符号是一种数据类型 ， 可以用 class 代替
        T 			  ：通用数据类型 ， 名称可以替换 ， 通常为大写
            
语法例子
    template<typename T>  
    void sWap(T& a, T& b) {
        T template = a;
         a = b;
         b = temp;
    }

调用
    方式一 ： 自动类型推断
    	// 必须要推导出一致的数据类型 T 才能使用
        int a = 3;  int b = 4;
        sWap(a,b)  // 可以实现交换
    方式二 ： 显示指定类型
        sWap<int>(a,b);

特点
    不能有默认参数
```

### 注意

#### 模板函数和普通函数

```c++
普通函数 ： 调用时发生自动类型转换（隐式类型转换）
函数模板调用时 
    利用自动推倒类型 ： 不会发生隐式类型转换
    利用显示指定类型 ： 可以发生隐式类型转换
```

## 类模板

### 介绍

```c++
作用
    建立一个通用类 ，类的成员、数据类型可以不具体制定， 用一个虚拟的类型来代表
 语法
    //template <字段类型> 函数名 {成员具体指}
    template <typename T>  类的声明
        关键字 template : 声明创建模板
        typename       : 表示其后面的符号是一种数据类型 ， 可以用 class 代替
        T 			  ：通用数据类型 ， 名称可以替换 ， 通常为大写
            
 特点
       类模板没有自动推倒的功能
       类模板在模板参数列表可以有默认参数(类型的默认参数)
  实例语法
  // NameType AgeType 就是任意类型，表示不同类型的 T     
  // 默认类型  <class NameType=string, class AgeType>
 template <class NammeType, class AgeType>
 class Person {
 public: 
     Person(NameType name, AgeType age) {
         this->m_name = name ;
         this->m_age = age;
     } ;
     NameType m_name;
     AgeType m_age;
 }

// 调用
void test() {
    // 类模板没有自动推倒的功能
    Person<string, int> p1("孙悟空"，999)；
}
```

### 模板方法成员

#### 创建底层

```c++
// 创建时机
    普普通类方法成员
        一开始就可以创建
    类模板中的方法成员
        在调用的时候创建
```



#### 声明定义

```c++
    
 // 类外实现
        template <class T1, class T2>
        class Person {
            Person(T1 name, T2 age){
                //this->m_Name = name;
                //this->m_Age = age;
            };
            
            void show() {
                cout << this->m_Name;
            };
            string m_Name;
            int age;
        }
		// 函数体内声明 ，函数体外定义 , 注意一个函数跟一个 template , 就是模板函数
		template <class T1, class T2>
         Person<T1, T2>:: Person(T1 name, T2 age){
                this->m_Name = name;
                this->m_Age = age;
         }
```

### 模块化

```c++
介绍
    类模板份文件编写 ， 将类模板函数份文件编写
问题
    类模板中成员函数创建时机是在调用阶段， 导致分文件编写是连接不到
 解决
    方法一 ：直接包含 .cpp 文件
    方法二 ： 将声明(.h文件)和实现(.cpp 文件)写到同一个文件中 ，并且改名为 .hpp(约定名称，非强制)
    
// 方法一  


```

####  方案一

```c++
person.h 头文件
    #pragma once
    #include <iostream>
    using namespace std;

	template <class T1, class T2>
    class Person {
        Person(T1 name, T2 age){
            //this->m_Name = name;
            //this->m_Age = age;
        };
        string m_Name;
        int age;
    }
person.cpp  源文件
    #include 'person.h'
    // 函数体内声明 ，函数体外定义 , 注意一个函数跟一个 template , 就是模板函数
    template <class T1, class T2>
        Person<T1, T2>:: Person(T1 name, T2 age){
            this->m_Name = name;
            this->m_Age = age;
        }
调用文件.cpp
    #include 'person.cpp'  // 不是 person.h
    Person<string, int> p("lili", 18);
原因
    模板中的成员函数一开始是不创建的， 所以调用文件 看不到 类.cpp 中的代码
```

#### 方案二

```c++
person.chh 文件
    #include <iostream>
    using namespace std;

	template <class T1, class T2>
    class Person {
        Person(T1 name, T2 age){
            //this->m_Name = name;
            //this->m_Age = age;
        };
        string m_Name;
        int age;
    }
    // 函数体内声明 ，函数体外定义 , 注意一个函数跟一个 template , 就是模板函数
    template <class T1, class T2>
    Person<T1, T2>:: Person(T1 name, T2 age){
         this->m_Name = name;
         this->m_Age = age;
    }

调用文件
    #include 'person.hpp'
    Person<string, int> p("lili", 18);
```



### 做参数

```c++
介绍
    类模板实例化出来的对象，向函数传递
方法
    指定显示类型 ： 直接显示对象的数据类型
    参数模板化   ：将对象中的参数变为模板进行传递
    整个类模板   ： 将这个对象类型模板化进行传递
    
 例子
    template <class T1, class T1>
    class Person {
    Public:
        Person(T1 name, T2 age) {
            this->name = name;
            this-age = age;
        };
        void show() {
            cout << "123" << endl;
        }
        
        T1 name;
        T2 age;
    }

	// 指定类型(推荐)
	void println(Person<string, int>& p){ p.show() };
	//  参数模板化   ：将对象中的参数变为模板进行传递
	template <class T1, class T2>
	void println(Person<T1, T2>& p){ p.show() };
	// 整个类模板   ： 将这个对象类型模板化进行传递
	void println(T& p){ p.show() };

	// 调用
	Person<string, int> p1("悟空"，100)；
    println1(p)
```



### 继承

```c++
特点
    当子类继承的父类是一个类模板 ，子类在声明的时候， 需要指定父类中 T 的类型
        如果不指定 ， 编译器无法给出子类分配内存
        如果想灵活指定父类中 T 的类型 ， 子类也需变为模板
    
语法例子
    template <class T>
    class Base {
        T m;
    };

	// 当子类继承的父类是一个类模板 ，子类在声明的时候， 需要指定父类中 T 的类型
	class Son :public Base<int> { } ;

	// 如果想灵活指定父类中 T 的类型 ， 子类也需变为模板
	template <class T1, class T2>
	class Son :public Base<T2> { public: T1 age; } ;

	// 调用
     Son<int, int> s1;
```

### 友元

#### 介绍

```c++
介绍
    友元函数的类内外实现
 分类
    全局函数类内实现 ： 直接在类内声明友元即可
    全局函数类外实现 ： 需要提前让编译器提前知道全局函数的存在
    
```



#### 类内实现

```c++

类内实现
	template <class T1, class T2>
    class Person {
    // 全局函数 类内实现
    friend void show(Person<T1, T2> p) {
        cout << p->m_name;
    }
    public:
        Person(T1 name, T2 age){
            //this->m_Name = name;
            //this->m_Age = age;
        };
    private:
        string m_Name;
        int age;
    }

	// 调用
	Person<string, int> p("tom",23);
	show()
```

#### 类外实现

```c++

类内实现
    
    // 编译器提前知道类
    template <class T1, class T2>
    class Person；
   //  编译器提前知道函数
	template<class T1,class T2>
    void show(Person<T1, T2> p) {
        cout << p->m_name;
    }
    
    
    
	template <class T1, class T2>
    class Person {
	// 类外实现 ，普通声明 , 下面是模板，需要调增加上<>
    // 需要让编译器提前知道有这个函数(半函数写在文件起始位置)，还要提前知道类，提前声明
   friend void show<>(Person<T1, T2> p);
    public:
        Person(T1 name, T2 age){
            //this->m_Name = name;
            //this->m_Age = age;
        };
    private:
        string m_Name;
        int age;
    }
	

	// 调用
	Person<string, int> p("tom",23);
	show()
```



## 注意

### T 类型确定

```c++

        
模板必须确定 T 的类型才能使用
template<typename T>
void func() {
	cout << "func 调用" ；
}

调用
    func()  // 出现错误 ， T必须给出具体类型
```







































































































































































































