## 数组封装需求

```c++
#pragma
using namespace std
#include <iostream>

template<class T>
class myArray {

public:
    myArray(int capacity){
        this->m_Capacity = capacity;
        this->m_Size = 0;
        this->pAddress = new T[this->Capacity]

    };

    // 拷贝函数
    myAddrray(const myArray& arr){
        this->m_Capacity = arr.m_Capacty;
        this->m_Size = arr.m_Size;

        // 深拷贝 ，不是浅拷贝，避免复制浪费空间
        this->pAddress = new T[this->Capacity];

        // 拷贝 arr 数据
        for (int i = 0; i< this->m_Size; i++) {
            this->pAddress[i] = arr.pAddress[i];
        }
    }


    // 尾插法
    void push_Back(const T& val) {

        // 数组容量和实际大小相同， 不能再插入
        if (this->m_Size == this->m_Capacity) {
            return;
        }

        // 插入
        this->pAddress[this->m_Size] = val;
        this->m_Size++;  // 更新数组数据
    }

    // 尾删法
    void Pop_Back() {
        if (this->m_Size == 0) {
            return;
        }
        this->m_Size--;
    }

    // 通过下标方式访问数组
    T& operator[](int indx) {
        return this->pAddress[index];
    };

    // 返回数据的容量
    int getCapacity() {
        return this->m_Capacity;
    };

    // 返回数组长度
    int getSize() {
        return this->m_Size;
    }



    // 计算符号重载，防止出现浅拷贝的问题
    myArray& operator=(const myArray& arr) {

        // 先判断原来的堆区是否有数据， 有的话就先释放
        if (this->pAddress ！= NULL) {

            delete[] this->Address;
            this->pAddress = NULL;
            this->m_Size = 0;
        }

        // 深拷贝
        this->m_Capacity = m_Capacity;
        this->m_Size = arr.m_Size;
        this->pAddress = new T[this->Capacity];
        for (int i = 0; i< this->m_Size; i++) {
            this->pAddress[i] = arr.pAddress[i];
        }

        return *this;

    }

    // 析构函数
    ~myArray(){
        if (if this->pAddress != NULL ) {
            delete[] this->pAddress;
            this->pAddreee = NULL:
        }
    }


private:
    int m_Capacity;
    int m_Size;
    T* pAddress;


};

```

