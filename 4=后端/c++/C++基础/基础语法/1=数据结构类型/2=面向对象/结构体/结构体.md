# 

## 1. 介绍

### 结构体

*   介绍
    *   是自定义的数据类型，代表一类事物
    *    只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存， 
    *   必须在定义结构体并实例化后才能使用结构体的字段。 

### 结构体实例化

* 结构体变量（实例）

  实际的，代表一个具体变量
  
  
### 实现

```go
“实现”是个动词，指的是使用某种计算机编程语言将某种程序设计思想写出来的过程，而且要保证写出来的代码是在可以在计算机上直接运行的。

实现就是将某种原理性的东西转化为可执行的程序代码的过程，同一种原理可以使用多种不同的语言实现，即使是使用同一种语言，也可能有不同的实现方式

原理是便于人类使用自然语言描述和理解的，而实现是可以在计算机上运行的。

接口就是可供bai外部调du用的方法，实现就是对zhi这些方法的dao编程实现
```



## 结构体格式

```c++
struct 结构体名称 {
	结构体成员列表，字段
} 实例名 ；

一些名词
    结构体标签 ：结构体名称
    结构体变量 ：实例名
    

例子
 struct student {
     // 字段类型 字段名;
     char name; // 姓名 ，  
     int age;  // 年级
 }
```

### 属性字段

  *   别称
      
      *   结构体字段（字段）  ： 结构体成员（成员）、成员变量（变量）
      *   建议记忆为 ：结构体属性（属性）
      
  * 特性
    *   字段拥有自己的类型和值，可以是任意数据类型
    *   字段名必须唯一；
    *   字段的类型也可以是结构体，甚至是字段所在结构体的类型。
    *    同类型的变量也可以写在一行 

*   需要总结

    ```js
    * 创建结构变量后，没有复制，默认只是零值
    * 不同结构体的变量的字段是独立的，互不影响，一个结构字段的更改，不影响另一个结构体
    * struct中的所有字段在内存是连续的
    ```

### 注意

```c++
结构体的属性字段是数组、结构体数组
    // 数组名是常量， 不允许进行赋值修改
    struct a {};
	struct b {
        struct b arr[3];
    } b1 ;
	// 赋值的时候
	b1.arr[3] = {{},{},{}}  // 不对
	struct b b2 = {arr[3]:{{},{},{}}} // 不对
  
```



## 声明实例化(赋值)

### 选择器

```c++
// 点操作符
	使用
		对普通结构体实例访问结构体的属性
     语法
    	结构体.成员名
// -> , 见结构体指针
     使用
     	对一个结构体指针进行访问、修改属性等操作的时候，
     语法
        结构体指针变量 -> 结构体属性字段
      例子
      	// 
        结构体指针
        struct Student * p = &s1;
        // 访问或者修改指针变量中的属性字段，要使用
        p -> name  // "lili"
    
作用
	 访问结构体成员
     点号操作符也被称为选择器(selector)
```

### 介绍

```c++
权限
    struct 默认权限是 public , 基本用不上
方法
       struct 中也基本不使用方法
声明 + 实例化
    // 实例化的时候的 struct 可以省略， 但是定义的时候不能省略
    先声明之后实例化
    声明的时候实例化
    
实例化个数
    单个实例化
    批量实例化
    
实例化 + 赋值
    是实例化之后给字段赋值，
    实例化的时候给字段赋值

赋值
    1. 访问字段名填充
    2. 键值对填充
    3. 推导键值对
    	按照顺序进行 值和字段属性进行对应赋值
    	必须初始化结构体的所有字段。
 
赋值注意
    1. 对于没有赋值的字段属性，都使用默认值 ，所以可以选择性初始化
	2. 三种方式不能混用，推荐键值对
```

### 声名 + 实例化

```c++
声明之后实例化
	// 声明 
    struct Student {
        string name;
        int agel;
    }   
	// 实例化
	单个 ：  struct Student s1;
	批量 ：  struct Student s1, s2, s3;

声明的时候实例化
   struct Student {
        string name;
        int agel;
    // 单个实例化
    } s1 ;
	// 批量实例化
	// s1, s2, s3;
```

### 实例化 + 赋值

```c++
// 沿用上面的分类 ， （赋值的形式有多种，这里只用其中的一种
声明之后实例化 ， 实例化之后赋值
    单个 ：  
    	struct Student s1;
		s1.name = "lili";
		s1.age = 18;
			
	批量 ：  
        // 针对每个结构体变量进行设置就行了
        struct Student s1, s2, s3;
		s1.name = "lili"; s1.age = 18;
		s2.name = "lili"; s2.age = 17;
		s3.name = "lili"; s3.age = 16;

声明之后实例化 ， 实例化的时候赋值
   struct Student {
        string name;
        int agel;
    // 单个实例化
    } s1 = {"lili",18};
	// 批量实例化
	} s1 = {"lili",18}，s1 = {"lili",17}，s1 = {"lili",16};;
```

### 赋值

```c++
访问字段名赋值
    单个 ：  
    struct Student s1;
    s1.name = "lili";
    s1.age = 18;

键值对赋值
    struct Student s1 =  {name:"lili", age:18};
推导键值对
    struct Student s1 =  {"lili",18};

注意
    当结构体的属性字段是一个结构体数组的时候 ， 貌似只能使用访问字段名进行赋值
```

### const 使用

```c++
const struct 结构体名字 * 结构体指针变量；
// 使用参看结构体作为函数参数进行传递
// 使用这个就可以防止函数改变参数结构体
```



## 特殊形式的结构体

### 结构体数组

```c++
结构体放到数组中进行维护

数组语法 ： 数据类型 数组名[] = {}
结构体数组 ： struct 结构体名 数组名[元素个数] = {{},{},{}}
例子
    struct student {
        string name;
        int age;
    }
	
	struct student arr[2] = {
        { name:"lisi", age：18 }，
        { name:"lisi", age：17 }，
    }
	访问 
    arr[1].age // 17
```

### 结构体指针

```c++
介绍
    通过操作符 -> 可以通过结构体指针访问结构体
    指针 		： 数据类型 * 指针变量；
    结构体指针 ： struct 结构体名称 * 指针变量；
例子
    struct Student {
        string name;
        int agel;
    } s1 = {name="lili", age:18};

	// 结构体指针
    struct Student * p = &s1;
	// 指针变量访问结构体变量中的数据
	p -> name  // "lili"
```

### 结构体作为函数参数

```C++
分类
    引用传递
    	// 注意这里函数体访问结构体属性，需要用 ->
    	void print(struct teacher * s)
    	print(&t1)
    值传递
    	void print(struct teacher s)
    	print(t1)
    const 引用类型
    	// 加上 const 对于结构体的属性字段就只能读，不能修改了
    	// 防止修改参数
    	void print(const struct teacher * s)
    	print(&t1)
介绍
    和函数中介绍的引用传递和值传递一样
    引用传递会改变实参的值，值传递不会
```

### 结构体嵌套

```c++
介绍
    结构体中的属性字段可以是另外一个结构体
例子
    struct student { int age; }
	struct teacher {
        int age;
        struct student stu;
    } t1;
	
	// 嵌套访问赋值
	t1.stu.age = 18；
        
注意
    子结构体需要在 父结构体之前定义 ， 字段属性名相当于一个实例化
	
```

### 注意

```c++
    struct a {
        int num;
    };
	struct b {
        struct a arr[3];
    } b1 ;
	
	// 所以数组赋值只能在初始化的时候赋值，然后就是一个下表索引一赋值
	//  不对
	 b1.arr = {{num:1},{num:1},{num:1}};  //
	// 对， 可以赋值
	struct b b2 = {arr:{{num:1},{num:1},{num:1}}}; 
	// 可以循环遍历进行赋值 一个下标一个下标来
	cout << b1.arr[1].num << endl;
	return 0;

	
```





## ========

### 结构体格式

```go

1. 关键字 type 可以将各种基本类型定义为自定义类型
2. 类型名：标识自定义结构体的名称，在同一个包内不能重复。
3. struct{}：表示结构体类型，type 类型名 struct{}可以理解为将 struct{} 结构体定义为类型名的类型。


```



## 2.声明/初始化/访问







### 2.字段名初始化

```go


3. 注意
	1. 以上两者如果横着写不需要写最后字段后面逗号，如果竖着写，每个字段最后都需要逗号
    	var p = Person{ "lihua"，20}
    	var p = Person{
            "lihua"，
            20,
        }
```

### 3.初始化赋值

```go
type Person struct{
    name string
    age  int
}
```

#### 1.非指针类型





#### 2.指针类型

```go
// 非指针类型，加上 *（如 Person 变成 *Person） 就变成指针了

1.var p1 *Person = new(Person)
	// p1 是一个指针，因此变准的给字段赋值方式
	(*p1).name = "john"
     p1.name = "john"
    // 上面两句话是一样的，底层会对 p1.name进行处理成 (*p1).name
    // 结构体指针访问字段的标准方式:(*结构体指针).字段名=结构体指针.字段名

// 2.  结构体进行 & 取地址操作时，视为对该类型进行一次 new 的实例化操作
 	var Lihua *Person = &Person{}  //  p := &Person{}
	
	var stus *stus = &stu{"小明"，10001，male}  
	
```



#### 3.取结构体地址

```go
// 1. 返回结构体的指定指针类型
    var p = &Person{
            name："Tom",
            id:"1000",
            gender:"male ",
       }
```



### 4.匿名结构体

```go
// 匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用
// 也可以不进行初始化成员

ins := struct {
    name string
}{
    // 字段值初始化
    name : lihua,
}
```



### 5. 与接口初始化

* ## 就是使用工厂方法，如何进行初始化

* 模型设计哪里用的很多

#### 1.符号使用

  ```go
  type Paper interface
  
  type Pen struct{}
  func (this *Pen) use(){   		 //这个地方是指针接收器
  	fmt.Print("调用成功")
  }   
  ====================================================
  func NewPen() *Pen{				//这个看情况
      // 
      return &Pen{}					//这个地方就要使用指针
  }
  
  （this *open）
  	返回： 接口 		只有 &
  		  结构体	 必须是成对存在，或者都不存在
  （this open）
  	返回： 接口		必须有 & ，或者都不写
  		  结构体     必须有 & ，或者都不写
  ```

  

#### 2.初始化 / 实例化

* 接口 作为类对象	Paper
* 接口 作为对象        paper Paper

```go
type Paper interface

type PenOne interface{
    write()
}
type Pen struct{
    Paper		// 使用 paper Paper都是一样的实例化/初始化过程
    Num int
}

func (p *Pen) write(){...}

---------------------------------------------------------------------
func (p *Pen) CreatePen(paper Paper,num int) Paper{
    p.Paper = paper
    p.Num = num
    return it
}
---------------------------------------------------------------------
// 初始化 pen 结构体初始化，里面含有一个接口，所以需要设置一个参数，但是返回的是它实现的实例....
func CreatePen(paper Paper,num int) Paper{
    return &Pen{
        Paper:paper,
        Num :num,
    }
}

---------------------------------------------------------------------
func CreatePen() *Pen {
    return &Pen{paper,num}
}

---------------------------------------------------------------------
// 这一种也适用于空结构体的情况
func CreatePen() *Pen {
    return &Pen{}	// 这个返回的是各个字段的零值
}

// Paper 是一个接口，所以传参进来，应该是 Paper 已经实例化了一个 struct,这个strut传进来的
// 这个 struct 实现了 Paper 接口，实例化的时候，返回的就是一个接口


```

#### 3.调用接口函数

* 接口作为类对象

    ```go
    type com interface{
        display()
    }
    
    type cn interface{
        display()
    }
    type cn1 struct{
        com
    }
    func (c *cn1) display(){
        c.com.display()		
        // 尽量不要用缩写的 c.display，虽然这样因为可以，但是会造成混淆
        // 而且两者使用相同的函数，会造成递归这个函数，
    }
    ```


#### 4.多参数化简传递

```go
// 将参数放在一个结构体中，可以化简参数变成一个参数

type Coordinate struct {
	X int
	Y int
}
type IgoChessman struct {
	Color string
}
// 等于说这里有三个参数，一个通过自身的结构体穿进去了，另外两个通过一个结构体，穿进去
func （igo *IgoChessman）Display(coordinate Coordinate){	// 这里传入结构体，就可以化简成一个参数
	fmt.Println("&v 的棋子在（%d,%d）的位置"，igo.Color,coordinate.X,coordinate.Y)
}
```



```go
type shape interface {
    Area() float64
}

type Rect struct {
    width float64
    height float64
}
func (r *Rect) Area() float64 {	
    return r. width * r.height
}

func main(){
    r := Rect{5.0,4.0}
    var s shape := &r  
    area := s.Area()
    fmt.Println(area)
}

// 在接口的情况下，如果方法有指针接收器，那么接口将具有动态类型的指针而不是动态类型的值
// 所以为接口变量分配类型值的时候，我们要分配类型为value的指针
```







## 3.构造函数 - 工厂模式

*    Go语言的类型或结构体<font color=red>没有构造函数的功能</font>
*    使用结构体初始化的过程来模拟实现构造函数 
*    没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。 

### 功能特性

*    每个类可以添加构造函数，多个构造函数使用函数重载实现。
*   构造函数一般与类名同名，且没有返回值。
*   构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。
*   在Go里我们一般不会返回多个struct，而是返回一个interface，而具体实现，都满足这个interface

### 模拟构造函数重载

```go
type Cat struct {
    Color string
    Name  string
}
func NewCatByName(name string) *Cat {	  // 用名字构造猫结构的函数，返回 Cat 指针。
    return &Cat{				    	// 取地址实例化猫的结构体
        Name: name,				    	// 始化猫的名字字段，忽略颜色字段。
    }
}
func NewCatByColor(color string) *Cat {
    return &Cat{
        Color: color,
    }
}

// 颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程
```

### 模拟父级构造调用

```go
type Cat struct {
    Color string
    Name  string
}

// lackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。
type BlackCat struct {
    Cat  // 嵌入Cat, 类似于派生
}

// “构造基类”
// NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。
func NewCat(name string) *Cat {
    return &Cat{
        Name: name,
    }
}

// “构造子类”
// NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针
func NewBlackCat(color string) *BlackCat {
    
    // 实例化 BlackCat 结构，此时 Cat 也同时被实例化。
    cat := &BlackCat{}
    
    // 填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat
    cat.Color = color
    return cat
}
```



3. 

（这两个是啥？需要百度）

## 5.方法 - 接收器

### 接收器

#### 介绍

*   某种类型的变量

*    Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。 

*   别称

    *   有的人称接收器   是类型

*   接收器 = 接收器变量 + 接收器类型

    ![1599045481171](1599045481171.png)

#### 接收器变量

```go
命名： 官方建议使用接收器类型名的第一个小写字母，不是 self this 之类的命名
接收器类型的一个实例（简化记忆：别名）
```

#### 接收器类型

*   可以作为接收器类型的

    ```go
    1.  是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法 
    2.  可以是其他允许类型的指针
    ```

*   不能作为接收器类型的

    ```go
    1. 接口类型
        因为接口是一个抽象定义，而方法却是具体实现，
        这样做了就会引发一个编译错误`invalid receiver type…`。
    
    2.  指针类型
    	但是可以是其他任何允许类型的指针
    ```



#### 类型 T 的方法集

*    型 T（或 T）上的所有方法的集合 
*    一个类型加上它的方法等价于面向对象中的一个类 
*    Go语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。



#### 分类

*    指针接收器 

    ```go
    1. 由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。
    2. 指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。
    
    
    // 定义属性结构
    type Property struct {
        value int  // 属性值
    }
    // 设置属性值 , 可以修改成员值，即便退出方法，也有效
    func (p *Property) SetValue(v int) {
        // 修改p的成员变量
        p.value = v
    }
    // 取属性值
    func (p *Property) Value() int {
        return p.value
    }
    func main() {
        // 实例化属性
        p := new(Property)  // 默认值 value = 0
        // 设置值
        p.SetValue(100)
        // 打印值
        fmt.Println(p.Value()) //100
    }
    ```

    

*    非指针接收器 

    ```go
    // 会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。
    // 方法变得类似于只读的方法，方法内部不会对成员进行任何修改。
    
    // 定义点结构
    type Point struct {
        X int
        Y int
    }
    // 非指针接收器的加方法
    func (p Point) Add(other Point) Point {
        // 成员值与参数相加后返回新的结构
        return Point{p.X + other.X, p.Y + other.Y}
    }
    func main() {
        // 初始化点
        p1 := Point{1, 1}
        p2 := Point{2, 2}
        // 与另外一个点相加
        result := p1.Add(p2)
        // 输出结果
        fmt.Println(result)  // {3 3}
        fmt.Println(p1.X)    // 1
    	fmt.Println(p2.X)    // 2
    }
    ```

*   使用

    ```go
    1. 小对象由于值复制时的速度较快，所以适合使用非指针接收器，
    2. 大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。 
    ```

    



### 方法

#### 介绍

*    Go 方法是作用在接收器（receiver）上的一个函数 
*   作用在指定数据类型上的（即和指定的数据类型绑定），因此自定义类型都有方法，而不仅仅是struct

#### 方法签名

```go
包括 ：方法名、参数列表、返回参数列表
```



#### 1.方法声明和调用

```go
func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {
    方法体
    return 返回值
}

1.接收器变量


2. 接收器类型
	接收器类型和参数类似，可以是指针类型和非指针类型
	表示方法和接收器类型进行绑定，或者说该方法作用于 接收器类型

3. 方法名 参数列表 返回参数  和函数一样

----------------------------------------------------------------------
type A struct{
    Num int
}
func (a A)test(){ // 表示A结构体有一个方法，方法名为test
    fmt.Print(a.Num) 
}
// (a A) 体现 test 方法和 A绑定
// a 相当于结构体 A 的别名，表示那个结构体(A)变量调用，a 就是它的副本，这个不是固定的，可以随意指定


// 调用
p.test()  // 结构体别名.方法名

------------------------------------------
func (a *A)test(){ // 表示A结构体有一个方法，方法名为test
    fmt.Print(a.Num) 
}
Pupil := &A
Pupil.test()
```



#### 2.方法调用和传参机制原理

* 方法的调用和传参机制和函数的一样，不同的就是，方法会调用方法的变量，当做实参也传递给方法（值类型进行值拷贝，引用类型进行地址拷贝）

#### 3.注意

1. 结构体是值类型，方法调用过程中遵守值传递机制，是只拷贝传递方式

2. 方法访问范围控制：

   和函数一样，方法名首字母小写，包内访问；方法首字母大写，跨包使用

3. 方法作用在指定的数据类型上（即：和指定的数据类型绑定），因此自定义类型都可以有方法，不仅仅是 struct

   ```go
   type integer int
   func(i integer)print(){
       fmt.Print("i=",i)
   }
   
   // 编写一个方法，可以改变 i 的值
   func （i *integer）change(){
       *i = *i + 1
   }
   
   func main(){
       var i integer = 10
       i.print()
       i.change
   }
   ```

4. 如果一个类型实现了String()这个方法，那么fmt.Println 默认会调用这个变量的String()进行输出

![](F:\最终整理版本\go语言\1593359829302.png)

5. 在方法中修改结构体变量的值，可以通过结构体指针的方法来处理\

   ![1593360044716](F:\最终整理版本\go语言\1593360044716.png)

   

#### 4.方法和函数的区别

1. 调用方式不同

   * 函数：函数名（实参列表）
   * 方法：变量.方法名（实参列表）

2. 接受者不同

   * 函数：当为值类型时，不能讲指针类型的数据直接传递，反之亦然

     ```go
     func test(p Person)  // test(p)
     func test(p *Person)  //test(&p)
     ```

     

   * 方法：当为值类型时，可以直接用指针类型的变量调用方法，反之亦然

     ```go
     func (p Person) test(){}
     func (p *Person) test(){}
     p.test() 等价于 &p.test()
     
     // 总结
     1.不管调用形式如何，真正决定值拷贝还是地址拷贝，看这个方法和哪个类型绑定
     2.和值类型绑定，就是值拷贝：（p Person）
     3.和指针类型绑定，就是地址拷贝（p *Person）
     ```

#### 方法重载

*   方法
    *    方法是函数，所以同样的，不允许方法重载 
    *    对于一个类型只能有一个给定名称的方法 
*   基于接收器类型
    *   可以重载
    *    有同样名字的方法可以在 2 个或多个不同的接收器类型上存在 









## 7.抽象

就是把对象的属性，放在一个结构体中

*   