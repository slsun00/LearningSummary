## 1.函数

* 为完成某一功能的程序指令(语句)的集合，称为函数。
* 讲一段经常使用的代码封装起来，减少重复代码

## 2.分类

*    函数的类型被称为函数的标识符 

*   分类

    ```go
    1.	普通的带名字的函数
    2.	匿名函数
            又称： lambda 函数
    3.	方法
    ```

*   常见样式

    ```c++
    有返回值
        有参数
        无参数
    无返回值
       	有参数
        无参数
    ```
    
    
    



## 函数签名

```go
函数签名就是函数的声明信息，包括参数、返回值

参数 	 ：	类型 个数 顺序
返回值	：  类型 个数  
异常   ：
这个众说纷纭，貌似没啥统一的
```



## 3.声明定义

### 介绍

```c++
名词
    函数声明 ：
    	告诉编译器函数的名称、返回类型和参数 ， 没有花括号

    函数定义 ： 提供了函数的实际主体。
		int max(int num1, int num2) { /*花括号里里面是函数体 */}; 

个人理解
    // 定义就像给函数变量赋值 ， 值就是函数体
    先声明，后定义   ： 函数声明
    声明的时候定义	  ： 函数定义 
```

### 函数结构

```c
// 有返回值 , 可没有参数
    返回值列表(类型) 函数名(参数值列表)  {
    	函数体语句
    	return 表达式（返回值列表）
	}
// 可以无返回值， 可没有参数
// 函数不需要返回值， 声明的时候可以写成 void
    void 函数名(参数类表)  {
    	函数体语句
    	return 
	}  
```

### 先声明后定义

```c
作用
    函数声明会告诉编译器函数名称及如何调用函数， 提前告诉编译器存在这么一个函数，不用报错
    函数的实际主体可以单独定义。
    
    
使用
    函数定义写在 main 函数之后的时候，就需要
特点
    声明的时候，函数没有函数体
    声明过的函数，可以在任意地方进行定义实现
    声明可以写多次，但是定义只能有一次    
    
语法例子
    	// 声明中，参数的名称并不重要，只有参数的类型是必需的 , 下面两种都可以
    	int max(int num1, int num2); 
		int max(int, int);  
语法实例
    // 声明
    int max(int,  int);
	// 赋值（赋予函数体）
	int max(int num1, int num2) {
        return num1 + num2;
    }
```



### 声明的时候定义

```c
函数定义
    
使用
    //         声明的时候赋值
    函数定义写在 main 函数之前

特点
    函数有函数体，位置定义的地方要在在 main 函数之前
    函数可以在任意地方调用
    
语法格式例子
        int add(int num1,int num2) {
            return (num1 + num2)
        }
	    int main() { return 0; };

	// 为什么理解成声明的时候赋值
	函数的正规写法是下面的，就像是赋值，但是一般都是写成上面紧凑的形式
    int add(int a, int b)
    {
        return (num1 + num2)
    }
```

### 无参无返回值

```c++
// 有返 ， 有参
    (int) add(int num1, int num2) {
    	int sum = num1 + num2;
    	return sum;
	}
// 有返 ， 无参
	(string) print_hello() {
        char hello = "hello";
        return hello
    }
// 无返 ， 有参
    void swap(int num1, int num2) {
        int temp = num1;
        num1 = num2;
        num2 = temp;
    }
// 无返 无参
    void hello() {
		char hello = "hello";
        cout << hello << endl;
    }	
```



*   执行语句

    *   实现某一功能代码块

*   函数变量

    *   局部变量，函数外不生效

## 4.参数

### 介绍

```c++
综述
    形参和实参只是函数的参数在不同的生命周期中的叫法
    形参 ： 函数定义(声明)的时候， 函数参数的叫法， (定义的参数)
    实参 ： 函数调用的时候，函数参数的叫法, (接收的参数)
形参， 参数列表
    介绍
    	形式的参数，其本身并没有数据
        表示函数的输入 ，形参列表可以是多个
    
实参
   	介绍
    	是一个局部变量 ， 参数的数据，由参数调用者提供
    
使用
    函数在调用时都必须按照声明顺序为所有参数提供实参（参数值）
    函数调用时，也没有默认参数值，也没有任何方法可以通过参数名指定形参
    形参和返回值的变量名对于函数调用者而言没有意义
```

### 2.传递方式 

#### 介绍

```c++
指针传递 ：需要开辟内存 ，容易造成内存泄漏
引用传递 ： 不用开辟内存
```



####  值传递

```c++
值传递
    // 默认使用
    函数在调用实参时，将数值传入给形参
    把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数
    
特点
    1.	传递的是值的拷贝，数据量大，越大效率越低
    2.	在函数内修改，不会影响到原来的值
    3.	变量直接存储值，内存通常在栈中分配
例子
    void swap(int num1, int num2) {
        int temp = num1;
        num1 = num2;
        num2 = temp;
    }
	int a=1, b=2;
	cout << a << endl;   // a=1
	swap(a,b);
	cout << a << endl;   // a=1

原理:

int a=1, b=2;
	开辟一个内存 ，内存中 a 的值为 1 ，b 的值为 2
swap(a,b);
    // 参数传递
    在内存中再开辟内存 num1 num2 ,然后把 a 的值赋值给 num1, b 的值赋值给 num2
    此时内存中有四个内存空间变量 a=1 b=2 num1=1 num2=2
    // 函数内部进行数值交换
	// int temp = num1;
    开辟一个 内存为temp 的空间 ， 将num1 的值给 temp , 
	此时内存空间 ：a=1 b=2 num1=1 num2=2 temp=1
	// num1 = num2;
    将内存空间 num2 的值赋值给 内存空间 num1
    此时内存空间 ：a=1 b=2 num1=2 num2=2 temp=1
	// num2 = temp;
   将内存空间 temp 的值赋值给 内存空间 num2
    此时内存空间 ：a=1 b=2 num1=2 num2=1 temp=1
    // 最后，回收 temp
    此时内存空间 ：a=1 b=2 num1=2 num2=1 
    // cout << a << endl;   // a=1
```

#### 地址传递(*)

```c++
特点
    传递的是值的地址的拷贝，地址数据量小，拷贝效率高
   	形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。
    传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问
    存在 堆中
例子
    void swap(int * num1, int * num2) {
        int temp = *num1;
        *num1 = *num2;
        *num2 = temp;
    }
	int a=1, b=2;
	cout << a << endl;   // a=1
	swap(&a, &b);
	cout << a << endl;   // a=2
原理
int a=1, b=2;
	开辟一个内存 ，内存中 a 的值为 1 ，b 的值为 2
swap(&a,&b);
    // 参数传递
    创建指针变量 num1 num2 ,
	然后把 a 的内存地址给指针变量 num1 ， b 的内存地址给指针变量 num2
    此时内存中有四个内存空间变量 a=1 b=2  num1=a的内存地址  num2=b的内存地址
    
    // 函数内部进行数值交换
	// int temp = *num1;
    开辟一个 内存为temp 的空间 ， 将指针变量 num1 记录的内存地址中的值 给 temp , 
	此时内存空间 ：a=1 b=2 num1=a的内存地址  num2=b的内存地址  temp=1
	// *num1 = *num2;
    将指针变量 num2 记录的内存地址中的值 覆盖(给) 指针变量 num1 记录的内存地址中的值
    此时内存空间 ：a=2 b=2 num1=a的内存地址  num2=b的内存地址  temp=1
	// *num2 = temp;
    将temp2 记录的值 覆盖(给) 指针变量 num2 记录的内存地址中的值
    此时内存空间 ：a=2 b=1 num1=a的内存地址  num2=b的内存地址 temp=1
    // 最后，回收 temp num1 num2
    此时内存空间 ：a=2 b=2  
    // cout << a << endl;   // a=2
        
简写
	// 不要随意简写
```

#### 引用传递(&)

```c++
作用
	函数传参时， 可以利用引用让形参修饰实参
优点
    可以简化指针修改实参
例子
    void swap(int &num1, int &num2) {
        int temp = num1;
        num1 = num2;
        num2 = temp;
    }
	
	int a=1,b=2;
	swap(a,b)
    // a = 2 , b = 1
    cout << a << b <<endl;
```

#### 常量引用

```c++
// 常量引用，见指针 引用
形参调用
    void show( const int &val ) { 
    	// val = 1000 ;  使用这里会报错，使用 const 不能在函数体内修改形参的值
    	cout << val <<endl;
	}
	int main() {
        int a = 100;
        show(a)   // 打印出来 1000 
    }
```

### 传递方法对比

```c++
// 指针传递   
	被调函数的形式参数作为被调函数的局部变量处理，在栈中开辟了内存空间
     以存放由主调函数放进来的实参的值，从而成为了实参的一个副本
     
   本质上
        是值传递的方式，它所传递的是一个地址值
    特点
        是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
// 引用传递
        
	被调函数的形式参数作为被调函数的局部变量处理，在栈中开辟了内存空间
     以存放的是由主调函数放进来的实参变量的地址，通过栈中存放的地址访问主调函数中的实参变量。
     
   特点
	    被调函数对形参的任何操作都被处理成间接寻址
        被调函数对形参做的任何操作都影响了主调函数中的实参变量。

引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。
```





* 变量储存的是一个地址，这个地址对应的空间才是真正存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址的时候，改地址对应的数据空间就成为一个垃圾，由GC回收。（数据在空间上）

* 传入与返回参数在调用和返回时都使用值传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参

### 3.类型

#### 默认参数

```c++
介绍
	c++ 的函数的形参是可以有默认值的
含义
	如果函数调用的时候，不传入参数，就直接使用默认值
	如果传入参数，就使用传入的值
注意
    默认参数必须放在形参列表的最后，不能在形参类表中间
语法
	返回值类型 函数名（参数 = 默认值) { }
	void add(int num1=2, int num2);
使用
    1. 当实参数量少于形参数量，少的就使用默认值
        int add(int num1=1, int num2=2, int num3=3)
        add(3, 3)  // 结果就是 9
    2. 声明、实现只能有一个的形参可以设置默认参数
    	int add(int num1=1, int num2=1);
		int add(int num1, int num2=3) {} ;  // 不允许num2重复赋予默认值
```

#### 占位参数(匿名参数)

```c++
介绍
    形参列表中可以有占位符， 用来占位 ， 调用函数时必须填补该位置
语法实例
    // 声明
    void func(int a, int) ;
    void func(int a, int=10);  // 带默认值
	// 实现
	// 必须参数必须填补
	func(10,10) {};
```



### 特殊参数

#### 数组

```c++
介绍
   C 语言不允许传入一个完整的数组作为函数的参数 
    通过指定不带索引的数组名来传入一个指向数组的指针
	是告诉编译器将要接收一个整型指针

语法例子
	//  每种方式都会告诉编译器将要接收一个整型指针
    // 	函数体内，仍旧可以使用 arr[i] 访问数组数据
    void addfunc(int *param);
    void addfunc(int param[10]);
    void addfunc(int param[]);
```



## 函数体

### 函数变量

### return



## 5.返回值

### 介绍

```c++
返回值列表
	描述了函数返回值的类型 
    ------------------------------
分类
    无返回值
    	返回值的位置 使用 void 占位
    	不包括返回值，函数执行完毕后，不会返回任何值
    有返回值
		必须以 return 语句结尾，除非函数明显无法运行到结尾处， 
		返回数组
    	返回指针
    	返回引用
    
注意
返回局部变量
    方法
        // 返回局部变量 ， 看数组返回
        C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量
    原因
    	因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，
        因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。
		
    	除非将其变量定义为 static 变量，
    	static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。
```



### 1.无返回

```c++
// return语句不能返回任何值, 只是用来结束函数 ，在函数最后一行的时候，可要可不要
void Add(int num1, int num2) {
    return;
}
```



### 数组返回

```c++
介绍
    C 语言不允许返回一个完整的数组作为函数的参数
    通过指定不带索引的数组名来返回一个指向数组的指针
例子
    int* returnArr() {
    	//  C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量
        static int arr[3] = {0, 1, 2};
        return arr;
	}
```



### 指针返回

### 引用返回

```c++
介绍
    // 引用做函数的返回值
    1. 不要返回局部数据的引用
    	 // 例如局部变量、局部对象、局部数组等
    	  因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，
    	  C++ 编译器检测到该行为时也会给出警告。
    2. 函数的调用可以作为左值
例子
 // 不要返回局部变量的引用 
    int& test01() {
        // 局部变量，存放子四区中的  栈区
        int a = 10;  
        return a;
    }
    int main() {
        int &res = test01();
        // 10 第一次编辑器做了保留
        cout << res << endl;
        // 乱码 ，编译器已经做了释放
        cout << res << endl;
    }
// 2. 函数的调用可以作为左值
int &test02() {
    // 静态变量 ， 存放在全局区 ，数据在程序结束后释放
    static int a = 10;
    return a
}
int main() {
    int &res = test02();
    // 10 多少次都是这样
    cout << res << endl;
    // 函数作为左值
    test02() = 1000;
    // 1000 
    cout << res << endl;
}
```

## 6.函数调用

### 本文件调用

```c++
语法
    // 函数名(参数)；
注意
    函数名：需要调用的函数名。
    参数列表：参数变量以逗号分隔，尾部无须逗号结尾。
    返回值变量列表：多个返回值使用逗号分隔
有返回值
    // 需要返回值，要有变量接收 
    int b = add(3,4)；
    // 不需要返回就不用变量接收
    add(3,4)；
无返回值
    // 直接调用
    int a=1,b=2;
    swap(a, b)；
```

### 模块化跨文件调用

```c++
函数分文件写
    头部文件
    	介绍
    		对需要跨文件引用的函数进行声明的文件
    	文件
    		后缀为 .h 的头部文件 
    	内容 
    		进行函数的声明
    		引入文件
    			#include <iostream>
    			using namespace std;
    源文件
    	介绍
    		对需要跨文件引用的函数进行定义的文件
    	文件
    		后缀是 .cpp 的文件
    	内容
    		进行函数的定义
    		引入头部文件 ： #include "头部文件名称"
//---------------------------------------------------------------------------
	调用文件    		
    	介绍
    		就是你写代码的文件 ， 你需要在这个文件进行跨包调用 头部文件中的函数
    	调用
    		#include <iostream>
    		using namespace std;
			#include "源文件名称"
			// 下面就可以直接使用了
```





### 2.调用机制

```go
当程序调用函数时，程序控制权会转移给被调用的函数。
被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。
----------------------------------------------------------------------------
1. 在调用一个函数时，会给该函数分配一个新的空间（栈），编译器会通过自身的处理让这个新的空间和其它的栈的空间区分开来
2. 在每个函数对应的栈中，数据空间是独立的，不会混淆
3. 当一个函数调用完毕(执行完毕)后，程序会销毁这个函数对应的栈空间。
```

### 3.调用过程

```go
1.函数在定义之后，皆可调用
2.可以通过调用的方式,让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。
3.函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失。
```



## 函数重载

### 介绍

```c++
作用
    函数名相同，提高复用性
满足条件
    1. 同一个作用域下
    2. 函数名称相同
    3. 函数参数的类型、或者个数 、或者顺序不同
 注意
    函数的返回值不可以作为函数重载的条件
```

### 例子

```c++
// 条件1
    1. 同一个作用域下
    2. 函数名称相同
    3. 函数参数的类型、或者个数 、或者顺序不同
 例子
    void fun() { cout<<"test1"<<endl;}
    void fun(int num1) { cout<<"test2"<<endl; }
    void fun(double num2)   { cout<<"test3"<<endl; }

    int main() {
        fun();  // test1
        fun(1);  // test2
        fun(1.1);  // test3
    }

// 条件2 
	引用作为函数重载的条件
例子
    void fun() { cout<<"test1"<<endl;}
    void fun(int &num1) { cout<<"test2"<<endl; }
    void fun(const int &num1)   { cout<<"test3"<<endl; }

    int main() {
        // a 可读可写，所以调用 test2
        int a = 10;
        fun(a);  // test2

        // int &num1 = 10 不合法，所以不会调用 test2
        fun(10);  // test3 
    }

条件3
    函数重载碰到默认参数
    void fun() { cout<<"test1"<<endl;}
    void fun(int num1, int num2=10) { cout<<"test2"<<endl; }
    void fun(int num1)   { cout<<"test3"<<endl; }

    int main() {
        fun();  // test1
        // 编译器出现二义性，会报错，应该尽量避免使用
        fun(10);  
    }
```



## 内存布局

### 函数指针

```c++
介绍
    指向函数的指针变量就叫函数指针
    可以像一般函数一样，用于调用函数、传递参数。
    说指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数
    
    
函数名
	一个函数在编译之后，会占据一部分内存，而它的函数名，就是这段函数的首地址。
    可以把一个指针声明成为一个指向函数的指针
    C 语言规定函数名会被转换为指向这个函数的指针，除非这个函数名作为 & 操作符或 sizeof 操作符的操作数。
函数底层
    对于： 
    // 两种方法都会得到指向该函数的指针
     f = test ; 直接引用函数名等效于在函数名上应用 & 运算符 ，test 被自动转换为 &test
	 f = &test; 中已经显示使用了 &test，所以 test 就不会再发生转换了
    // *test --> *(&test) --> test --> &test
 特点
     指向函数的指针必须初始化，或者具有 0 值，才能在函数调用中使用
     // 与数组一样
     禁止对指向函数的指针进行自增运算++
     禁止对函数名赋值，函数名也不能用于进行算术运算。
         
语法例子
     // 声明一个指向同样参数、返回值的函数指针类型
     // 返回值（*函数指针名）(参数类表)；
     int(*p)(int, int);

实例
    int max(int a, int b) {return a+b;};
	int(*p)(int,int);
	//把函数Max赋给指针变量p, 使p指向Max函数
	p = max;
	//通过函数指针调用Max函数
	int c = (*p)(1, 2);
	// 等价于 max(1,2)
	int c = p(1, 2);
	
	 // error，标准禁止对指向函数的指针进行自增运算
	 p++;
     // error，不能对函数名赋值，函数名也不能用于进行算术运算
      p = P + 2;

```



### 指针函数

```C++
介绍
    返回指针的函数
```

### 两者混用

```c++
函数指针 + 指针函数
    函数的返回值不仅仅局限于指向变量的指针，也可以是指向函数的指针
```



## 7.特殊函数

### 构造函数

```c++
详情见 class 中的方法
```

### 析构函数

```c++
详情见 class 中的方法
```



### 递归函数

```c++
详情见 数据算法与结构  递归函数 + 树
```



### 回调函数

```c++
介绍

    一个函数的参数是函数，函数在调用的时候，会调用这个函数参数
    参数函数就叫回调函数 ，主函数就叫回调实现者
阐述
    // 函数 a 的参数是一个参数 b ，
    // 函数 a 调动的时候会调用函数 b ， 即 a 执行函数的时候，会后头调用 函数 b 
    // 函数 b 就叫回调函数 ，函数 a 是回调实现者

注意
    函数做参数，使用的是函数指针，调用者可以传递一个函数的地址给实现者，让实现者去调用它
    关于函数指针的，看函数指针
    
语法例子
    // 回调实现者 func1 ，回调函数 f2
    void func1(int arg, void (*f2)(int)) {
    	cout <<  "接收到参数 arg ," << arg << endl;
    	// 调用参数函数
    	f2(arg);
	}
    
	void hello(int a) {
        cout << "这里是 hello" << endl;
        cout << "回调成功, 传入 " << a << endl;
    }
	int main() {
        // 注意 hello 函数并没有写参数 ，具体看函数指针
        func1(666, hello);
        // 接收到参数 arg ,666
        // 这里是 hello
        // 回调成功, 传入 666
        return 0;
    }
```



### 3、匿名函数

*   介绍
    *   即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体 
    *    匿名函数也往往以变量方式传递 
    *    支持随时在代码里定义匿名函数 

*   定义格式

    ```go
    // 匿名函数就是没有名字的普通函数
    
    func(参数列表)(返回参数列表){
        函数体
    }
    ```

*   调用

    1.  定义的时候进行调用

        ```go
        1. 这种匿名方式只能调用一次
        //--------------------------------------------------------
        a := func （n1 int,n2 int）int(){
        		return n1 + n2
        }(10,20)  // (10,20) 即为对函数的调用，传入的参数是 (10,20)
        ```

        

    2.  匿名函数赋值给变量

        ```go
        1.实现多次调用
        2.将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数
        3.全局匿名函数
        	将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序中有效
        
        //-------------------------------------------------------
        func （n1 int,n2 int）int(){
        		return n1 + n2
        }
        var a func()
        a = 
         a（10 ， 20） // a 调用匿名函数
        
        
        // 全局匿名函数
        
        var (
            FUN1 := func （n1 int,n2 int）int(){
        		return n1 + n2  }
        )
    res := FUN1(10 ,20)
        ```
        
        

* 使用
  
  *   匿名函数作为回调函数
    
      ```go
        //  回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
        // 回调方法 是 任何一个 被 以该回调方法为其第一个参数 的 其它方法 调用 的方法。很多时候，回调是一个当某些事件发生时被调用的方法。
        
        
        // 使用 visit() 函数将整个遍历过程进行封装，
        // 当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。
        
        func visit (list []int, f func(int)) {
            // // 遍历切片的每个元素, 通过给定函数进行元素访问
            for _, v := range list{
                f(v)
            }
        }
        
        func main(){
            // 使用匿名函数打印切片内容
            visit([]int{1,2,3,4},func(v int)){
                // 定义了一个匿名函数，作用是将遍历的每个值打印出来。
                fmt.Println(v)
            }
        }
      ```
  
  *   匿名函数实现封装
  
      ```go
      //
      
      // 定义命令行参数 skill，从命令行输入 --skill 可以将 = 后的字符串传入 skillParam 指针变量。
      var skillParam = flag.String("skill","","skill to perform")
      
      func main(){
          
          // 解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值
          flag.Parse()
          
          // 定义一个从字符串映射到 func() 的 map，然后填充这个 map . 
          // 初始化 map 的键值对，值为匿名函数
          var skill = map[string]func(){
              "fire" : func() {
                  fmt.Println("chicken fire")
              },
              
              "run" ： func() {
                  fmt.Println("soldier run")
              },
              
              "fly" : func(){
                  fmt.Println("angel fly")
              },
          }
          
          // skillParam 是一个 *string 类型的指针变量，
          // 使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。
          if f,ok := skill[*skillParam]; ok {
              f()
          } else {
              fmt.Println("skill not found")
          }
      }
      
      // 运行
      go run main.go --skill=fly  // angel fly
      ```
  
      
  
  ​      



## 函数操作

### 相同函数

```c++
相同类型

*    如果两个函数形式参数列表和返回值列表中的变量类型一一对应，
*    这两个函数被认为有相同的类型和标识符，
*    形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。 
```







 

## 7.使用

*   函数作为一种数据类型
    *   函数是一种数据类型，可以赋值给一个变量，则改变量就是一个函数，通过该函数可以对函数调用

### 1. 把函数赋值给变量

*    函数也是一种类型，可以和其他类型一样保存在变量中 

```go
// go 中函数也是一种数据类型，可以赋值给一个变量，
// 该变量就是一个函数，通过该函数可以对函数进行调用

// 定义了一个函数变量 f，并将一个函数名为getsum() 的函数赋给函数变量 f，
// 这样调用函数变量 f 时，实际调用的就是 getsum() 函数

func getsum (n1 int ,n2 int)int{
	return  n1 + n2
}
var f func()
f := getsum
res := f( 10 , 20 )

```

### 2. 函数作为形参 - 回调

```go
// 函数是一种数据类型，
// 所以可以做为参数进行传递，然后再其他函数内执行调用
// 作为主调函数的形参的类型，即传递一个指向函数的指针

func myfun (getsum(n1 int,n2 int) , n3 int)
res := myfun(getsum,50,60)

//------------------------------------

 
//提供一个接口，让外部去实现
func test(x, y int, callbackfunc (x, y int) int) int {
  return callback(x, y)
}
 
func add(x, y int) int {
  return x + y
}
 
func main() {
  x, y := 6, 7
  z := test(x, y, add)	
  fmt.Printf("z = %d",z)
}
```



### 3.函数作为返回参数

```go
func complexF2() (re float64, im float64) {
    return complexF1()
}
```



* 函数中的变量是局部的，函数外不生效

* 基本数据类型和数组默认都是值传递的，即进行值拷贝。在函数内修改，不会影响到原来的值。

  函数中和函数外部的变量可以一样，他们不互相影响，但是不建议这样做

* 如果希望函数内的变量能修改函数外的变量(指的是默认以值传递的方式的数据类型)，可以传入变量的地址&，函数内以指针的方式操作变量。从效果上看类似引用。

  ```go
  func test(b1 *int){
      *n1 = *n1 + 10
      fmt.Print("test() n1="*n1) // test() n1=30
  }
  
  func mian(){
      num := 20
      test(&num)
      fmt.Println("main() num=",num) //main() num=30
  }
  //
  ```

  

