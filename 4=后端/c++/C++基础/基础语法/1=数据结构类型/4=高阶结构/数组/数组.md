@[toc]
## 1.数组

###  1.概念

*   一个由固定长度的   特定类型   元素组成的序列 ，元素个数>=0，长度固定，所以很少使用
*   性质是
    *   值类型
*   优点
    *   使用数组来解决问题，程序的可维护性增加。而且方法代码更加清晰，也容易扩展。

## 2.声明赋值

### 介绍

*   数组创建后，如果没有赋值，有默认值(参看各种数据类型默认值)
*   数组是多个相同类型数据的组合，一旦声明/定义了，其长度是固定的，不能动态变化。否则就会报越界

### 1.单维数组

```go
方式
	参看变量的声明赋值四种形式
标准声明
    var name [ 元素数量 ]Type 
    name    (数组名)   :数组变量名字, 数组声明及使用时的变量名。 
    size	元素数量（数组大小）   
            1.数组的元素数量，数组的长度必须是常量表达式，要在编译阶段确定
             2.但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。
    Type    (数组类型)  
             1.可以是任意数据类型，包括数组本身，类型为数组本身时，可以实现多维数组。
			2.不能混用值类型和引用类型

// 四种初始化数组的方式
// 先声明，后赋值
// 声明的时候赋值
    var a [3]int = [3]int{100,200,300}   //数组字面值语法，用一组值来初始化数组：
// 简写
// 类型推导
	// 左值推类型
    var a  = [3]int{100,200,300}
// 索引类型简写
	// 右值推长度
    var a  = [...]int{100,200,300}   // “...”省略号，则表示数组的长度是根据初始化值的个数来计算
	// 初始化指定元素：根据索引值确定左值
	// 声明并初始化数组中索引为 1 和 3 的元素
    var a  = [...]int{1：100，3：300}  //类型推导

```

### 2.多维数组

````go
方式
	参看变量的声明赋值四种形式
	和一维数组一样的
标准形式
	var array_name [size1]...[sizeN]Type
 
 array_name   为数组的名字
 size1、sizeN 等等为数组每一维度的长度
 array_type   为数组的类型

标准形式
     //四个元素/四个维度，每个元素指向一个数组，就是四个数组 ，每个数组有两个元素       
	var array [4][2]int  
	array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}                                      
// 声明的时候赋值
	var 数组名 [大小][大小]类型 = [大小][大小]类型{{初始值}，{初始值}}
// 类型推倒
	// 全右值
	var 数组名                 = [大小][大小]类型{{初始值}，{初始值}}
// 索引类型简写
	// 省略右值长度
    var 数组名                 = [...][大小]类型{{初始值}，{初始值}}
	// 初始化指定元素：根据索引值确定左值
	// 声明并初始化数组中索引为 1 和 3 的元素
	array = [4][2]int{1: {20, 21}, 3: {40, 41}}
元素个数： 内置函数 len() 可以返回数组中元素的个数。
````



## 3.访问数组元素 

*   数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置 
*   数组的下标是从0开始的
*   数组下标必须在指定范围内使用，否则报panic:数组越界，

### 1.单维数组

```
  数组名 [ 下标 ]  ：a [ 2 ]
```

### 2.多维数组

```go
// 访问单个元素，需要反复组合使用[ ]方括号
      var array2 [2][2]int
      var array1 [2][2]int
// 设置每个元素的整型值
       array1[0][0] = 10
       array1[0][1] = 20
       array1[1][0] = 30
       array1[1][1] = 40
//  同样类型的多维数组可以相互复制
 	   rray2 = array1
// 因为数组中每个元素都是一个值，所以可以独立复制某个维度,
 	   var array2 [2]int = array1[1]  //将 array1 的索引为 1 的维度复制到一个同类型的新数组里
// 将数组中指定的整型值复制到新的整型变量里
	   var value int = array1[1][0]    

```



## 4.内存布局

### 1.单维数组

1. 数据的地址可以通过数组名来获取    ： &a
2. 数组的第一个元素的地址，就是数组的首地址
3. 数组的各个元素的地址间隔是依据数组的类型的决定的 ：比如int64 - 》8

### 2.多维数组

```go
1. 先创建一个数组的地址，第一个元素的地址和整个数组的地址是一样的，但是第二个元素的地址是在第一个元素的地址的基础上加上第二个元素相应的数据类型的字节数，就是第二个元素的地址，以此类推
2. [size1]...[sizen]第二个元素和第一个元素之间的地址相差的字节数正好是第一个元素的所有数据的字节数
3. 地址都是在最左边标记的，所以第一个元素和第二个元素之间的地址空间就是第一个元素的数组的数据站的字节数，就可以推到出来第一个元素的数组的第一个元素的地址，（记住地址是在方格的最左边标记的）
```

## 5.比较

* 数组比较条件

  *   两个数组类型相同（数组长度、数组中元素的类型）：可用比较运算符==  和 ！=

  *   只有所有元素都相等的数组才是相等的，

  *   不同类型的数组不可比较，否则程序无法执行

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int

[3]int 和 [4]int 是两种不同的数组类型 
```

## 6.使用

### 1.使用步骤
```go
1. 声明数组，开辟空间
2. 给各个元素赋值
3. 使用数组
```

### 2.遍历

```go
for k, v := range  {}
// 使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。
```

## 7.使用注意

1. 是值传递，会进行值传递，数组间不会相互影响，如果要在其他函数中修改原来的数组，需要用指针方式，通过地址修改
7. 长度是数组类型的一部分，在传递函数参数时需要考虑数组的长度，（数组间长度一样的才能相互传递）：
   * 不能大传小，也不能小传大（元素数量）
   * 切片和数组是不同的

## 跳转
* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)


