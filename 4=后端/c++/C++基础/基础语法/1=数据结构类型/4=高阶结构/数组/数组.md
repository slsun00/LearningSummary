@[toc]
## 1.数组

###  1.概念

*   一个由固定长度的   特定类型   元素组成的序列 ，元素个数>=0，长度固定，所以很少使用
*   数组就是一个集合 ，里面存放了相同元素的数据元素
*   特点
    *   数组中的每个数据元素都是相同的数据类型
    *   数组是由连续的内存位置构成的
    *   最低的地址对应第一个元素，最高的地址对应最后一个元素。
*   优点
    *   使用数组来解决问题，程序的可维护性增加。而且方法代码更加清晰，也容易扩展。

## 2.声明赋值

### 介绍

```c++
注意
	数组是多个相同类型数据的组合，
    一旦声明/定义了，其长度是固定的，不能动态变化，否则就会报越界
    
数组名是常量， 不允许进行赋值修改
    int arr[2];
	arr = 10;  // 出错
	所以数组赋值只能在初始化的时候赋值，然后就是一个下表索引一赋值
        
数组名
      // 数组名是一个指向数组中第一个元素的常量指针
	查看内存布局 --  数组指针
        
```



### 1.单维数组

```go
变量声明的方式
// 先声明后赋值
	数组类型 数组名[数组长度];
	例子
		int a[3];
		a[0] = 3; a[1]=2; a[2]=3;
	注意
		// 错误， 数组名不是一个变量，是个常量 ，值代表第一个数据元素的地址
		// 不能对数组赋值，只能对数组元素初始化或赋值。
		a = {1,2,3}


// 声明的时候赋值
	// 非推导类型
	数组类型 数组名[数组长度] = {值1， 值2， 值3，...}
    // 长度推倒
    数组类型 数组名[] = {值1， 值2， 值3，...}

注意
	int arr[size] = {valueSize} 
	size < valueSize   // 多余的位置
	size > valueSize   // 不足的位置用 0 填充
```

### 2.多维数组

````go
方式
	参看变量的声明赋值四种形式

// 先声明后赋值
	数据类型 数组名[ 行数 ][ 列数 ]；
	int arr[2][2];
	arr[1][1] = 3;
// 声明的时候赋值
	数据类型 数组名[ 行数 ][ 列数 ] = 
		{ 
            {0行0列数据1，0行1列数据2,...},  // 一行一个一维数组
            {1行0列数据1，1行1列数据2,...},
            ...
        };
// 数量推倒 ，这种先在一行填充满列数 ，然后再进行下一行的填充，不够的部分使用默认值，多余的舍去
数据类型 数组名[ 行数 ][ 列数 ] = {数据1 ，数据2， 数据3， 数据4，...};
数据类型 数组名[      ][ 列数 ] = {数据1 ，数据2， 数据3， 数据4，...};


````



### 3.默认值

```js
介绍
	对数组中元素初始化，而没有初始化的元素在默认的情况下会用数值0填充，
    代表的是空字符(NULL或\0)

注意
	一个数组，没有对其初始化，那么其输出的数据会是垃圾数据，而不是没有值
    
声明的时候，没有进行初始化赋值的部分就用默认值填充了
    int a[3] = {1,2}
    // a[2] 的值就是 0 
越界的数组访问也使用默认值
```

## 内存布局

### 占用空间+长度

* 介绍

    ```c++
    首地址
    	数组指针 = 数组首地址 = 数组第一行首地址 = 数组第一行第一个元素的地址
        数组第 n 行首地址 = 第 n 行第一个元素首地址
    ```

    

* 单维数组

    ```c++
    1. 可以统计整个数组在内存中的长度
        数组占用内存长度   sizeof(a)
        数组元素占用内存长度 sizeof(a[0])
        数组长度 len = sizeof(a) / sizeof(a[0])
    2. 获取数组在内存中的首地址
        // 第一个元素的地址就是数组在内存中的首地址
        直接输入 (int)a 就可以得到
        sizeof(a[0])
    ```

* 多维数组

    ```c++
    3. 数组第一行
        占用的内存	sizeof(arr[0])
        首地址(第一个元素)    (int)a[0]
        
    第二行首地址 (int)arr[1]
        
    4. 数组
        首地址
           // 第一个元素的地址就是数组在内存中的首地址
            直接输入 (int)arr 就可以得到
            (int)&arr[0][0]
        占用内存长度   sizeof(arr)
        元素占用内存长度 sizeof(arr[0][0])
        长度 len = sizeof(a) / sizeof(a[0])
        行数  row = sizeof(a) / sizeof(a[0])
        列数	col = sizeof(a[0]) / sizeof(a[0][0])
    ```

* 数组元素地址

    ```c++
    cout << "方法一：" << endl;
    	for(int i = 0; i != ArraySize; i++)
    	cout << "&arr[" << i << "] = " << &arr[i] << endl;
    cout << "方法二：" << endl;
    	for(int i = 0; i != ArraySize; i++)
        cout << "[arr+" << i << "] = " << arr+i << endl;
    cout << "方法三：" << endl;
    	for(int i = 0,*p = arr; p != (arr+ArraySize) && i != ArraySize; i++,p++)
        cout << "p -[" << i << "]= " << p << endl;
    ```

    

### 数组指针

```css
数组名
      // 数组名是一个指向数组中第一个元素的常量指针
      数组名本身不是变量，所以它不占用存储空间，也不能用来存储数据
      它只是代表一个数据，作为值时，它代表数组中第一个数据元素的地址

注意
	1.数组名作为常量指针是合法的，反之亦然。因此
        *(balance + 4) 是一种访问 balance[4] 数据的合法方式
    2. 编译器在编译时对数组中的方括号做了相应的变换：（两边都是相互等价的）
        arr[i] <=> *(arr+i)
        *(arr+i) <=> *(i+arr)
        *(i+arr) <=> i[arr]
        arr[i] <=> i[arr]
        i 是偏移量，表示偏移第一个元素的元素个数

例子
    double *p;
    double balance[10] = {1, 2, 3, 4, 5};
    p = balance;  // 可以
	// 以下三种结构都是一样的
    for ( i = 0; i < 5; i++ ) {
        cout << *(p + i) << endl;
    }
    for ( i = 0; i < 5; i++ ) {
        cout << *(balance + i) << endl;
    }
    for ( i = 0; i < 5; i++ ) {
        cout << balance[i] << endl;
    }
```







## 数组操作

### 访问数组元素 

* 介绍

    ```c++
    *   数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置 
    *   数组的下标是从0开始的
    *   数组下标必须在指定范围内使用，否则报panic:数组越界，
        
    // 越界访问会返回数据的初始值
        int arr[2] = {1, 2}；
    	cout << arr[2] << endl;  // 就是  0
    ```

* 单维数组

    ```c++
    数组名 [ 下标 ]  
     int arr[2] = {1, 2}；
     cout << arr[1] << endl;  // 2
    ```

* 多维数组

    ```js
    水泥管子
    ```

### 遍历

```c++ 
使用 for 循环进行循环遍历打印
   int arr[5] = {300, 350, 200, 400, 250}; 
   for (int i = 0; i<=(len-1); i++) {
        cout << arr[i] <<" ";
    }
    cout << endl;
    return 0;
}


编译器在编译时对数组中的方括号做了相应的变换：（两边都是相互等价的）
    arr[i] <=> *(arr+i)
    *(arr+i) <=> *(i+arr)
    *(i+arr) <=> i[arr]
    arr[i] <=> i[arr]
    i 是偏移量，表示偏移第一个元素的元素个数
    
for(int i = 0; i != ArraySize; i++)
    // 方法一
    cout << arr[i] << ' ';
    // 方法二
    cout << *(arr+i) << ' ';
    // 方法三
    cout << i[arr] << ' ';
	
// 方法四
	// 指针每自增一个值，就移动到一个元素的位置
	指针自增遍历
 		{ int* p = arr; cout <<  p; p++; }
    指针自减遍历
		{ int* p = arr[ArraySize-1]; cout <<  p; p--; }
 

 //越界访问数组中的数据元素
 cout << "越界访问的后果！" << endl;
 int iNum = 123,iLen = 90;
 int array[7] = {10,3,6,8,5,9,7};
 
 //越界访问数据可能会访问到无法与之的数据
 for(int i = -2; i != 9; i++)
  cout << array[i] << ' ';
 cout << endl;
 
 cout << iNum << "---" << iLen << endl;

 //越界存放数据可能会影响其它变量的值，甚至可能会导致程序崩溃（没有发生这种情况，怪哉！！！）
 for(int i = -2; i != 7; i++)
  cin >> array[i];
 for(int i = 0; i != 7; i++)
  cout << array[i] << ' ';
 cout << endl;
 cout << iNum << "---" << iLen << endl;
 return 0;
}
```

### 复制

```c
直接赋值
	int arr[3] = {1,2,4}
    int s[3];
    // 这样复制是错误的 
    s = arr;
	原因
        就是不要对数组名做除了内存测量之外的操作，详情见介绍中的数组名
```





## 4.内存布局

### 1.单维数组

1. 数据的地址可以通过数组名来获取    ： &a
2. 数组的第一个元素的地址，就是数组的首地址
3. 数组的各个元素的地址间隔是依据数组的类型的决定的 ：比如int64 - 》8

### 2.多维数组

```go
1. 先创建一个数组的地址，第一个元素的地址和整个数组的地址是一样的，但是第二个元素的地址是在第一个元素的地址的基础上加上第二个元素相应的数据类型的字节数，就是第二个元素的地址，以此类推
2. [size1]...[sizen]第二个元素和第一个元素之间的地址相差的字节数正好是第一个元素的所有数据的字节数
3. 地址都是在最左边标记的，所以第一个元素和第二个元素之间的地址空间就是第一个元素的数组的数据站的字节数，就可以推到出来第一个元素的数组的第一个元素的地址，（记住地址是在方格的最左边标记的）
```



## 6.使用

### 综述

```c++
1. 作为函数参数
2. 作为函数返回值
    // 详情见函数中 参数  、 返回值
   C 语言不允许传入/返回一个完整的数组作为函数的参数 
    通过指定不带索引的数组名来传入/返回一个指向数组的指针
```



### 2. 做函数返回值

```c++
介绍
	您可以通过指定不带索引的数组名来返回一个指向数组的指针
例子
    int* all() {
    	static int a[10] = {1,2};
    	return a;
	}
	// 主函数调用
	int* p = all();
```



## 7.使用注意

1. 是值传递，会进行值传递，数组间不会相互影响，如果要在其他函数中修改原来的数组，需要用指针方式，通过地址修改
7. 长度是数组类型的一部分，在传递函数参数时需要考虑数组的长度，（数组间长度一样的才能相互传递）：
   * 不能大传小，也不能小传大（元素数量）
   * 切片和数组是不同的

## 跳转
* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)


