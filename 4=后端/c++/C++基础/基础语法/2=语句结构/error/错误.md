* # 错误



## 1.错误处理思想及特征

*    一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。
*    在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。

*    在默认情况下，当发生错误后(panic)，程序就会退出(崩溃.)
*    当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行。



## 2.错误

### 1.错误接口

```go
type error interface {
    Error() string  // string 是返回的错误描述
}
所有符合 Error()string 格式的方法，都能实现错误接口，即这个类型的实例为错误接口的实例

所有实现该接口的类型都可以当作一个错误类型。
	即函数返回 error 时，可以返回实现错误接口的类型

在使用 fmt.Println 打印错误时，会在内部调用 Error() string 方法来得到该错误的描述
```

### 2.自定义错误

#### 1.errors.New

*   使用

    ```go
    var err = errors.New("this is an error")  
    
    
    func New(text string) error
      
      // 直接在代码中使用就行，没其他的
      func xxx()(err error){
          return errors.New("自己定义的错误输出")
      }
    
    //---------------------------------------------
    1. 错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回
    ```

*   底层

    ```go
    // new 实现原理
    
    // 错误对象
    func New(text string) error {
        return &errorString{text}
    }
    
    // 错误字符串
    type errorString struct {
     s string
    }
    
    //返回发生何种错误
    func (e *errorString) Error() string {
        return e.s
    }
    
    
    ```

#### 2.解析时使用自定义错误

*    解析错误的结构还实现了 error 接口的 Error() 方法，返回错误描述时，将自定义的错误信息返回

##### 1.结构体 + 字段

```go
// error 底层，这个引入包就有
type error interface {  
    Error() string
}
//---------------

// 声明一个解析错误
type ParseError struct {
    Filename string // 文件名
    Line     int    // 行号
}
// 实现error接口，返回错误描述
func (e *ParseError) Error() string {
    return fmt.Sprintf("%s:%d", e.Filename, e.Line)
}
// 创建一些解析错误
func newParseError(filename string, line int) error {  // 这里的 error就是Errors 包中的error接口
    return &ParseError{filename, line}  // 注意这里
}
// 解析函数
func newParse (filename string, line int) error {
    if filename == "" {
        return &ParseError{filename, line}  // 注意这里
    }
}
func main() {
    var e error
    // 创建一个错误实例，包含文件名和行号
    e = newParseError("main.go", 1)
    // 通过error接口查看错误描述
    fmt.Println(e.Error())
    // 根据错误接口具体的类型，获取详细错误信息
    switch detail := e.(type) {
        case *ParseError: // 这是一个解析错误
            fmt.Printf("Filename: %s Line: %d\n", detail.Filename, detail.Line)
        default: // 其他类型的错误
            fmt.Println("other error")
    }
    
    //---------------------------------------------------------
    
    s , err := newParse("",666)
    if err != nil {
        if err,ok  := err.(*ParseError);ok {
            fmt.Printf("输入错误参数："，err.filename)
            return
        }
        fmt.Println(err)
        return
    }
}

```

##### 2.结构体 + 方法

```go
// 定义一个错误结构体
type xxxError struct {  
    err    string	//存储了实际的错误信息
    radius float64	//它存储了与错误有关的半径
}

// 实现 error 接口 ,返回了关于错误的描述
func (e *xxxError) Error() string {  
    return e.err
}

// 错误类型添加方法，使它提供了更多的错误信息。
func (e *xxxError) lengthNegative() bool {  
    return e.length < 0
}

//错误类型添加方法，使它提供了更多的错误信息。
func (e *xxxError) widthNegative() bool {  
    return e.width < 0
}


// 实际引用
func rectArea(length, width float64) (float64, error) {  
    err := ""	 //?? 这个是什么意思？
    if length < 0 {
        err += "length is less than zero"
    }
    if width < 0 {
        if err == "" {
            err = "width is less than zero"
        } else {
            err += ", width is less than zero"
        }
    }
    if err != "" {
        return 0, &areaError{err, length, width}
    }
    return length * width, nil
}



// 主程序
func main() {  
    length, width := -5.0, -9.0
    area, err := rectArea(length, width)
    if err != nil {
        if err, ok := err.(*areaError); ok {
            if err.lengthNegative() {
                fmt.Printf("error: length %0.2f is less than zero\n", err.length)

            }
            if err.widthNegative() {
                fmt.Printf("error: width %0.2f is less than zero\n", err.width)

            }
            return
        }
        fmt.Println(err)
        return
    }
    fmt.Println("area of rect", area)
}
```



* 自定义包中的错误处理和 panicking，这是自定义包实现者最佳实践

    

#### 3. fmt.Errorf

```go
// 直接使用

func xxx()(err error){
    return fmt.Errorf("格式化的错误提示，抵用动词格式化"）
    // 比如 ：return fmt.Errorf("半径错误,r = %f 不是整数 ",v）                  
}
```

### 3.断言

```go
补充
类型断言格式： y, ok := x.(T)

err, ok := err.(*os.PathError) //成功：f为os.PathError，ok为true，否则ok为false

ok值通常立刻用于决定是否执行下一步，惯用法：

if f, ok := w.(*os.File); ok { // ... use f ... }
```

## 2.panic - 宕机

### 介绍

*    当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer  机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value  通常是某种错误信息。 
*    发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。

*    panic 会引起程序的崩溃， 用来表示非常严重的、不可回复的错误
*    panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用Go语言提供的错误机制，而不是 panic。
*    不可以随意用 panic 终止程序，必须尽力补救错误让程序能够执行 

### 底层

```go
func panic(v interface{})    //panic() 的参数可以是任意类型的。输出错误信息，并退出程序.
```

### 触发宕机

*    在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失 
*    Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置 

#### 手动触发宕机

```go
package main
func main() {
    panic("crash")
}
```

#### 运行依赖的必备资源缺失

*    当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。 

     ```go
     //  func Compile(expr string) (*Regexp, error)
     //  func MustCompile(str string) *Regexp
     func MustCompile(str string) *Regexp {
         regexp, error := Compile(str)
         if error != nil {
             panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())
         }
         return regexp
     }
     ```

### 宕机处理 

####  defer 延迟

*    当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作 

*   必须先声明defer ,否则不能捕获到 panic 异常。

*   普通函数在执行的时候发生 panic 了，则开始运行 defer, defer处理完再返回

    ```go
    // defer + panic
    
    func main() {
        defer fmt.Println("宕机后要做的事情1")
        defer fmt.Println("宕机后要做的事情2")
        panic("宕机")
    }
    // 结果
    宕机后要做的事情2
    宕机后要做的事情1
    panic: 宕机
    ```

#### recover 恢复

*    通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作 

*    Go语言的内建函数

     *   以让进入宕机流程中的 goroutine 恢复过来
     *   让程序冲 panicking 重新获得控制权，停止终止过程进而恢复正常执行


*    只能用在 defer 修饰的函数中

     *   用于取得 panic 调用中传过来的错误值，如果正常执行，调用 recover 会返回 nil ,且没有其他效果

*   panic 和 recover

    ```go
    1.    有 panic 没 recover，程序宕机。
    2.    有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。
    3.	  panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。
    4. 	  在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。
    5. 	  如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。
    ```

    

*   总结

    *   panic 会导致栈被展开到 defer 修饰的 recover() 被调用或者程序终止

```go
// 下面的代码实现了 ProtectRun() 函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生 panic 崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。

/ 崩溃时需要传递的上下文信息
type panicContext struct {
    function string // 所在函数
}
// 保护方式允许一个函数
func ProtectRun(entry func()) {
    // 延迟处理的函数
    // 使用 defer 将闭包延迟执行，
    // 当 panic 触发崩溃时，ProtectRun() 函数将结束运行，此时 defer 后的闭包将会发生调用。
    defer func() {
        // 发生宕机时，获取panic传递的上下文并打印
        // recover() 获取到 panic 传入的参数。
        err := recover()
        switch err.(type) {
            case runtime.Error: // 运行时错误
                fmt.Println("runtime error:", err)
            default: // 非运行时错误
                fmt.Println("error:", err)
        }
    }()
    
    entry()
}


func main() {
    fmt.Println("运行前")
    	
    // 允许一段手动触发的错误
    ProtectRun(func() {
        fmt.Println("手动宕机前")
        // 使用panic传递上下文
        panic(&panicContext{
            "手动触发panic",
        })
        fmt.Println("手动宕机后")  // panic 没有执行
    })
    
    // 故意造成空指针访问错误
    ProtectRun(func() {
        fmt.Println("赋值宕机前")
        var a *int
        *a = 1
        fmt.Println("赋值宕机后")  // panic 没有执行
    })
    
    fmt.Println("运行后")    // 执行了..
}
// 结果
运行前
手动宕机前
error: &{手动触发panic}
赋值宕机前
runtime error: runtime error: invalid memory address or nil pointer dereference
运行后
```





## 1、 panicking

* 多层嵌套函数中调用 panic ,可以马上终止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者，这样向上冒泡直到最顶层，并执行每层的 defer  , 在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况，这个终止情况就是 panicking





## 4、使用

### 1.defer +recover 

* Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理

* 进行错误处理后，程序不会轻易挂掉，如果加入预警代码，就可以让程序更加的健壮。

    ```go
    func test(){
        //使用defer + recover 来捕获和处理异常
    	defer  func(){
    		err := recover()    //recover()内置函数，可以捕获异常
    		if err != nil{      //说明捕获错误
    			fmt.Println("err = ",err)
             fmt.Print("请发送错误")
            }    
    	}()	 // 这个就是代码处理机制
        
        // 编写需要执行的代码块 
        
    }()
    
    // 使用
    直接调用函数test(),如果函数出错了，就会执行里面的匿
    ```










