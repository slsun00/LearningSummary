

# 前言

# go中的类型传递

*   都是值传递
    *   值传递 ： 就是内存传递，将内存中值复制一份传递出去
    *   引用传递 ： 地址传递

# 1.变量

*   variable

* 变量相当于内存中一个数据存储空间的表示

  数据存在存储空间中，则这个存储空间的名字叫变量（可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间（数据在房间里），同样，通过变量名可以访问到变量(值)。）

* 变量表示内存中的一个存储区域，该区域有自己的名称(变量名)和类型(数据类型)

```go
数学概念--->  没有固定值且可改变的数
计算机实现--> 一段或者多段用来储存数据的内存
```



# 2.声明/赋值

## 介绍

*   go语言是静态类语言，因此变量必须有明确的类型，编译器就会检查变量的正确性

*   注意

    ```c++
    初始化
    	就是一个名词，一个变量声明后，第一次赋值就叫初始化
        
    变量三要素  
    	变量= 变量名 + 值 + 数据类型
    概念
     	int a;创造了一个变量 a，我们把这个过程叫做 //变量定义。
        a=123;把 123 交给了变量 a，我们把这个过程叫做给 //变量赋值；
        	又因为是第一次赋值，也称 //变量的初始化、赋初值。
    ```

## 方式

```go
1. 先声明后赋值		
	标准形式
	//指定变量类型，声明后不赋值，使用默认值
2. 声明的时赋值
	显式地标明变量的类型，在多变量同时声明时可以用到
3. 简写格式

4. 类型推倒
// -----------------------
索引类型
	1. 根据省略长度，进行推倒(见数组)
	2. 赋值填充
		1. 键值对填充(根据索引键值对确定)
        2. 值列表
        3. 访问字段名填充
```



## 单个命名c

```c++
先声明后赋值
    变量类型 变量名；
    int a;
	a = 1;
声明的时候赋值
    数据类型 变量名 = 变量初始值；
    int a = 1;
```





## 批量命名c

```go
规则
	批量赋值，等到的左值和右值从左到右的顺序赋值
相同类型
	// 先声明后赋值
	int a, b, c;
	a = 1; b = 2; c = 3;
	// 声明的时候赋值
	int a = 1, b = 2 ,c = 3
不同类型
	// 应该无法同时声明
```

## 默认值

*   介绍

    ```js
    数据类型都有一个默认值，当声明时没有赋值，就会使用默认值
    默认值又叫零值
    // 初始默认值就是  ：初始但未引用的值
    ```
    
* 不同类型数据结构的初始值

    ```go
    //基础类型
    数值
    	整形		int short long 均为 0  long long 为43 (???)
    	浮点		float 为 0  double为无穷小(7.90505e-323)
    文本
    	字符串		     // 空字符串 , 啥也没有 ，输出为空
    	字符			 // 空字符串 , 啥也没有 ，输出为空
    布尔
    	布尔			0（false）
    
    -----------------------------------------------------------------
    面向对象
    	函数			nil
    	结构体		   默认值根据随结构体内部类型变化而变化
    	接口			nil
    并发
        通道			nil
    
    高级类型
    	数组			默认值根据数组类型变化而变化，如 [3]int 为 [0,0,0]	
    	切片			nil  // 有争议，我运行出来是 空的切片
    	字典			nil
    	指针			nil	 // 结构体指针也是有点儿问题，是内部每个来说的
    
    ```

*   注意

    ```go
    // 结构体  
    	// 默认值根据随结构体内部类型变化而变化
    	// 结构体指针跟这个是一样的	
            type Person struct {
                Name string
                Age  int
            }  		//默认值为{ 0} 即 Name为"" Age为0
    	    var a *Person = &Person{}   a 就是上面的初始默认值
    // 切片
        // 初始化但是未使用
        var strList [3]string
        fmt.Println(strList)  // [   ]
    ```

    





*    

```go

```





# 3.匿名变量

* 编码过程中遇到的没有名字的变量、类型和方法。

```go
// 匿名变量使用：只需要在变量声明的地方使用下划线“_”
	a，b := 100,200
	a，_ := 100,200

// 空白标识符
它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算
```

* 优点：不占用内存空间，不分配内存，匿名变量和匿名变量之间也不会因为多次声明而无法使用

# 5.变量作用域

## 1.作用域

```go
// 变量在同一个作用域(在一个函数或者在代码块)内不能重名
一个变量（常量、类型和函数）在程序中有一定的作用范围
var i int = 20 
i := 10 
//注意上面是完整的，声明赋值
```

## 2.分类

### 	1.局部变量

```go
// 函数内部的变量
	函数内声明的变量。作用域在函数体内，局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。

// 形式参数
1.定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。
2.形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
3.在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。
4.形式参数会作为函数的局部变量来使用。

```

### 	2.全局变量

```go
1.函数外声明的变量。
2.只需要在源文件中定义,就可以在所有源文件中使用。
3.不包含这个全局变量的源文件需要用import引入全局变量说正在文件夹之后才能使用这个全局变量
4.注意：1.全局变量的声明必须用var关键字开头
 	   2.在外部包使用全局的全局变量的首字母必须大写
 	   3.全局变量和局部变量的名称可以相同，但是函数体内的局部变量会优先考虑
	   4.在go函数外部定义变量就是全局变量
```

### 3.同一区域内变量

* 该区域年内的数据值可以在同一类型内不断变化（重点）

```go
func main(){
    var i int
    i = 30  //可以
    i = 10  //可以
    i = 50  //以上连写可以
    i = 1.2  //不可以，因为i的数据 类型只能是int
}
```



# 6.变量的生命周转期 

* 变量的作用周期和作用域有关系
*  Go语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们任然需要了解变量的声明周期 
    *    如果将局部变量赋值给全局变量，将会阻止 GC 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。 

1. 全局变量：生命周期和整个程序的运行周期是一致的

2. 局部变量：声明周期是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止

    *   全局变量和局部变量同名的情况下，局部变量生效。 

    *   形式参数和函数返回值：属于局部变量，函数被调用时创建，函数调用结束后被销毁

3.  堆（heap）：

    *   用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。
    *   当进程调用 malloc 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。
    *   当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）； 

4.  栈(stack)：

    *   又称堆栈， 
    *   用来存放程序暂时创建的局部变量，也就是我们函数的大括号`{ }`中定义的局部变量。 

5.  程序的编译阶段，

    *   编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。  

6. 逃逸分析

    *    实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。
    *    之前的golang逃逸机制是会拷贝，现在是直接丢过去了 

```go
var global *int
func f() {
    var x int
    x = 1
    global = &x
}
//函数 f 里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的。用Go语言的术语说，这个局部变量 x 从函数 f 中逃逸了。
func g() {
    y := new(int)
    *y = 1
}
//函数 g 返回时，变量 *y 不再被使用，也就是说可以马上被回收的。因此，*y 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 *y 的存储空间，也可以选择在堆上分配，然后由Go语言的 GC（垃圾回收机制）回收这个变量的内存空间。

```







# 11 .动静类型

*   参见接口的类型
*   动态类型
*   静态类型



# 跳转

* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)