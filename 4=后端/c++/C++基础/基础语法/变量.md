

# 前言

# go中的类型传递

*   都是值传递
    *   值传递 ： 就是内存传递，将内存中值复制一份传递出去
    *   引用传递 ： 地址传递

# 1.变量

*   variable

* 变量相当于内存中一个数据存储空间的表示

  数据存在存储空间中，则这个存储空间的名字叫变量（可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间（数据在房间里），同样，通过变量名可以访问到变量(值)。）

* 变量表示内存中的一个存储区域，该区域有自己的名称(变量名)和类型(数据类型)

```go
数学概念--->  没有固定值且可改变的数
计算机实现--> 一段或者多段用来储存数据的内存
```



# 2.声明/赋值

## 介绍

```c++
变量声明
    向编译器保证变量以指定的类型和名称存在
    这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译
初始化
	就是一个名词，一个变量声明后，第一次赋值就叫初始化
    
变量三要素  
	变量= 变量名 + 值 + 数据类型
概念
 	int a;创造了一个变量 a，我们把这个过程叫做 //变量定义。
    a=123;把 123 交给了变量 a，我们把这个过程叫做给 //变量赋值；
    	又因为是第一次赋值，也称 //变量的初始化、赋初值。
```

## 方式

```go
1. 先声明后赋值		
	标准形式
	//指定变量类型，声明后不赋值，使用默认值
2. 声明的时赋值
	显式地标明变量的类型，在多变量同时声明时可以用到

3. 声明种类
	需要建立存储空间的
		int i; //声明，也是定义
	不需要建立存储空间的
        // 通过使用extern关键字声明变量名而不定义它
        extern int i; //声明，不是定义


// -----------------------
索引类型
	1. 根据省略长度，进行推倒(见数组)
	2. 赋值填充
		1. 键值对填充(根据索引键值对确定)
        2. 值列表
        3. 访问字段名填充
```



## 单个命名c

```c++
先声明后赋值
    变量类型 变量名；
    int a;
	a = 1;
声明的时候赋值
    数据类型 变量名 = 变量初始值；
    int a = 1;
```





## 批量命名c

```go
规则
	批量赋值，等到的左值和右值从左到右的顺序赋值
相同类型
	// 先声明后赋值
	int a, b, c;
	a = 1; b = 2; c = 3;
	// 声明的时候赋值
	int a = 1, b = 2 ,c = 3
不同类型
	// 应该无法同时声明
```

## 默认值

*   介绍

    ```js
    数据类型都有一个默认值，当声明时没有赋值，就会使用默认值
    默认值又叫零值
    // 初始默认值就是  ：初始但未引用的值
    ```
    
* 不同类型数据结构的初始值

    ```go
    //基础类型
    数值
    	整形		int short long 均为 0  long long 为43 (???)
    	浮点		float 为 0  double为无穷小(7.90505e-323)
    文本
    	字符串		     // 空字符串 , 啥也没有 ，输出为空
    	字符			 // 空字符串 , 啥也没有 ，输出为空
    布尔
    	布尔			0（false）
    
    -----------------------------------------------------------------
    面向对象
    	函数			nil
    	结构体		   默认值根据随结构体内部类型变化而变化
    	接口			nil
    并发
        通道			nil
    
    高级类型
    	数组			默认值根据数组类型变化而变化，如 [3]int 为 [0,0,0]	
    	切片			nil  // 有争议，我运行出来是 空的切片
    	字典			nil
    	指针			nil	 // 结构体指针也是有点儿问题，是内部每个来说的
    
    ```

*   注意

    ```go
    // 结构体  
    	// 默认值根据随结构体内部类型变化而变化
    	// 结构体指针跟这个是一样的	
            type Person struct {
                Name string
                Age  int
            }  		//默认值为{ 0} 即 Name为"" Age为0
    	    var a *Person = &Person{}   a 就是上面的初始默认值
    // 切片
        // 初始化但是未使用
        var strList [3]string
        fmt.Println(strList)  // [   ]
    ```




# 表达式

```c
种类
    左值
    右值
 左值表达式
    指向内存位置的表达式被称为左值（lvalue）表达式。
    左值可以出现在赋值号的左边或右边
右值表达式
    存储在内存中某些地址的数值。
    右值是不能对其进行赋值的表达式
    右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
    
例子
    // 变量是左值，因此可以出现在赋值号的左边。
    // 数值型的字面值是右值，因此不能被赋值
    int a = 10;
```







# 跨文件引用

```c++
介绍
	如果需要在一个源文件中引用另外一个源文件中定义的变量
做法
    只需在引用的文件中将变量加上 extern 关键字的声明即可
例子
    // 菜鸟教程上的例子，没有动
```

# 变量别名

```c++
// 详情见指针 中的 引用 reference
语法
    数据类型 &别名 = 原名
    // a b 内存地址一样，不能在更改 b 的内存地址
    int &b = a;
```





# 5.变量作用域

## 1.作用域规则

```go
介绍
	作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问

变量可以声明的地方
	函数或块内部的局部变量
	所有函数外部的全局变量
	形式参数的函数参数定义中

// 变量在同一个作用域(在一个函数或者在代码块)内不能重名
一个变量（常量、类型和函数）在程序中有一定的作用范围
var i int = 20 
i := 10 
//注意上面是完整的，声明赋值
```

## 2.分类

### 	1.局部变量

```go
介绍
	某个函数或块的内部声明的变量称为局部变量
特点
	它们只能被该函数或该代码块内部的语句使用。
	局部变量在函数外部是不可知的

// 函数内部的变量
	函数内声明的变量。
	作用域在函数体内，局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。

// 形式参数
	形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用
    2.形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
    3.在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值，在函数调用时才分配内存
	4. 调用结束后，形参被释放掉，实参保留原值（单向传值）
    
```

### 	2.全局变量

```go
介绍
	定义在函数外部，通常是在程序的顶部
	全局变量在声明后整个程序中都是可用的

特点
	全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。


2.只需要在源文件中定义,就可以在所有源文件中使用。

注意：
	程序中，局部变量和全局变量的名称可以相同，
	但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用
 

```

### 3.同一区域内变量

* 该区域年内的数据值可以在同一类型内不断变化（重点）

```go
func main(){
    var i int
    i = 30  //可以
    i = 10  //可以
    i = 50  //以上连写可以
    i = 1.2  //不可以，因为i的数据 类型只能是int
}
```

## 初始化

```c
介绍
	当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。
	定义全局变量时，系统会自动对其初始化
数据类型	初始化默认值    
int 		0
char 		'\0'
float 		0
double 		0
pointer 	NULL 
```



# 6.变量的生命周转期 

* 变量的作用周期和作用域有关系
*  Go语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们任然需要了解变量的声明周期 
    *    如果将局部变量赋值给全局变量，将会阻止 GC 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。 

1. 全局变量：生命周期和整个程序的运行周期是一致的

2. 局部变量：声明周期是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止

    *   全局变量和局部变量同名的情况下，局部变量生效。 

    *   形式参数和函数返回值：属于局部变量，函数被调用时创建，函数调用结束后被销毁

3.  堆（heap）：

    *   用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。
    *   当进程调用 malloc 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。
    *   当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）； 

4.  栈(stack)：

    *   又称堆栈， 
    *   用来存放程序暂时创建的局部变量，也就是我们函数的大括号`{ }`中定义的局部变量。 

5.  程序的编译阶段，

    *   编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。  


# 11 .动静类型

*   参见接口的类型
*   动态类型
*   静态类型



# 跳转

* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)