## 内存分区模型

```c++
c++ 程序在执行的时候，将内存大方向划分为 4 个区域

    代码区
    	存放函数体的二进制代码，由操作系统进行管理
    全局区
    	存放全局变量、静态变量、局部变量等
    栈区
    	编译器自动分配释放 ， 存放函数的参数值、局部变量等
    堆区
    	有程序员分配和释放， 如程序员不释放， 程序结束时， 由操作系统回收
意义
    不同区域存放的数据 ，赋予不同的声明周期，给我们更大的灵活编程
```



## 程序运行前

### 介绍

* 程序编译后，生成了 exe 可执行程序，未执行该程序前分为两个区域

### 代码区

* 存放 CPU  执行的指令
* 特点
    * 共享 ：目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
    * 只读 ： 原因是防止程序以外修改了它的指令

### 全局区

* 全局变量 、 静态变量存放地
* 还有 ： 常量区( 字符串常量 、其他常量const修饰的）
* 该区域的数据在程序结束后，由操作系统释放
* 内存就分了： 全局区 + 非全局区

## 程序运行后

### 栈区

#### 介绍

```c++
// 主要就是局部变量
	由编译器自动分配释放， 存放函数的参数值、局部变量等
    注意
        不要返回局部变量的地址， 栈区开辟的数据由编译器自动释放
        
例子
     int* func () {
        int a = 10; // 局部变量，存放在栈区， 栈区的数据在函数执行完以后自动释放
        return &a; // 返回局部变量的地址
    }
	int main() {
        // 函数运行结束，
        int * p = func();
        // 第一正确打印数字，是因为编译器做了保留
        cout << *P << endl; 
        // 第二次这个数据就不保留了
        cout << *P << endl;
        return 0;
    }
```

### 堆区

```c++
介绍
	由程序员分配释放， 若程序不释放， 程序结束时由操作系统回收
	在 c++ 中主要利用 new 在堆区开辟内存
```



### new

```c++
new
    语法
    	// new 返回的是指定的数据类型的指针
    	数据类型 * 指针变量 = new 数据类型(值)；
	    	int * p = new int(10);
		// 释放堆区的数据
		delete 指针变量
            delete p;
堆区开辟空间
例子
    new 将数据开辟到在堆区
    int func() {
    	// 指针本质也是局部变量， 放在栈上， 指针存放的数据是放在堆区
    	// 开辟了一个指针变量，该指针存放了一个内存地址，该内存地址指向堆区的一个数据
        int * p = new int(10);
    	return p;
    	
    	// 在堆区创建一个10个元素的数组 ，循环遍历可以进行修改操作 arr[i]
    	int * arr = new int[10];
    	// 数组释放
    	delete[] arr;
	};
	int main() {
        // 在堆区存放数据
        int *p = func()；
        // 不管后面打印几次 ，结果都是 10
        // 如果不手动释放该内存，该内存会一直存在，直到程序被关闭运行      
        cout << *P << endl; 
        cout << *P << endl;
    }
    
```





