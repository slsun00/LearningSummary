## 常量池

### 介绍

```java
介绍
    java 文件反编译为二进制文件，包含类基本信息、常量池、类方法定义，包含了虚拟机指令 
常量池
    就是一张表， 虚拟机根据这张常量表找到要执行的类名、方法名、参数类型、字面量的等息息
```

### 运行时常量池

```go
介绍
	constant pool
    常量池是 *.class  文件中的 
    当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真正的地址
```

## 串池 - StringTable

### 字符串加载

```java
注意
    jdk1.8+ 中堆中、堆中的 串池，是不一样
例子
    String s1 = "a";
加载过程
    常量池中的信息， 会被加载到运行时常量池中
    此时 a 是常量池中的符号， 还没有变为 java 字符串对象
    运行到代码所在行， 就会在常量池中找到 a , 将其变为字符串对象
    最后 ： 准备一个空间(串池) Stringtable , 如果串池中没有字符串对象 a , 就会把生成的对象加入串池
    
例子
    String s2 = "b";
	String s3 = "ab"    // 这个是在串池中
	String s4 = s1 + s2; // 这个是在堆中的  ，所以 s3 != s4
	先调用 StringBuilder() 随后 .append("a")  再 .append("b") 最后 .toString() => new string("ab")
    
     String s5 = "a" + "b";  // 串
	// 在常量池中查找，直接返回 “ab” , 所以 s3 == s5 , javac 在编译器的优化
	// 常量操作，常量的值基本不变，在编译期就可以确定，直接从串池中查找
	// 变量操作，可能会变化，在运行期间才能确定 , 用 StringBuilder 进行操作
	
	String s6 = new String("a") + new String("b") // new String("ab") 在堆中
     String s7 = s6.intern(); 
	//  主动将串池中还没有的字符串对象放入串池
	//  如果有就不放了，没有就放进去， 都会把串池的对象返回 s7 == s3
	
注意
    // intern
	jdk1.7+ ：把字符串对象放入串池， 如果有就不放，返回串池中的对象
    jdk1.6- : 把字符串对象放入串池， 如果有就不放，没有就把对象复制一份翻入串池，返回串池中的对象

总结
    变量 ：new 和 变量参与的 + 拼接  // 堆中
    常量  ：" "  和 纯 "" 参与的 + 拼接   // 串中
```

### 特性

* 常量池中的字符串仅仅是符号，第一次使用才变为对象
* 利用串机制，可以避免重复创建字符串对象
* 字符串拼接的原理是 StringBuilder(  jdk1.8 ) , 是编译器优化
* 可以使用 intern 方法 ， 主动将串池中还没有的字符串对象放入串池

### 位置

```java
1.6   在常量池，永久代
1.7+  在堆中 ， 
    
验证
    一直往串池中存放字符串对象，看到底是堆栈溢出，还是永久代溢出
    // 注意 1.8 中堆不足，爆出的是 GC。。。
```

### 垃圾回收

```java
串池也存在垃圾回收
```

### 调优

```java 
介绍
    串池的底层是哈希表， 调优主要是调整Stringtable的大小
    如果系统中字串的个数非常多，就把 StringTable 的值变大
调整
    调整 -XX：StringTableSize=桶个数
    考虑将字符串对象是否入池，使用 intern 进行入池

```



