## 公民使用

```java
// 一等公民
// java 是强类型语言，所以参数、返回值、变量都是有类型的
类型
    内建(基础)类型 	比如 int 或者 double
    类 			   比如 ArrayList、自定义类
    接口 		  	   比如 Iterable、方法
```

## 分类

### 介绍

```js
变量类型和数据类型是一样的，只不过看的角度不一样而已

我们将 char、int、float 等由语言本身支持的类型称为基本类型，
将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型
	（在讲解结构体时也曾使用复杂类型、构造类型这两种说法）。
    
```

### 基础类型

```java
// 数值 
    整数(IntegerType)
		byte short int long
    浮点(floatType)  
        float32 float64
// 文本
    字符型		
		char(单引号的)
    字符串 ：  
		String(双引号的)  // 注意这个是 ： 引用类型
// 布尔
    布尔型：          
        bool
// 注意
   基础类型可以通过 包装类 转化为引用类型
```

### 引用类型

```js
// 面向对象(代码块在{})
	方法		 通过接口定义类型（jdk8）
	类          class 类名称
    接口
// 除了基本类型外，全部是引用类型，包括自定义类型   
```

### 区别

| 类型     |                             作用                             | 内存分配 |                                                              |
| -------- | :----------------------------------------------------------: | -------- | ------------------------------------------------------------ |
| 值类型   |      变量直接存储值，<br>都有对应的指针类型(*数据类型)       | 栈中分配 | 数值型      字符型      布尔型                               |
| 引用类型 | 变量存储的是一个地址，这个地址<br/>对应的空间才真正存储数据(值)，<br/>内存通常在。当没有任何变量引用这个地址时，<br/>该地址对应的数据空间就成为一个垃圾，由GC来回收 | 堆上分配 | 字符串<br>数组<br>结构体     指针  slice   map(映射)   chan    interface 函数 |



## 类型默认值

```java
整数	0
浮点	0.0
字符	'\u0000'  :''
布尔	false
引用类型	null
```



## 类型检测

```c++
java 所有数据类型在所有机器中的大小都是相同的
```





## 类型转换

### 隐式扩展转换

```java
特点
	java 自动转换
    规则 ： 数据范围有小到大
    特点 ： 代码不需要进行特殊处理， 自动转换
// 对一个值自动匹配对应的类型
    System.out.println(100);  // 100 默认是整型
    System.out.println("a");  // a 是字符串
    System.out.println(3.13);  // 3.14 默认是 double 类型

// 数据范围有小到大转换
	long a = 100 ;  // 隐式将 int 类型转换为 long 类型
	int num = 100L; // 出错，大范围转为小范围会出现错误
```

### 强制显示转换

```go
语法
    // 将 类型 A 的值转换为类型 B 的值 ，可以对值和变量类型进行转换
	Type_B = Type_B(Type1_A_variable)
	Type_B = Type_B(Type1_A_value)
	int a = 100L;
	// 注释
		Type 和 Type1 ：表示go中的任意两种变量，Type1不同于Type
		Type_B  : 一种类型的变量
		Type1_A_variable：一种类型的变量的字面值


//注意
1.类型转换可以从大范围到小范围，也可以从小范围到大范围
2.被转化的是变量储存的数据（即值）。变量本身的数据类型没有变化
        long a = 100L;
		int b = int(a) // a 的数据类型没有发生变化，知识它存的值转化为int,并给了b
3.小范围转大范围没有问题
4.大范围转小范围可能导致数据溢出
	long b = 600000000L;
	int a = int(b); // int 最大数值也就是 2 的 32 次方
4.只有相同底层类型的变量之间可以进行相互转换
	int a = int(3.9)  // 会造成精度损失 ， 所有小数位都被删除
	int 和 int32
  不同底层类型的变量相互转换时会引发编译错误
	bool 类型转换为 int 类型

5.浮点数在转换为整型时
	默认：截尾， 会将小数部分去掉，只保留整数部分。29.8 =》 29
	改变 ：舍入， 使用 java.lang.Math 中的 round()方法
```

### 类型提升

#### 运算提升

```java
介绍
    只要类型比 int 小的在运算之前都会转变为 int,
	得到的结果也是  int 
    值得是 ：   byte char short 
表达式 
    1. 右侧赋值没有超过返回，编译器会自动补上强制转换 , 超过了就报错
    	byte a = 40;  // 编译器执行 byte a = byte(a)
    2. 进行数学运算，都会首先被提升为一个 int 类型， 会转化为位一个数字
        byte a1 = 40;
        byte a2 = 50;	
        // // 出错 ，a1 a2 会被提升为 int 类型 ，其结果也是 int 类型，转换出现数值损失
        byte sum = a1 + a2 ;  
	3. 右侧均为数字常量， 是没有提升的 , 编译器的优化，
        byte sum = 8 + 5 ; // byte sum = 13;
	
```

#### 运算符提升

```java
// 通常表达式中最大的数据类型决定了表达式最终结果的数据类型
float + double = double
```

### 注意

```java
布尔类型的不能转化为非布尔类型
```

