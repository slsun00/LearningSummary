## 方法公民

### 介绍

```java
有所属函数
	和类深度绑定的函数， 即写的方法肯定属于一个类
 完成封装
	为完成某一功能的程序指令(语句)的集合，
	将一段经常使用的代码封装起来，减少重复代码
```

### 类型

```java
// 主要是利用函数对象 ， 详情看使用
参数
返回值
赋值给变量
```



### 分类

* 函数的类型被称为函数的标识符 

* 分类

    ```go
    1.	普通的带名字的函数
    2.	匿名函数
            又称： lambda 函数
    3.	方法
    ```

* 常见样式

    ```c++
    有返回值
        有参数
        无参数
    无返回值
       	有参数
        无参数
    ```

    

### 相关概念

```java
   
方法重载
   同一个类中，参数不同，
    
方法覆盖重写 // 参看类中方法
   类继承， 有一个 @override

方法实现  // 参看接口中的方法
    接口实现， 类实现接口的中的方法
```











## 3.声明定义



### 方式

```c++
// 普通类中 ：
	声明的时候定义（赋值)）
    // 抽象函数 、 接口
    先声明 ， 后定义
// 注意
     声明：说的是写函数的时候，不写函数体
```

### 函数结构

```java
// 有返回值 , 可没有参数
访问修饰符  关键字修饰符  返回值类型 函数名(参数列表){ // 函数体  }
public static void get(int a){ ... }
```

### 声明的时候定义

```c
函数定义
    
使用
    //         声明的时候赋值
    函数定义写在 main 函数之前

特点
    函数有函数体，位置定义的地方要在在 main 函数之前
    函数可以在任意地方调用
    
语法格式例子
        int add(int num1,int num2) {
            return (num1 + num2)
        }
	    int main() { return 0; };

	// 为什么理解成声明的时候赋值
	函数的正规写法是下面的，就像是赋值，但是一般都是写成上面紧凑的形式
    int add(int a, int b)
    {
        return (num1 + num2)
    }
```



## 4.参数

### 介绍

```c++
综述
    形参和实参只是函数的参数在不同的生命周期中的叫法
    形参 ： 函数定义(声明)的时候， 函数参数的叫法， (定义的参数)
    实参 ： 函数调用的时候，函数参数的叫法, (接收的参数)
形参， 参数列表
    介绍
    	形式的参数，其本身并没有数据。 只是一个占位作用
        表示函数的输入 ，形参列表可以是多个
    
实参
   	介绍
    	是一个局部变量 ， 参数的数据，由参数调用者提供
    
使用
    函数在调用时都必须按照声明顺序为所有参数提供实参（参数值）
    函数调用时，也没有默认参数值，也没有任何方法可以通过参数名指定形参
    形参和返回值的变量名对于函数调用者而言没有意义
```

### 分类

```java
分类
    有参 ： 参数列表中有值
    	方法执行需要数据条件才能完成任务
    	public static int sum(int a, int b) {...};
    无参 ： 参数类表中留空
    	一个方法不需要任何数据条件 ， 可以自己独立完成任务
        public static int print() {...};
```

### 传递方式

#### 介绍

```java
介绍
    java 中没有指针的概念， 只有值传递
```

#### 值传递

```java
值传递
    // 默认使用
    函数在调用实参时，将数值传入给形参
    把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数
    
特点
    1.	传递的是值的拷贝，数据量大，越大效率越低
    2.	在函数内修改，不会影响到原来的值
    3.	变量直接存储值，内存通常在栈中分配



类型
    // 下面的不管是不是使用 new 都是进行值传递的
    基础类型
    	传递的是传入变量的值的拷贝， 传递以后互不关联
    基础类型的包装
    	因为是存在自动装箱、自动拆箱，所以也是引用传递
    // 注意
	   	String  类型也是值传递
   
    	
例子
public class demo1 {
    public void change(int a){
        a += a;
        System.out.println(a);
    }
    public static void main(String[] args) {
        int s = 10;
        demo1 demo1 = new demo1();
        demo1.change(s);	// 20
        // 参数传递并没有改变原变量的值
        System.out.println("传递过后："+s);  // 10
    }
}

// 过程分析例子
int a=1, b=2;
	开辟一个内存 ，内存中 a 的值为 1 ，b 的值为 2
swap(a,b);
    // 参数传递
    在内存中再开辟内存 num1 num2 ,然后把 a 的值赋值给 num1, b 的值赋值给 num2
    此时内存中有四个内存空间变量 a=1 b=2 num1=1 num2=2
    // 函数内部进行数值交换
	// int temp = num1;
    开辟一个 内存为temp 的空间 ， 将num1 的值给 temp , 
	此时内存空间 ：a=1 b=2 num1=1 num2=2 temp=1
	// num1 = num2;
    将内存空间 num2 的值赋值给 内存空间 num1
    此时内存空间 ：a=1 b=2 num1=2 num2=2 temp=1
	// num2 = temp;
   将内存空间 temp 的值赋值给 内存空间 num2
    此时内存空间 ：a=1 b=2 num1=2 num2=1 temp=1
    // 最后，回收 temp
    此时内存空间 ：a=1 b=2 num1=2 num2=1 
    // cout << a << endl;   // a=1


```



#### 引用地址值传递

```java
介绍
    // 是引用类型
    传递的是传入变量的值的拷贝， 只不过这个值是源数据的内存地址
 注意
    基础类型及其包装类，是无法进行引用值传递的，需要借助数组、map等

例子
public class demo1 {
    public void change(int[] a){
        a[1] = a[1] + 10;
        System.out.println(a[1]);

    }
    public static void main(String[] args) {
        int[] s = {1,3};
        demo1 demo1 = new demo1();
        demo1.change(s);
        System.out.println("传递过后："+s[1]);
    }
}
```

#### 特殊

```java
引用类型进行值传递
	引用类型传递进去进行操作， 就是在对内存地址上的数进行的操作，
    // 只要不对引用的类型直接操作，就不会改变引用类型的值
例子

public class demo1 {
    public void change(int[] a){
//        a[1] = a[1] + 10;
//        System.out.println(a[1]);
        int s = a[1];
        s++;
        System.out.println(s);  // 13

    }
    public static void main(String[] args) {
        int[] s = {1,3};
        demo1 demo1 = new demo1();
        demo1.change(s);
        System.out.println("传递过后："+s[1]);  // 3
    }
}
```



#### 可变参数

```java
介绍
    jdk1.5 之后
    定义一个方法需要接受多个参数，并且参数的类型一致， 可以简写
语法
    // 终极写法 Object... obj
    修饰符 返回值类型 方法名(参数类型... 形参名){ }；
    // 等价于
    修饰符 返回值类型 方法名(参数类型[] 形参名){ } ；
注意
    参数类型确定， 参数个数不确定
    可变参数和重载方法冲突的时候。优先使用重载方法
    一个方法的可变参数只能有一个
    可变参数必须写在参数列表的结尾
底层
    // 可变参数就是不用显示编写数组语法了
    是一个数组， 根据传递参数的不同，创建不同的长度的数组，来存储这些参数（>= 0个）
```

### 特殊参数类型

#### 数组

```c++
介绍
	java 也不允许传入一个完整的数组作为函数的参数 
    通过指定不带索引的数组名来传入一个指向数组的指针
	是告诉编译器将要接收一个整型指针

语法例子
	//  每种方式都会告诉编译器将要接收一个整型指针
    // 	函数体内，仍旧可以使用 arr[i] 访问数组数据
	public static void showArr(int[] arr) {
    	arr[i]
	}
```

#### 对象

```java
介绍
    // 传递进来的其实就是传递进来的地址
	public static void showArr(Phone phone) {
    	phone.name
	}
```



## 5. 函数体

### 函数变量

### return

```java
作用
    停止当前方法， 将后面返回值还给调用处
    return 后面跟的返回值， 必须和方法前面的返回值类型保持对应
```





## 6.返回值

### 介绍

```c++
返回值
	描述了函数返回值的类型 
    只能有 1 个或者 0 个返回值
多个值返回
    使用数组 、 类等
分类
    无返回值
    	返回值的位置 使用 void 占位
    	不包括返回值，函数执行完毕后，不会返回任何值
    有返回值
		必须以 return 语句结尾，除非函数明显无法运行到结尾处， 
		返回数组
    	返回指针
    	返回引用
    
注意
返回局部变量
    方法
        // 返回局部变量 ， 看数组返回
        C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量
    原因
    	因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，
        因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。
		
    	除非将其变量定义为 static 变量，
    	static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。
```



### 1.无返回

```c++
// return语句不能返回任何值, 只是用来结束函数 ，在函数最后一行的时候，可要可不要
void Add(int num1, int num2) {
    return;
}
```



### 数组返回

```c++
介绍
    C 语言不允许返回一个完整的数组作为函数的参数
    通过指定不带索引的数组名来返回一个指向数组的指针
例子
    int* returnArr() {
    	//  C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量
        static int arr[3] = {0, 1, 2};
        return arr;
	}
```



### 指针返回

### 引用返回

```c++
介绍
    // 引用做函数的返回值
    1. 不要返回局部数据的引用
    	 // 例如局部变量、局部对象、局部数组等
    	  因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，
    	  C++ 编译器检测到该行为时也会给出警告。
    2. 函数的调用可以作为左值
例子
 // 不要返回局部变量的引用 
    int& test01() {
        // 局部变量，存放子四区中的  栈区
        int a = 10;  
        return a;
    }
    int main() {
        int &res = test01();
        // 10 第一次编辑器做了保留
        cout << res << endl;
        // 乱码 ，编译器已经做了释放
        cout << res << endl;
    }
// 2. 函数的调用可以作为左值
int &test02() {
    // 静态变量 ， 存放在全局区 ，数据在程序结束后释放
    static int a = 10;
    return a
}
int main() {
    int &res = test02();
    // 10 多少次都是这样
    cout << res << endl;
    // 函数作为左值
    test02() = 1000;
    // 1000 
    cout << res << endl;
}
```

## 7.调用

### 本文件调用

```c++
语法
    // 函数名(参数)；
分类
    有返回值
        赋值调用  打印调用	 
    无返回值
    	单独调用
注意
    函数名：需要调用的函数名。
    参数列表：参数变量以逗号分隔，尾部无须逗号结尾。
    返回值变量列表：多个返回值使用逗号分隔
    
语法例子
    public static int add(int a, int b) {
		int res = a + b;
		return res;
	}
    
有返回值(赋值调用)
    // 赋值调用 ：需要返回值，要有变量接收 
        int b = add(3,4)；
        add(3,4)；
   // 打印调用 ： 直接打印返回值
        System.out.println(add(2,3));
无返回值(直接调用)
    // 直接调用 ， 不需要返回值就不用变量接收
    // 无返回值不能使用 打印调用
    int a=1,b=2;
    swap(a, b)；
 

```





### 2.调用机制

```go
当程序调用函数时，程序控制权会转移给被调用的函数。
被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。
----------------------------------------------------------------------------
1. 在调用一个函数时，会给该函数分配一个新的空间（栈），编译器会通过自身的处理让这个新的空间和其它的栈的空间区分开来
2. 在每个函数对应的栈中，数据空间是独立的，不会混淆
3. 当一个函数调用完毕(执行完毕)后，程序会销毁这个函数对应的栈空间。
```

### 3.调用过程

```go
1.函数在定义之后，皆可调用
2.可以通过调用的方式,让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。
3.函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失。
```



## 特殊函数

### 回调函数

```java
原因
    先理解怎么运行回调函数，可能会较好理解函数作为参数使用
 例子
    // 函数 A  作为参数传入函数 B ， 当 B 中的代码执行完会调用 A  ， A 就是回调函数
	// 即函数主体执行完，才执行的函数

	// 定义回调机制 ，这里没有定义 函数 A
        void B(int b, A){
            b++;
            A(b);
        }
	// 实现回调函数 A
        void A(int a) {
            a+=a
        }
	// 调用
		B(3,A)
	// 过程分析
        1. 函数 B 传入一个 参数 3 和一个 函数 A
         2. 函数 B 执行完 3++ ，就开始调用函数 A （此题中给 A 传可一个参数）
        总结
        // 这就是为什么，你使用一个别人提供的 Api , 定义一个函数就可以实现对数据的处理，调用在内部完成
```



## 8. 使用

### 函数对象

```java
介绍
    // 通过一个类去传递/使用一个方法
     java 中函数并不是一种数据类型，需要通过匿名类， 来完成函数的传递
     定义一个只有方法而没有数据的类，然后把这个类的对象传递给别的方法，这时传递的这个对象就是一个函数对象。
    通过对这个类对象达到方法的调用
例子
    
// 一个类，其中定义了一个方法
public class OperAdd {
    public int operation(int a, int b) {
        return a + b ;
    }
}

class  All {
	// 声明了函数对象 f
    // 定义了函数对象传进来，该怎么工作
    public static void doit (int a, int b, OperAdd f) {
        int c = f.operation(a, b);
        System.out.println(c);
    }
	// 实现调用 ,使用匿名内部类
    public static void main(String[] args) {
        doit(1,2,new OperAdd());
    }
}
```



### 参数

```java
介绍
   
// jdk1.1+
	匿名类
 // jdk8
	函数接口  Lambda
// 例子
    // 函数对象介绍了使用类来规定函数，这里使用接口来规定函数
public interface TestMath {
    public static void Add(int a, int b);
}

class Test{
    // 这里只是声明了一个 函数接口， 没有方法实现
    // 只是规定了，该怎么运行
	public void a_Add(int a,int b, TestMath t){
        t.Add(a,b);
    }
    public static void main(String[] args){
		a_Add(1,3,new TestMath(){
            @Override
            Add(int a, int b){
                int c = a+b;
                System.out.print(c);
            }
        })
    }
}
```



### 返回值

```java
// 还是返回了一个函数对象，一个对象 
```



### 赋值给变量

```java
// 返回一个函数对象，这个对象赋值给变量
```



## 方法重载

### 介绍

```c++
作用
    函数名相同，提高复用性
满足条件
    1. 同一个作用域下
    2. 函数名称相同
    3. 函数参数的类型、个数 、顺序不同（这个是重点）
无关条件
    参数名称无关 
    函数返回值无关，没有有返回值都行
    跟限定词无关
作用
    记住一个方法名称 ，可以实现多个功能
 注意
	1.不要使用参数顺序不同来构成重载
```

### 重载提升

```java
// 基本类型的重载
形参类型是一个比较大的类型 ： int
实参类型是一个比较小的类型 ： char
// 形参类型 > 实参类型
    会自动出现类型提升
// 形参类型 < 实参类型
    需要提前进行窄化转换（进行类型转换）， 否则报错
```



### 例子

```c++
// 条件1
    1. 同一个作用域下
    2. 函数名称相同
    3. 函数参数的类型、或者个数 、或者顺序不同
 例子
    void fun() { cout<<"test1"<<endl;}
    void fun(int num1) { cout<<"test2"<<endl; }
    void fun(double num2)   { cout<<"test3"<<endl; }

    int main() {
        fun();  // test1
        fun(1);  // test2
        fun(1.1);  // test3
    }

// 条件2 
	引用作为函数重载的条件
例子
    void fun() { cout<<"test1"<<endl;}
    void fun(int &num1) { cout<<"test2"<<endl; }
    void fun(const int &num1)   { cout<<"test3"<<endl; }

    int main() {
        // a 可读可写，所以调用 test2
        int a = 10;
        fun(a);  // test2

        // int &num1 = 10 不合法，所以不会调用 test2
        fun(10);  // test3 
    }

条件3
    函数重载碰到默认参数
    void fun() { cout<<"test1"<<endl;}
    void fun(int num1, int num2=10) { cout<<"test2"<<endl; }
    void fun(int num1)   { cout<<"test3"<<endl; }

    int main() {
        fun();  // test1
        // 编译器出现二义性，会报错，应该尽量避免使用
        fun(10);  
    }
```





## 内存引用

### this

```JAVA
介绍
    this  指向被调用的成员方法所属的对象
    this 不需要定义，直接使用即可
    
使用
    只能在方法体内使用
    方法体内获取当前对象的引用
    
用途
    // 解决命名冲突
    方法的局部变量和成员变量重名的时候， 根据就近原则， 优先使用局部变量 ，访问类变量就需要用 this
    当形参和成员变量同名时， 可用 this 指针来区分
    //  返回对象本身
    在类的非静态成员函数返回对象本身， 可使用 return this

    
 语法
    this.成员

 省略
    // 为了语义明确，我感觉最好还是加上 this ，
    方法体内调用同一个类中的其他方法不需要加上，编译器会自动加上
 语法例子
    pulic class Person {
        String name;
        // this 指的就是 Person
        public void sayHello(String name) {
            system.out.println(this.name )
        }
    }
```





## -------

## 7.特殊方法

### 构造函数

```c++
详情见 class 中的方法
```

### 析构函数

```c++
详情见 class 中的方法
```



### 递归函数

```c++
详情见 数据算法与结构  递归函数 + 树
```



### 回调函数

```c++
介绍

    一个函数的参数是函数，函数在调用的时候，会调用这个函数参数
    参数函数就叫回调函数 ，主函数就叫回调实现者
阐述
    // 函数 a 的参数是一个参数 b ，
    // 函数 a 调动的时候会调用函数 b ， 即 a 执行函数的时候，会后头调用 函数 b 
    // 函数 b 就叫回调函数 ，函数 a 是回调实现者

注意
    函数做参数，使用的是函数指针，调用者可以传递一个函数的地址给实现者，让实现者去调用它
    关于函数指针的，看函数指针
    
语法例子
    // 回调实现者 func1 ，回调函数 f2
    void func1(int arg, void (*f2)(int)) {
    	cout <<  "接收到参数 arg ," << arg << endl;
    	// 调用参数函数
    	f2(arg);
	}
    
	void hello(int a) {
        cout << "这里是 hello" << endl;
        cout << "回调成功, 传入 " << a << endl;
    }
	int main() {
        // 注意 hello 函数并没有写参数 ，具体看函数指针
        func1(666, hello);
        // 接收到参数 arg ,666
        // 这里是 hello
        // 回调成功, 传入 666
        return 0;
    }
```



### 3、匿名函数

*   介绍
    *   即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体 
    *    匿名函数也往往以变量方式传递 
    *    支持随时在代码里定义匿名函数 

*   定义格式

    ```go
    // 匿名函数就是没有名字的普通函数
    
    func(参数列表)(返回参数列表){
        函数体
    }
    ```

*   调用

    1.  定义的时候进行调用

        ```go
        1. 这种匿名方式只能调用一次
        //--------------------------------------------------------
        a := func （n1 int,n2 int）int(){
        		return n1 + n2
        }(10,20)  // (10,20) 即为对函数的调用，传入的参数是 (10,20)
        ```

        

    2.  匿名函数赋值给变量

        ```go
        1.实现多次调用
        2.将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数
        3.全局匿名函数
        	将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序中有效
        
        //-------------------------------------------------------
        func （n1 int,n2 int）int(){
        		return n1 + n2
        }
        var a func()
        a = 
         a（10 ， 20） // a 调用匿名函数
        
        
        // 全局匿名函数
        
        var (
            FUN1 := func （n1 int,n2 int）int(){
        		return n1 + n2  }
        )
    res := FUN1(10 ,20)
        ```
        
        

* 使用
  
  *   匿名函数作为回调函数
    
      ```go
        //  回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
        // 回调方法 是 任何一个 被 以该回调方法为其第一个参数 的 其它方法 调用 的方法。很多时候，回调是一个当某些事件发生时被调用的方法。
        
        
        // 使用 visit() 函数将整个遍历过程进行封装，
        // 当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。
        
        func visit (list []int, f func(int)) {
            // // 遍历切片的每个元素, 通过给定函数进行元素访问
            for _, v := range list{
                f(v)
            }
        }
        
        func main(){
            // 使用匿名函数打印切片内容
            visit([]int{1,2,3,4},func(v int)){
                // 定义了一个匿名函数，作用是将遍历的每个值打印出来。
                fmt.Println(v)
            }
        }
      ```
  
  *   匿名函数实现封装
  
      ```go
      //
      
      // 定义命令行参数 skill，从命令行输入 --skill 可以将 = 后的字符串传入 skillParam 指针变量。
      var skillParam = flag.String("skill","","skill to perform")
      
      func main(){
          
          // 解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值
          flag.Parse()
          
          // 定义一个从字符串映射到 func() 的 map，然后填充这个 map . 
          // 初始化 map 的键值对，值为匿名函数
          var skill = map[string]func(){
              "fire" : func() {
                  fmt.Println("chicken fire")
              },
              
              "run" ： func() {
                  fmt.Println("soldier run")
              },
              
              "fly" : func(){
                  fmt.Println("angel fly")
              },
          }
          
          // skillParam 是一个 *string 类型的指针变量，
          // 使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。
          if f,ok := skill[*skillParam]; ok {
              f()
          } else {
              fmt.Println("skill not found")
          }
      }
      
      // 运行
      go run main.go --skill=fly  // angel fly
      ```
  
      
  
  ​      



## 函数操作

### 相同函数

```c++
相同类型

*    如果两个函数形式参数列表和返回值列表中的变量类型一一对应，
*    这两个函数被认为有相同的类型和标识符，
*    形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。 
```






## 函数签名

```go
函数签名就是函数的声明信息，包括参数、返回值

参数 	 ：	类型 个数 顺序
返回值	：  类型 个数  
异常   ：
这个众说纷纭，貌似没啥统一的
```



## 成员方法

