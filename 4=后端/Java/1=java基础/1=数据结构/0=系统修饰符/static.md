## static

### 介绍

```java
介绍
    所有对象公用一份数据 
    	不属于某个对象，
    	成员使用该字段，就表示该成员不属于任何一个实例对象，而是属于所在的类
    在编译阶段分配内存(全局区)

    
优势
    只在需要的时候进行创建， 而且只被创建一次
    可以节省内存，对于对象都一样

```

### 静态访问

```java
介绍
    // static方法就是没有 this 的方法。
    被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。
    而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。

访问规则
	静态只能访问静态 ： 静态方法中只能使用静态变量、调用静态方法
    非静态通吃      ：  非静态方法随意访问
    
原因
    1. 在内存中先有静态内容， 后有非静态内容
    2. 非静态成员方法/变量都是必须依赖具体的对象才能够被调用
       静态方法来说，是没有this的，因为它不依附于任何对象，就可以进行访问
特点
    1. 静态优先于非静态加载到内存中（静态优先于对象进入内存）
    2. 被 static 修饰的成员变量不能被序列化，序列化的都是对象
    3. 静态成员不能通过 this 访问：因为 this 是对象创建之后生成的
    4. 静态方法中不能使用 this 

    
例子
    public class Main {
    static int a = 2;
    public int b = 3;
    public static void add1(){
        a++;
        // b++; 错误
        // this.b++ 错误
    }
    public void add2(){
        a++;
    }

}
```

### 修饰成员

#### 调用

```java
1. 通过对象进行访问
2. 通过类名进行访问(推荐)
    本类中调用可以省略类名称
```

#### 构造器 + 局部变量

```java
// 静态方法中不能使用this，而构造器中可以使用this关键字
构造器不是  static 限定的
    https://blog.csdn.net/qq_17864929/article/details/48006835

static 不能用于局部变量 ！！！！！(这是  java 语法规定的)  
```

#### 修饰变量

```c++
// 静态成员变量
介绍
	只能修饰类的变量
    不能修饰方法中变量
区别
    静态变量
    	// 类变量
    	类变量属于类所有,被所有的对象所共享
         	在内存中只有一个副本，它当且仅当在类初次加载时会被初始化
    	static 修饰的变量位于⽅法区中
	非静态变量
    	是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。
访问
    2. 被 static 修饰的成员变量不能被序列化，序列化的都是对象
    3. 静态成员不能通过 this 访问：因为 this 是对象创建之后生成的
    4.直接通过 类 名.变量名 
    	不⽤通过实例化类再进⾏使⽤
    
初始化
    初始化顺序按照定义的顺序进行初始化
语法例子
    class Person {
    // 类内声明
    public static int age;
    }

	// 类外初始化
	// 2 通过类名进行访问， 类内调用，可以省略类名
	int Person.age = 20；
        
         // 类外访问
        // 1. 通过对象进行访问
        Person p2 = new Person();
        p2.age = 200;
        p1.age  // 200
    }
```

#### 修饰方法

```c++
// 静态成员方法
介绍
    // static 修饰方法， 一般称作静态方法
    所有对象共享同一个函数
    静态成员函数只能访问静态成员变量
    
调用
    // 4. static 方法就是没有 this 的方法
    1. 通过对象访问: 普通的一样
        
	// 可以在不用创建对象的前提下就能够访问 static 方法        
    2. 通过类名访问: 直接通过 类名.⽅法名 来使⽤
    3. 静态⽅法内部
        	不能使⽤： ⾮静态属性和⽅法
        非静态方法
        	可以调用 static 静态方法。
理解
	main 方法为什么是 static 的
        因为程序在执行 main 方法的时候没有创建任何对象，因此只有通过类名来访问。
语法例子
    class Person {
   
        int num;
        public int age;
        public static void func() {     
             // 出错，静态成员函数不能访问费静态成员变量
            // 无法判断变量属于哪一个对象
            num = 10;
            // 静态变量不属于哪个对象，变相理解成全局的 ，全局只有一个
            age = 20; 
            cout << "static" << endl;
        }
    }
	
	// 类外初始化变量
	int Person::age = 20;
	void test() {
        // 通过对象访问
        Person p;
        p.func();
        
        // 通过类名访问
        Person::func();
    }
```

#### 修饰代码块

```java
// 静态代码块
介绍
    静态代码块
    	直接定义在类中， 使⽤ static{}
	静态内部类
        在类中定义， 使⽤ static class xxx{}
            
// 静态内部类
	参看类 -- 静态内部类            
// 静态代码块            
介绍
	可以置于类中的任何地方
	可以有多个 static 块
	类初次被加载的时候记载
      会按照static块的顺序来执行每个static块，并且只会执行一次。            
格式
    public class 类名称 {
        static {
        	静态代码块
        }
    }

用途
    对静态变量进行赋值， 优化程序性能
例子
    public class Person {
        static {
            system.out.println("1");
        }
        public Person() {
            system.out.println("2");
        }
    }

	// 执行
	Person p1 = new Person()  // 1 ， 2
    Person p2 = new Person()  // 2
```

#### 修饰导包

```java
static 可以⽤于静态导包，通过使⽤ import static xxx 来实现，这种⽅式⼀般不推荐使⽤
    
import static java.lang.Integer.*;

public class StaticTest {

    public static void main(String[] args) {
        System.out.println(MAX_VALUE);
        System.out.println(toHexString(111));
    }
}    
```



### 访问权限

```java
1. Java中的static关键字不会影响到变量或者方法的作用域
2. Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字    
```

### 生命周期

```java
static 变量的生命周期与类的生命周期相同，
    随类的加载而创建，随类的销毁而销毁；普通成员变量和其所属的生命周期相同。
```

### 序列化

```java
序列化目的是: 
	为了 把 Java 对象转换为字节序列。
     对象转换为有序字节流，以便其能够在网络上传输或者保存在本地文件中。
        
介绍
    只有堆内存才会被序列化
	// 声明为 static 和 transient 类型的变量不能被序列化，
    因为 static 修饰的变量保存在方法区中        
	而 transient 关键字的作用就是防止对象进行序列化操作。
        
        
```

### 加载顺序

```java
加载父类的静态字段 -> 父类的静态代码块 -> 
    子类静态字段 -> 子类静态代码块 ->
    
父类成员变量（非静态字段）-> 父类非静态代码块 -> 父类构造器 -> 
    子类成员变量 -> 子类非静态代码块 -> 子类构造器
```

### 辨析

#### 类的构造器是否是 static 的

```java
// 构造器不是  static 的
// 类的构造器虽然没有用 static 修饰，但是实际上是 static 方法
1. 而在类的构造器中，是有隐含的 this 绑定的，因为构造方法是和类绑定的，
    	从这个角度来看，构造器不是静态的。
2. 从类的方法这个角度来看，因为 类.方法名不需要新创建对象就能够访问，
    	所以从这个角度来看，构造器也不是静态的
3. jvm
    static 方法 ：
    	调用 static 方法时是使用的 invokestatic 指令
    	invokestatic 指令是专门用来执行 static 方法的指令
    构造器方法： 
    	new 对象调用的是 invokespecial 指令
    	invokespecial 是专门用来执行实例方法的指令
    所以从这个角度来看，构造器也不是静态的
```



### 思考

```java
static 修饰的成员， 颇像全局成员，虽然 java 禁止使用全局成员
尽量少用 static
```

