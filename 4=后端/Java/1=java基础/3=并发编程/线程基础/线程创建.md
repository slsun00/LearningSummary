## 创建

### Thread 创建

#### 直接使用

```java
// 语法例子
// 构造函数中的名字可要可不要，但是最好加上
Thread t1 = new Thread("t1"){
    @Override
    // run 方法实现了要执行的任务
    public void run(){
        // 
    }
}

// 线程启动
t1.start();

// 注意
t1.setName("t1")
```

#### 继承使用

```java
介绍
    创建  Thread 类的子类， 要想实现多线程程序，就必须继承 Thread 类
步骤
    1. 创建一个 Thread 类的子类， 
    2. 在 Thread 类的子类中重写 Thread 类中的方法， 设置线程任务（开启线程做什么）
    3. 创建 Thread 类的子类对象
    4. 调用 Thread 类中的 start 方法， 开启新的线程，执行 run 方法
    	 start() 使线程开始执行， Java 虚拟机调用该方法的 run 方法
    结果
    	两个线程并发运行， 当前线程（main线程）和另一个线程（创建的新线程，执行 run 方法）
    	多次启动一个线程是违法的， 特别是当线程已经结束执行后， 不能再重新启动


// 语法例子
class  Mythread extends Thread {
    @Override
    public void run() {
        for (int i=0; i<4; i++){
            System.out.println("================= "+ i);
        }
    }
}
    
// 测试
public class Main {
    public static void main(String[] args) {
        Mythread mt = new Mythread();
        mt.start();

        for (int i=0; i<1000; i++){
            System.out.println("main  "+i);
        }
    }
}

    
```

#### 常用方法

```java
创建方法
    thread() // 四个
常用方法
    getName
    start
    run 
    sleep
    currentThread
了解
    setname 设置线程名称
```



### Runnable (配合 thread)

#### 基础

```java
介绍
    实现 Runnable 接口， 重写 run 方法，该方法仍旧是该线程的线程执行体
    实现类必须定义一个 run 的无参方法
构造方法
    Thread(Runnable target) // 分配新的 Thread 对象
    Tread(Runnable target, String name); 分配新的 Thread 对象
步骤
    1. 创建一个 Runnable 接口实现类, 实现类中重写 run 方法
    2. 创建接口实现类对象， 传入 Thread 对象
    4.  Thread 调用 start 方法， 开启新的线程的方法
    
// 语法例子
class RunnableImpl implements Runnable {
    @Override
    public void run() {
        for (int i=0; i<20; i++){
            System.out.println(i);
        }
    }
}   

// 测试
public class Main {
    public static void main(String[] args) {
       RunnableImpl test = new RunnableImpl();
       Thread t1 = new Thread(test，t1);
       t1.start();
    }
}
```

#### 匿名内部类创建

```java
介绍
    匿名： 没有名字。 内部类：写在其他类的类

语法例子
public static void main(String[] args) {
        // 方法一： Runnable r = new Runnable(){...};
    	// 方法二： Runnable r = () -> {...};
    	// 综述： new Thread(new Runnable(){...}, t1).start();
        Runnable r = () ->{
            @Override
            public void run() {
                for (int i=0; i<20; i++){
                    System.out.println(i);
                }
            }
        };
    
       //  r 构造也可以写到 thread 中，但是不方便阅读
       Thread t1 = new Thread(r，t1);
       t1.start();
    }        
```



### futureTask(配合 thread)

```java
介绍
    futureTask 能顾接收 Callable 类型的参数， 用来处理有返回结果的情况
例子
    FutureTask<Integer> test = new Futuretask<>(){
    	@Override
	    public Interger call() throws Exception {
            // 需要在线程中执行的代码
        }
	
	}
	// 开启，开启后需要通知主线程使用
	new Thread(test,"t1").start();

	// 主线程运行到这里，会一直等待线程返回结果
	test.get();
```

### 3.callable 和 future

### 4线程池创建

### 创建区别

```java
区别
    如果一个类继承 Thread , 则不适合资源共享，
    实现了 Rannable 接口的话， 则很容易地实现资源共享
总结
    1. 实现接口，可以去继承其他类，避免 java 单继承的局限
    // 实现Rannable 更具有优势
    1. 适合多个相同程序代码的线程去共享同一个资源
	2. 两者线程执行的方法不同：call run
    3. 增加程序的健壮性， 实现解耦， 代码可以被多个线程共享， 代码和线程独立
	    	把线程任务和开启新线程进行了分离 
    		实心 runnable ,重写 run 方法设置线程任务， 
    		创建 Thread 的start 进行开启新线程的 run
    4. 线程池只能放入实现 Runnable 或 Callable 类的线程， 不能直接放入继承 Thread 的类
```



## 比较

```java

```



## 线程查看

### 运行

```java
// 
线程是交替进行执行的，由底层决定，
```

### 查看

```java
// window
任务管理器可以查看进程和线程数， 也可以用来杀死进程
    tasklist | findstr java 查看进程
    taskkill 杀死进程
// linux
```



## 线程安全

```java
多个线程同时对同一个资源进行访读写，会造成两个线程同时在读写统一而数据
注意
    线程安全问题是不能产生的
 解决
    可以让一个线程在访问线程的时候， 无论是否失去了 CPU 的执行权，其他线程只能等待
```

