## 介绍

```java
英文
    Annotation 
中文名
	 注解，也叫元数据    	
作用
   说明程序， 给计算机看的 
    一种描述数据的数据。所以可以说注解就是源代码的元数据
本质
    接口
使用
    jdk1.5+
分类
   // 到 Java 8 为止 Java SE 提供了 11 个内置注解
    有 5 个是基本注解，
    	位于 java.lang 包。
    有 6 个是元注解
    	位于 java.lang.annotation 包，
    	用于自定义注解 
```



## 注解符号

```jaa
编译检测， 让编译器实现基本的编译检查
	@Override
代码分析
	
编写文档
	文档注释 /***/
```



## 基本注解

### 介绍

```java
分类
    jdk5
        @Override
        @Deprecated
        @SupperessWarning("all")
	jdk7
    	@SafeVarargs 
    jdk8
    	@FunctionalInterface	
```

### @Override

```java
使用
    只能修饰方法
    // 只用于方法重写
作用
    告诉编译器检查这个方法，
    如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误
    
```

### @Deprecated

```java
使用
    类、接口、成员方法和成员变量
作用
    表示标注的元素（类、方法等）已过时。
    当其他程序使用已过时的元素时，编译器将会给出警告。
    
属性
    jdk9+ 添加了两个属性
    
```



### @SupperessWarning("all")

```java
作用
    指示编译器去忽略注解中声明的警告。
    取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素
    
属性值
    unchecked		抑制没有进行类型检查操作的警告
    all				抑制所有警告
    boxing			抑制装箱、拆箱操作时候的警告
    cast			抑制映射相关的警告
    dep-ann			抑制启用注释的警告
    deprecation		抑制过期方法警告
    fallthrough		抑制在 switch 中缺失 breaks 的警告
    finally			抑制 finally 模块没有返回的警告
    hiding			抑制相对于隐藏变量的局部变量的警告
    incomplete-switch	忽略不完整的 switch 语句
    nls				忽略非 nls 格式的字符
    null			忽略对 null 的操作
    rawtypes		使用 generics 时忽略没有指定相应的类型
    restriction		抑制禁止使用劝阻或禁止引用的警告
    serial			忽略在 serializable 类中没有声明 serialVersionUID 变量
    static-access	抑制不正确的静态访问方式警告
    synthetic-access	抑制子类没有按最优方法访问内部类的警告
   
    unqualified-field-access	抑制没有权限访问的域的警告
    unused			抑制没被使用过的代码的警告
```

### @SafeVarargs 

```java
作用
    忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告
注意
    @SafeVarargs注解不适用于非 static 或非 final 声明的方法
    对于未声明为 static 或 final 的方法，如果要抑制 unchecked 警告，可以使用 @SuppressWarnings 注解。
    
语法例子
public class HelloWorld {
    public static void main(String[] args) {
        // 传递可变参数，参数是泛型集合
        display(10, 20, 30);
        // 传递可变参数，参数是非泛型集合
        display("10", 20, 30); // 没有@SafeVarargs会有编译警告
    }
    @SafeVarargs
    public static <T> void display(T... array) {
        for (T arg : array) {
            System.out.println(arg.getClass().getName() + "：" + arg);
        }
    }
}    
```



### @FunctionalInterface

```java
作用
    指定某个接口必须是函数式接口
    
位置
    只能修饰接口
函数式接口
    接口中只有一个抽象方法（但可以包含多个默认方法或多个 static 方法）
```



## 元注解

### 介绍

```java
使用
    用于自定义注解
分类
    jdk5
    	@Documented
    	@Target
    	@Retention 
    	@Inherited
    jdk8
    	@Repeatable 
    	@Native 
    
    

	@Retention 注解被保留的阶段
    REtntionPolicy.RUNTIME  档期啊注解会保留到字节码文件中， 被 jvm 读取到
@Document 
@Inherited	注解是否被子类继承
```

### @Document

```java
作用
    是一个标记注解，没有成员变量
    注解内容是否抽取到 api 文档中
    
    // 声明注解类时
    指定了 @Documented，
    	就会被 JavaDoc 之类的工具处理，注解类型信息就会被包括在生成的帮助文档中。
    未指定
   		 默认情况下，JavaDoc 是不包括注解的
语法例子
    @Documented
    @Target({ ElementType.TYPE, ElementType.METHOD })
    public @interface MyDocumented {
        public String value() default "这是@Documented注解";
    }   
// 使用
@MyDocumented
public class DocumentedTest {
    @MyDocumented
    public String Test() {...}
}
// 生成的 api 文档中
@MyDocumented
public class DocumentedTest
extends java. lang. object
    
    
@MyDocumented
public java.lang.String Test()

```



### @Target

```java
作用
    描述注解能够作用的位置
    被 @Target 修饰的注解可以用在什么地方
    
目标注释
// 例子
    // 参看 Enum ElementType
    ElementType.PACKAGE  包
    
public enum ElementType {
    PACKAGE,     包
    TYPE  		类、接口(包括注解类型) 或enum声明      
    FIELD  		字段（包括枚举常量）
        
    METHOD, 	方法       
    CONSTRUCTOR  构造函数
        
    PARAMETER,  描述方法参数， 输入参数声明
        
    LOCAL_VARIABLE,  局部变量
	ANNOTATION_TYPE, 注释类型
        
	// 泛型
     TYPE_PARAMETER,  用来标注类型参数   
     TYPE_USE    参数类型声明， 使用一种类型         		
```



### @Retention

```java
含义
    保留
作用
    标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问
value
    // value 是 java.lang.annotation.RetentionPolicy 枚举类型
    RetentionPolicy.SOURCE - 
    	在源文件中有效（即源文件保留）
    		标记的注释仅保留在源文件中，并由编译器忽略。
	RetentionPolicy.CLASS - 
    	在 class 文件中有效（即 class 保留）|
    		标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。
	RetentionPolicy.RUNTIME -
		在运行时有效（即运行时保留)            
    		标记的注释由JVM保留，因此运行时环境可以使用它。
value 使用范围
	SOURCE < CLASS < RUNTIME，前者能使用的地方后者一定也能使用
使用场景
	1. 运行时去动态获取注解信息，那只能用 RUNTIME 注解；
    2. 编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS 注解；
    3. 只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。            
    
```



### @Inherited

```java
作用
    一个标记注解，用来指定该注解可以被继承
     @Inherited 注解的 Class 类，表示这个注解可以被用于该 Class 类的子类，这个过程是自动的
位置
    此注释仅适用于类声明。
    
```



### @Repeatable

```java
作用
    标识某注解可以在同一个声明上使用多次。
    表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。
    
语法例子
public @interface Roles {
    Role[] value();
}
@Repeatable(Roles.class)
public @interface Role {
    String roleName();
}
public class RoleTest {
    // 种简化写法是一种假象，多个重复注解其实会被作为“容器”注解的 value 成员的数组元素处理。
    @Role(roleName = "role1")
    @Role(roleName = "role2")
    public String doString(){
        return "这是C语言中文网Java教程";
    }
}    
```



### @Native

## 自定义注解

### 格式

```java
介绍
    声明自定义注解使用 @interface 关键字（interface 关键字前加 @ 符号）实现
格式例子
    public @interface 注解名称{
    	属性列表
	}

使用
    注解可以在程序的任何地方使用，通常用于修饰类、接口、方法和变量等。

本质
    无论是哪一种注解，本质上都一种数据类型，是一种接口类型
    public interface test extends java.lang.annotion.Annotation{}
```

### 权限修饰

```java
    public @interface 注解名称{
    	属性列表
	}
	// 公有权限
     public   
        公有访问权限。
    	一个源程序文件中可以声明多个注解，但只能有一个是公有访问权限的注解。
    	且源程序文件命名和公有访问权限的注解名一致。
	//          
	默认不写
    	默认访问权限
```



### 成员变量

#### 介绍

```java
介绍
    注解的属性键值对： 键
    成员变量以无形参的方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型
格式
    // 属性值类型 属性名() default 默认值；
    返回值类型 ==  成员变量类型 == 属性值类型
    接口方法名 ==  成员变量名   == 属性名
注意
    若注解里定义了成员变量，那么使用该注解时就应该为它的成员变量指定值
    使用了默认值的则不用
语法例子
    public @interface MyTag {
        // 定义带两个成员变量的注解
        // 注解中的成员变量以方法的形式来定义
        // 使用默认值为其中一个成员变量指定默认值
        String name() ;
        int age();
    }
    public class Test {
        // 使用带成员变量的注解时，需要为成员变量赋值
        @MyTag(name="xx", age=6)
        public void info() {}
    }
```

#### 默认值

```java
介绍
    可使用 default 关键字为成员变量指定默认值
语法例子
public @interface MyTag {
    // 定义了两个成员变量的注解
    // 使用default为两个成员变量指定初始值
    String name() default "C语言中文网";
    int age() default 7;
}

public class Test {
    // 使用带成员变量的注解
    // MyTag注释的成员变量有默认值，所以可以不为它的成员变量赋值
    @MyTag
    public void info() {}
}
```

#### 总结

```java
	1. c成员类型 ： 基础类型 、String 枚举 注解 以上类型的数组
	2. 定义了属性值，在使用的时候要赋值初始化
		1. 使用 default 没有赋值，可以使用指定的默认值
		2. 只有一个属性需要赋值， 可以不用写类型，直接写数据
		3. 数组赋值，用大括号
```



### 分类

```java
介绍
	标记注解
    	不包含任何成员变量
    	仅利用自身的存在与否来提供信息
   	元数据注解   
    	含有成员变量，
    	
语法实例
    // 标记注解
    public @interface Test {
    }
	
	// 普通注解
    public @interface MyTag {
        // 定义带两个成员变量的注解
        // 注解中的成员变量以方法的形式来定义
        String name();
        int age();
    }

```

### 注解生效

```java
介绍
    注解修饰了类、方法、变量等成员之后，这些注解不会自己生效，必须由开发者提供相应的工具来提取处理
    获取注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，除此之外没有其它方法。

反射获取
 Annotation 
    Java 注解类型都继承于 java.lang.annotation.Annotation 接口
    该接口代表程序中可以接收注解的程序元素
reflect
    从 Java 5 开始，java.lang.reflect 包所提供的反射 API 增加了读取运行时注解的能力。
    只有当定义注解时使用了 @Retention(RetentionPolicy.RUNTIME) 修饰，该注解才会在运行时可见。
使用
    程序通过反射获取了某个类的 AnnotatedElement 对象（如 Class、Method、 Constructor 等）之后，
    程序就可以调用该对象的相关方法来访问注解信息
相关方法
    getDeclaredAnnotationXXXX：
    	只可以获取直接存在的注解信息，即直接修饰在某个元素（类、属性和方法）上的注解。
    getXXXXByType：
    	可以获取间接存在的注解信息
    getAnnotationXXX：
    	可以获取继承的注解信息
    
语法案例
    	
//  这是自定义注解的类
    @Target({ ElementType.TYPE, ElementType.METHOD })
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    public @interface MyRequestMapping {
        String value(); // 这是注解的一个属性字段，也就是在使用注解时填写在括号里的参数
    }
// 使用
    @MyRequestMapping("/test")
    public class TestController {
        public void test() {
            System.out.println("进入Test方法");
        }
    }
// 获取注解信息
public class Test {
    public static void main(String[] args) {
        Class<?> c = TestController.class;
        MyRequestMapping baseRequestMapping = c.getAnnotation(MyRequestMapping.class);
        System.out.println(baseRequestMapping.value()); // 输出value的值: /test
    }
}
```



## 使用

### 介绍

```jaa
获取注解中定义的属性值， 
后期都是替换配置文件的
```

