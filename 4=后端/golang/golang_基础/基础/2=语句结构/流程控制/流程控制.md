
[toc]

## 前言

* 不做文字的搬运工，多做灵感性记录
* 这是平时学习总结的地方，用做知识库
* 平时看到其他文章的相关知识，也会增加到这里
* 随着学习深入，会进行知识拆分和汇总，所以文章会随时更新
* 参考的文章过多、很杂很乱，所以参考会写不全，见谅

<font size=5 color= yellow>流程控制</font>

主要是三大流程控制流程控制语句

1)顺序控制

2)分支控制

3)循环控制

## 1.顺序控制

程序从上到下逐行地执行，中间没有任何判断和跳转。

1. 注意

   * Golang中定义变量时采用合法的前向引用。

     就是说你使用变量就需要提前声明它

## 2.分支语句

### 1.形式

* 单分支  
* 双分支
* 多分支

### 2. if  分支控制

#### 2.单分支控制  if

```go
if 条件表达式 {

	执行代码块

}
条件表达式为true时，就会执行{}的代码，注意{}是必须有的，就算你值写一行代码
// golang支持在if中直接定义一个变量
if age := 20;age > 18{
    ...
}
```

#### 3.双分支语句  if

```go
if 条件表达式 {
	执行代码块 1
}else{
    执行代码块 2
}

// 注意
1.条件表达式为true时，就会执行代码块1，否则就执行代码块2，注意{}是必须有的
2.双分支只会执行其中的一个分支

```

#### 4.多分支控制  if

```go
if 条件表达式 {
	执行代码块1
}else if 条件表达式{
    执行代码块2
}else if 条件表达式{
    执行代码块3
}else{
    执行代码块 n
}
// 注意
else不是必须的，但多分支只能执行一个执行入口    
    
```

#### 5.if 特殊写法

```go
// if 表达式之前添加一个执行语句，再根据变量值进行判断
// 将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中
// 优点 ：变量的作用范围越小，所造成的问题可能性越小， 限制变量的作用范围

if _, ok := map[key]; ok {
    //存在
}

_, ok := map[key] :  一个带有返回值的函数
ok  			 ： if 的判断表达式
```



### 3. 嵌套分支

       在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支，外面的分支结构称为外层分支。嵌套分支不宜过多，建议控制在3层内。

### 4. switch case分支控制

1. switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上到下逐一测试，直到匹配为止。
2. go的switch case默认有break。如果不需要break
3. 用来改多重 if else 语句

```go
switch 表达式{
	case 表达式1，表达式2，...：
		语句块1
	case 表达式3，表达式4，...:
		语句块2
		
	default:
		语句块3
}

// 注意
1.先执行switch的表达式得到值。然后执行case的语句，进行比较，遇到相等的，就比配到，执行对应的case的语句块，然后退出switch，如果没有匹配成功，就会执行default语句
2.case后的表达式可以有多个，用逗号隔开
3.switch 后面也可以不带表达式，直接跟上（:）类似 if - case 分支来使用
	switch:{}
4.switch 后面也可以直接声明/定义一个变量，以分号结尾（不推荐）
	switch grade:=90;{}

5.switch穿透-fallthough，
	如果在case语句块后增加fallthrough，会继续执行下一个case,

	var num int = 20
	switch num{
        case 10:
            fmt.Print('ok')
            fallthrough  //默认只能穿透一层,执行case 30
        case 30:
        	fmt.Print('1')
         // case不需写break,默认情况下执行case语句以后，就跳出switch控制语句
        	break   
        default:    // 不是必须的，
        	fmt.Print('2')
    	}

6. type - switch 
	参看接口的类型开关 —— 断言
```

### 5. if 相关

*   1.switch 和 if 区别

1)  如果判断的具体数值不多，而且符合整数、浮点数、字符、字符串这几种类型。建议使用swtich语句，简洁高效。

2)  其他情况:对区间判断和结果为bool类型的判断，使用if,  if的使用范围更广。

## 3.循环结构

* golang中没有while和do..while的语法，需要通过for循环实现

### 1.for 循环结构

```go
for 循环变量初始化 ；循环条件 ； 循环变量迭代{
	循环执行语句（语句）
} 

// 执行顺序
// 变量初始化 - 循环条件 - 执行语句 - 循环变量迭代 - 循环条件 - 执行语句 - 循环变量迭代 -。。。
// 注意省略情况

// 初始化语句
	 第一次循环前执行的语句，一般使用初始语句执行变量初始化，
	 如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。 
	 初始语句可以被忽略，但是初始语句之后的分号必须要写，

// 条件表达式
	控制是否循环的开关， 每次循环开始前都会计算条件表达式，

     表达式为 true     ：则循环继续，

     表达式为 false   ：结束循环

     表达式忽略        ：后默认形成无限循环。 

// 结束语句
	在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。
```

### 2.省略实现循环

```go
1. 省略初始化循环变量、循环变量迭代： //相当于while循环 
     for i > 10{}
             循环变量初始化
       
        说明：1.此for循环是一个无限循环
             2.break就是来跳出for语句
2.全部省略   // 无限循环
	1.保留分号
		for ; ;{
                循环执行语句
                break
            } 
	2.不保留分号  
		// 实现 while
		// 实现 do - while
		for{
                循环执行语句
                break
         }
```



### 3.实现  while   循环

```go
 for{
    if 循环条件表达式{
        break //跳出for循环
    }
    循环操作（语句）
    循环变量迭代
}
```

### 4.实现 do - while

```go
循环变量初始化
 for{
     循环操作（语句）
     循环变量的迭代
     if 循环条件表达式{
         break  //跳出for循环
      }
  }
 1.先执行，再判断，因此至少执行一次
 2.循环条件成立后，就会执行break，跳出for 循环，结束循环
```









### 5.多重循环控制

1. 一个循环放在另一个循环体内，就形成了嵌套循环，建议一般使用两层，最多不适用三层
2. 实质就是内层循环的循环条件为false时，才会跳出内层循环，才结束外层的  当次  循环
3. 外层循环m次，内层循环n次，则内层循环体需要执行  m *   n次
4. 编译后先易后难，将一个复杂的问题分解为简单的问题，

### 6. for range

*   遍历 集合 

    ```go
    数组
    切片
    字符串   : key 和 value 分别代表字符串的索引和字符串中的每一个字符。
    map   	: key 和 value 分别代表 map 的索引键 key 和索引对应的值
    通道     : 是通道在遍历时，只输出一个值，即管道内的类型对应的数据。
    ```

*   语法

    ```go
    for index, value := range slice {  //以切片为例
      ...
    }
    ----------------------
    // 关键字 range 会返回两个值，第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本
    // 注意 ：不是直接返回对该元素的引用，
    index 索引  (可以自定义为其他字母)
    value 值    (可以自定义为其他字母)
    	始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，
    	 对它所做的任何修改都不会影响到集合中原有的值。
    
    a := []int{1, 2, 3}
    for index, value := range a {
        fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n", value, &value, &a[index])
    }
    Value: 1 Value-Addr: C0000120A0 ElemAddr: C00000C560
    Value: 2 Value-Addr: C0000120A0 ElemAddr: C00000C568
    Value: 3 Value-Addr: C0000120A0 ElemAddr: C00000C570
    // 因为迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的，要想获取每个元素的地址，需要使用切片变量和索引值,如：&a[index]
    ----------------------
     
    
    range 总是会从切片头部开始迭代
    // 对迭代做更多的控制，则可以使用传统的 for 循环
    for index := 2; index < len(slice); index++ {
            fmt.Printf("Index: %d Value: %d\n", index, slice[index])
    }
    ```

*   字符串遍历

    ```go
    // 一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串
    // key 和 value 分别代表字符串的索引和字符串中的每一个字符。
    // 够自动根据 UTF-8 规则识别 Unicode 编码的字符
    ```
    
    
    
*   map 遍历

    ```go
    // 遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。
    // 如果需要特定顺序的遍历结果，正确的做法是先排序
    	将 map 中的数据放到一个 切片中去，将切片中的数据进行排序，最后遍历切片就行了
    
    for key, value := range map{}
    // 只遍历key,无须将值改为匿名变量形式，忽略值即可
    for key := range map{}
    // 只遍历value
    for _, value := range map{}
    ```

    

### 6.跳出循环

#### 1.普通跳出循环

```go
// 默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。

func main() {
    
    var breakAgain bool
    for x := 0; x < 10; x++ {			// 外循环
        for y := 0; y < 10; y++ {		// 内循环
            
            if y == 2 {			     	// 满足某个条件时, 退出循环
                  breakAgain = true        // 设置退出标记，退出内层循环
                 break
            }
        }
        
        if breakAgain {  // 根据标记, 跳出外层循环
                break
        }
    }
    fmt.Println("done")
}
```



#### 1. break

*  一般都是用来跳出 `for` 或 `switch` 语句。在 Go 中也可以在 `select` 语句中使用 `break`。 
* 跳出  当前（最近）  的 for 循环、switch语句
*  跳出标签, 
    * 表示退出某个标签对应的代码块，
    * 标签要求必须定义在对应的 for、switch 和 select 的代码块上。 

```go
// 为不带标签的break只能终止最内层(innermost)的循环，如果像终止外部的循环，就得用标签了：

lable 2:
    for i := 0;i < 4; i++{
        for  j := 0;j < 4;j++{  //设置一个lable1  
            if j == 2{
            break lable2         //跳出lable2下面对应的for循环
            }
        } 
    }

```

*  语句不能跨越函数边界。

```go
// 跨越边界会报错	 break is not in a loop, switch, or select
```



####  2. fallthrough  

```go
// 参见 switch 
```



#### 3.contine

1.  仅限在 for 循环内使用 

2. 跳出本次循环，执行下一次循环

3. continue 标签

    *    表示开始标签对应的循环 

4. 可以通过标签指明要跳过的哪一层循环，调到标签对应的 for 循环处

   ```go
   here:
       for i:=0;i<4;i++{
           for j:=1;j<4;j++{
               if j==2{
                   continue here  // 代码运行到这里开启下一层循环
               }
              fmt.Print("i=",i,"j=",j)
           }
       }
   
   /*
   
   i= 0 j= 1
   i= 1 j= 1
   i= 2 j= 1
   i= 3 j= 1
   
   */
   
   ```

   

#### 4.goto

1. 不建议使用，以免造成程序流程的混乱，使理解和调试程序都产生困难

2. 可以无条件跳到程序中指定的行，接着往下运行

3. goto语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。

    

```go
if n > 20{
	goto lable2
}

lable2:
	fmt.Println("game over")
```

#### 5.return

* 如果return是在普通的函数，则表示跳出当前所在的方法或函数，即不再执行函数中return后面代码

* 如果return是在main函数，表示终止main函数，也就是说终止程序。

    ```go
    参看函数返回值
    ```

## 跳转

* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)

