

## 介绍

* Go语言的包借助了目录树的组织形式

* 一般包的名称就是其源文件所在目录的名称。

* 这就像在一个已经存在的包中生成一个子目录一样，

* 在编写代码时，导入包需要做的仅仅只是提供这个要被嵌套的包的相对路径。

* go语言是以包为组织的，类似于其他语言的库和模块，一个包下可有多个源文件

    Go语言都是以包为组织的，类似于其他语言中的库和模块。



## 1 .引入

* 调用其他文件定义的函数
* 优先搜寻GOROOT/src 目录中寻找包目录，如果没有找到，则会去 GOPATH/src 目录中继续寻找，不用带 src ,编译器会自动从 src 下开始引入 

* 使用go mod 之后就变了

## 2.原理

包的本质就是创建不停的文件夹，来存放程序文件

## 包名

*   包名，就是文件所在文件夹的名称 , 通常以 .go 文件最近的一层文件夹
*   包名一般是小写的，使用一个简短且有意义的名称。
*   包名一般要和所在的目录同名，也可以不同，包名中不能包含`- `等特殊符号。
*   包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到`GOPATH/src/github.com/userName/projectName `目录下。
*   包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。
*   一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。





## 1. 声明包

*   叫打包

```go
//package 就是声明这个包在哪里，在哪个文件夹

// 使用 go mod 以后，格式就是 项目文件夹/包名
package 包名
	// 打包就是声明这个文件属于哪个文件夹，

```

## 2.导入包

```go
单行导入  
	import  " 包的路径 "   //包中函数首字母大写和小写有区别  
多行导入
     import(
           "包的路径"	
           "包的路径"	 
         )

// package 指令在文件第一行，然后是import文件
// 开启go moudle 后,包名为
	导入自己的包 ： 报的路径就是全路径 ，项目名/子文件夹/...
// 导入第三方包
	全路径

相对路径
	
绝对路径


注意的是 package 使用的是包所在的文件目录，除非有 main 文件，文件夹变成 main 文件夹，但是此时作为 mian 文件夹，此目录内的 文件 都是 package main:// 即同一个目录文件家中的 package 语句都是一样的
```

## 引用

### 标准引用

```go
import "fmt"

此时可以用fmt.作为前缀来使用 fmt 包中的方法，这是常用的一种方式。
fmt.Println("666")
```

### 自定义别名引用

```go
import f "fmt" 

f 就是 fmt 包的别名
使用f.来代替标准引用格式的fmt.来作为前缀使用 fmt 包中的方法。
f.Println("666")

// 假如有一个变量名字为 f , 包的别名就设置为 fpkg
1. 导入包的重命名只影响当前的源文件。
	其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。
```



### 省略引用格式

```go
import ."fmt"

把 fmt 包直接合并到当前程序中，在使用 fmt 包内的方法是可以不用加前缀fmt.，直接引用。
Println("666")
```



### 匿名引用格式

```go
import _ "database/sql" // import _"报的路径"

1. 匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中
2. 引用包时，仅执行包的初始化 init 函数，而不使用任何包内的结构和类型，也不调用包内的任何函数时
	即使包没有 init 初始化函数，也不会引发编译器报错。

```

### 注意

*   引入包，必须避免死循环，如 A 引 B , B引C, C引A.





## 2.包加载+init

### 过程

*   找包

*   引包

    ```go
    1.一个文件调用多个包 ： 从上到下初始化 import 中的写的包
    2. 一个包只初始化一次 ： 即前面初始化过了，就不在进行初始化( 不再执行init )
       包的重复引用是允许的，但只能被初始化一次
    3. main 包依赖其他包，所以最后初始化，以深度优先顺序初始化。
    ```

*   链式引包

    *   被依赖的总是先被初始化，有依赖就要进行初始化
    *   例如：引包顺序 main –> A –> B –> C，则初始化顺序为 C –> B –> A –> main

<img src="F:/%25E6%2595%25B4%25E7%2590%2586%25E6%2596%2587%25E4%25BB%25B6/go%25E8%25AF%25AD%25E8%25A8%2580/go%2520%25E8%25AF%25AD%25E6%25B3%2595%25E7%25BB%2593%25E6%259E%2584/image-20200905133735414.png" alt="image-20200905133735414" style="zoom:80%;" />



*    init 函数

     ```go
     // init只可以由go runtine自已调用， 我们在代码中不可以显示调用，也不可以被引用，如赋给a function variable。
     
     1. 一个文件		：有多个 init 函数 ：从上到下 
     2. 一个 package ： 不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数		
     	同一个包中的多个 init() 函数的调用顺序不可预期。(注意)
     3.init() 函数不能被其他函数调用。
     4.init() 函数会在程序执行前（main() 函数执行前）被自动调用。
     
     
     // 注意--------------------
     
     1.，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。
     
     ```

*   变量

    *   const var 也遵循 init 函数

### 特点

*   包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。
*   Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。
*   单个包的初始化过程如上图所示，先初始化常量，然后是全局变量，最后执行包的 init 函数。



## 2.访问

*   判断是否是一个包

    *   不管 包 所在的目录有几个文件。主要是看每个文件中 package xx，(xx为包名，xx一样就在一个包)

*   包内标识符

    *   ```go
        // 标识符（如类型、变量、常量、结构图、结构体字段等）
        首字母大写 ：可以跨包引用访问
        首字母小写 ： 只能包内引用访问
        ```

### 同包访问

```go
// 访问设置的常量、函数、结构体、
	直接使用，可以直接使用不同文件的变量等信息
```



### 跨包访问

```go
// 标识符首字母小写 ： 只能包内引用访问

1. 一个包里引用另外一个包里的标识符（如类型、变量、常量、结构图、结构体字段等）时，必须首先将被引用的标识符导出，
2. 将要导出的标识符的首字母大写就可以让引用者可以访问这些标识符了。

1. 无论包中有多少个 .go 文件，引用哪个文件的标识符，都是
	包名.标识符
	包名.函数名（）	包名.常量



//一个项目的目录
.
|-- client
|   `-- login.go		package main
|   `-- main.go			package main
|-- common
|   `-- message.go
|-- go.mod
|-- server
|   `-- main.go
```



## 3.基本概念

每一个文件都属于一个包，go以包（文件）的形式来管理文件和项目目录结构的

## 4.作用

1.区分相同名字的函数、变量等标识符

2.当程序文件很多时，可以很好管理项目

3.控制函数、变量等访问范围，即作用域

## 5.使用

1. 再给一个文件打包是，该包对应一个文件夹，文件的包名和文件所在的文件夹名字一致，一般为小写字母
2. 当一个文件使用其他包函数或者变量时，需要先引入对应的包
3. 同一个包中，不能有相同的函数（也不能有相同的全局变量名），否则重复定义
4. 要编译一个可执行的程序文件，就需要将这个包声明为main()即package mian
    是一个语法规范，若自己写一个库，包名也可以自定义
5. 如果一个程序是 main 包的一部分，那么在 go install 则会生成一个二进制文件，在执行时则会调用 main 函数。如果一个程序除了 main 包外还是其他包的一部分，那么在使用 go install 命令时会创建包存档文件。（run main函数=install+执行main）

## 6.闭包

#### 1.概念	

​	闭包就是一个函数和与其相关的引用环境组合的一个整体(实体,整体封装到到一个函数中)，即：闭包=函数+引用环境

#### 2.本质

```go
// 函数中返回另一个函数，防止变量污染，变量使用过后会保留，不会被删除，省内存
// 将函数和它使用到的变量都封装到一个函数中
	
 //AddUpper()返回的数据类型是func(int) int 
func AddUpper() func(int) int{   
   var n int = 10                 // x叫做自由变量
   return func(x int) int{      // 匿名函数引用到函数外的n，因此这个匿名函数就和n形成一个整体，构成闭包。 
        n = n + x
        return n
    }
}	
	
原码分析
1. 闭包是类，函数时操作，n是字段。函数和它使用到n构成闭包。
2. 反复的调用f函数时，因为n是初始化一次，因此每调用一次就进行累计。
3. 闭包的关键，就是要分析出返回的函数它使用(引用)到哪些变量，因为函数和它引用到的变量共同构成闭包。
4. 函数f每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。
	

运行分析，注意累计
func main(){
    var f = AddUpper()
    fmt.Printf("结果=%d\n",f(1))     // 结果 = 11
    fmt.Printf("结果=%d\n",f(20))    // 结果 = 21
    fmt.Printf("结果=%d\n",f(300))   // 结果 = 331
	
--------------------------------------------------------------
// 编写函数接收一个文件后缀名，返回一个闭包，传入一个文件名，若文件名没有指定的后缀则返回 文件名.jpg，如果有就返回全名
    func makeSuffix(suffix string) func (string)string{
        return func.HassSuffix(name,suffix){
            return name + suffix
        }
        return name
    }
    f2 := makeSuffix(".jpg")
    fmt.Println(f2("writer")) // winter.jpg
    fmt.Println(f2("bird.jog")) // bird.jpg
   // 闭包会保存上次引用的某个值，所以穿一次.jpg就可以了
副作用

func main(){
    for i:=0;i<5;i++{
        go func(x int){
            fmt.Println(x)
        }(i)
 
    }
    time.Sleep(time.Second)
}
   结果  ：5 5 5 5 5 
   分析：实际上面这里每一个go协程中的匿名函数和外部for循环的i也形成了闭包，因为for循环执行比较快，所以go还没来得及执行就变成5了。  ？？？
   
更改：在每一个go协程之后加一个延时，结果就是0,1,2,3,4了
   func main(){
    for i:=0;i<5;i++{
        go func(){
            fmt.Println(i)
        }()
            time.Sleep(time.Second)
    }
    time.Sleep(time.Second)
}
```

#### 3.破包

* 问题就在于不可能每次执行都进行延迟，所以需要做一件事情打破这个闭包。

```go
这里把i当做参数传入到匿名函数中，保证了每次循环传的值都不一样
func main(){
    for i:=0;i<5;i++{
        go func(x int){
            fmt.Println(x)
        }(i)

    }
    time.Sleep(time.Second)
}
   
	
	
	不同在作用域

容易造成内存泄露
n 就像一个私有变量
因为他调用的函数返回了一个带参数 的函数
就是内部函数引用外部函数，被引用和初始化一次
闭包的变量只能作用在函数内
就是类的属性变化
```

#### 4.构建闭包

```go
1. 确定闭包的两个函数，一个主函，一个返回的闭包函数
   1.闭包函数需要调用的主函的变量，
	   1.就是闭包函数使用的外部变量，要放在主函数中
        2.如果这个变量可以是主函的形参，但是此时需要在执行是把主函数的形参给传递上，
        3.果这个变量不是,那主函数形参为空，引用变量需要在闭包函数前声明
   2.确定闭包函数的代码执行块，
   3.确定 return 的值
2. 主函数进行变量赋值
   主函数有形参，需要提前把形参传递进去，没有形参的话，就知赋值就行
3. 利用变量进行函数传参计算

```



