## 1.函数

* 为完成某一功能的程序指令(语句)的集合，称为函数。

## 2.类型

*    函数的类型被称为函数的标识符 

*   分类

    ```go
    1.	普通的带名字的函数
    2.	匿名函数
            又称： lambda 函数
    3.	方法
    ```

*   相同类型

    *    如果两个函数形式参数列表和返回值列表中的变量类型一一对应，
    *   这两个函数被认为有相同的类型和标识符，
    *   形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。 



## 函数签名

```go
函数签名就是函数的声明信息，包括参数、返回值

参数 	 ：	类型 个数 顺序
返回值	：  类型 个数  
异常   ：
这个众说纷纭，貌似没啥统一的
```




## 3.基本语法

```go
func 函数名 （形参列表） （返回值类型列表）{
	执行语句
	return  返回值列表
}
```

*   形参列表

    *   表示函数的输入 ，形参列表可以是多个
    *   数据类型可以是：值类型和引用类型类型和引用类型
    *   局部变量，其值由参数调用者提供

*   返回值列表

    *    描述了函数返回值的变量名以及类型 

    *   无返回值

        *    返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。
        *    不包括返回值列表，那么函数体执行完毕后，不会返回任何值 

    *   有返回值

        *    必须以 return 语句结尾，除非函数明显无法运行到结尾处， 

    *   返回值指只有一个，返回值类型列列表可以不写 

    *   可有可无，数量不限

        

*   执行语句

    *   实现某一功能代码块

*   函数变量

    *   局部变量，函数外不生效

     

## 4.参数

### 1.调用

*   函数在调用时都必须按照声明顺序为所有参数提供实参（参数值）
*   形参和返回值的变量名对于函数调用者而言没有意义。 
    *   函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参

### 2.传递方式

* 变量储存的是一个地址，这个地址对应的空间才是真正存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址的时候，改地址对应的数据空间就成为一个垃圾，由GC回收。（数据在空间上）

*  传入与返回参数在调用和返回时都使用值传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参

    *   实参若包括引用类型，如指针、slice(切片)、map、function、channel 等类型，
    *   参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用
    *   实参可能会由于函数的间接引用被修改。

    ```GO
    package main
    
    import "fmt"
    
    // 代表各种结构体字段
    type InnerData struct {
    	a int
    }
    
    // 值传递结构体
    type Data struct {
    	complax  []int      // 测试切片在参数传递过程中的效果
    	instance InnerData  // 实例分配的 innnerData
    	ptr      *InnerData // 将 ptr 声明为 InnerData 的指针类型
    }
    
    // 值传递测试函数
    /* 该函数的参数和返回值都是 Data 类型，
    在调用过程中，Data 的内存会被复制后传入函数，
    当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量
    */
    func passByValue(inFunc Data) Data {
    
    	/*
    	输出参数成员情况
    	输出 inFunc 变量的详细结构，
    	以便观察 Data 结构在传递前后内部数值的变化情况
    	*/
    
    	fmt.Printf("inFunc value :%+v\n", inFunc)
    
    	// 打印 inFunc 的指针
    	// 打印传入参数 inFunc 的指针地址，
    	// 在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。
    	fmt.Printf("inFunc value: %p\n", &inFunc)
    
    	// 将传入的变量作为返回值返回，返回的过程将发生值复制。
    	return inFunc
    }
    
    func main() {
    	// 准备传入函数的结构体,创建一个 Data 结构的实例 in
    	in := Data{
    		complax: []int{1, 2, 3},
    		instance: InnerData{
    			5,
    		},
    		ptr: &InnerData{1},
    	}
    	// 结构的成员情况
    	fmt.Printf("in value:%+v\n", in)
    
    	// 结构体的指针地址
    	fmt.Printf("in ptr :%p\n", &in)
    
    	// 传入结构体，返回同类型的结构体
    	out := passByValue(in)
    
    	// 输出结构的成员情况
    	fmt.Printf("out value :+v\n", out)
    
    	// 输出结构的指针地址
    	fmt.Printf("out ptr : %p\n", &out)
    }
    
    
    // 结果
    in value: {complax:[1 2 3] instance:{a:5} ptr:0xc042008100}
    in ptr: 0xc042066060
    inFunc value: {complax:[1 2 3] instance:{a:5} ptr:0xc042008100}
    inFunc ptr: 0xc0420660f0
    out value: {complax:[1 2 3] instance:{a:5} ptr:0xc042008100}
    out ptr: 0xc0420660c0
    
    
    所有的 Data 结构的指针地址都发生了变化，
    	意味着所有的结构都是一块新的内存，
    	无论是将 Data 结构传入函数内部，还是通过函数返回值传回 Data 都会发生复制行为。
    所有的 Data 结构中的成员值都没有发生变化，
    	原样传递，意味着所有参数都是值传递。
    Data 结构的 ptr 成员在传递过程中保持一致，
    	表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。
    
    ```

    

1.值传递

```go
1.	传递的是值的拷贝，数据量大，越大效率越低
2.	在函数内修改，不会影响到原来的值
3.	变量直接存储值，内存通常在栈中分配
```

2.引用传递

```go
1.传递的是值的地址的拷贝，地址数据量小，拷贝效率高
```

### 3.类型

```go
// 就是基本数据类型
值类型     ：int  、float 、bool、 string  数组   结构体

引用类型 ：指针   slice  map   chan   interface

// 如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型
func f(i, j, k int,) (s, t string) { /* ... */ }
```

### 4.空白标识符

*   在接收时，希望忽略某个返回值时，用 _ 字符，占位忽略

### 5.可变参数

*   介绍

    *   go支持可变参数，参数数量可变的函数称为可变参数函数

*   格式

    *   形式

        ```go
        ...type
        1. 只能作为函数的参数类型存在，并且必须是最后一个参数，但不是唯一一个参数
        3. 遍历 ： 可以使用 for 遍历
        
        // ---------------------------------------------------------
        func sum(args...int) int {} //args是个切片
        sum() 接受不定数量（支持0到多个参数）的参数，这些参数的类型全部是 int，
        ```

        

    *   本质

        ```go
        2. 本质 ： 本质上是一个数组切片，也就是[]type，但是和切片还是有区别
        	func f(...int) {}
        	func g([]int) {}
        
            fmt.Println("%T\n", f)      //"func(...int)"
            fmt.Println("%T\n", g)      //"func([]int)" 
        
        ```

*   使用

    ```go
    //在函数体中，values被看做是类型为 []int 的切片。sum函数可以接收任意个数量的int参数
    // sum函数接收任意个int参数
    func sum(values...int) {           
        total := 0           
        for _, value := range values {
            total += value
        }
        return total
    }
    
    
    // 如果原始参数已经是切片类型，需要在最后一个参数后加上省略号。
    values := []int{1,2,3,4}
    // 调用 sum 函数
    sum(values...)   //"10"
    
    
    可变参数经常被用于格式化字符串
    ```

*   特殊类型的可变参数

    *   任意类型的可变参数

        ```go
        func sum(args...interface{}) int {} //args是个切片
        //  interface{} 传递任意类型数据是Go语言的惯例用法，使用 interface{} 仍然是类型安全的
        ```

    *   遍历可变参数列表——获取每一个参数的值

        ```go
        // 可变参数列表的数量不固定，传入的参数是一个切片，
        // 如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，
        
        
        // 定义一个函数, 参数数量为0~n, 类型约束为字符串
        func joinStrings(slist ...string) string {
            // 定义一个字节缓冲, 快速地连接字符串
            var b bytes.Buffer
            // 遍历可变参数列表slist, 类型为[]string
            for _, s := range slist {
                // 将遍历出的字符串连续写入字节数组
                b.WriteString(s)
            }
            // 将连接好的字节数组转换为字符串并输出
            return b.String()
        }
        func main() {
            // 输入3个字符串, 将它们连成一个字符串
            fmt.Println(joinStrings("pig ", "and", " rat"))
        }
        ```

        

    *   获得可变参数类型——获得每一个参数的类型

        ```go
        // 当可变参数为 interface{} 类型时，可以传入任何类型的值，
        // 如果需要获得变量的类型，可以通过 switch 获得变量的类型，
        
        func printTypeValue(slist ...interface{}) string {
            // 字节缓冲作为快速字符串连接
            var b bytes.Buffer
            // 遍历参数
            for _, s := range slist {
                // 将interface{}类型格式化为字符串
                str := fmt.Sprintf("%v", s)
                // 类型的字符串描述
                var typeString string
                // 对s进行类型断言
                switch s.(type) {
                    case bool:    // 当s为布尔类型时
                        typeString = "bool"
                    case string:    // 当s为字符串类型时
                        typeString = "string"
                    case int:    // 当s为整型类型时
                        typeString = "int"
                }
                
                // 写字符串前缀
                b.WriteString("value: ")
                // 写入值
                b.WriteString(str)
                // 写类型前缀
                b.WriteString(" type: ")
                // 写类型字符串,字符串描述
                b.WriteString(typeString)
                // 写入换行符
                b.WriteString("\n")
            }
            return b.String()
        }
        func main() {
            // 将不同类型的变量通过printTypeValue()打印出来
            fmt.Println(printTypeValue(100, "str", true))
        }
        ```

        

    *   在多个可变参数函数中传递参数

        ```go
        // 可变参数变量是一个包含所有参数的切片，
        // 如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加...，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。
        // 可变参数使用...进行传递与切片间使用 append 连接是同一个特性
        
        
        // 实际打印的函数
        func rawPrint(rawList ...interface{}) {
            // 遍历可变参数切片
            for _, a := range rawList {
                // 打印参数
                fmt.Println(a)
            }
        }
        // 打印函数封装
        func print(slist ...interface{}) {
            // 将slist可变参数切片完整传递给下一个函数
            rawPrint(slist...)
        }
        func main() {
            print(1, 2, 3)
        }
        ```

        



## 5.函数返回值

### 1.无返回类型

```go
// return语句不能返回任何值。
func sum(a,b int){
    c := a + b
    return
}
```



### 2.有返回类型

*    Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，
*   Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误， 

#### 1.无变量名称返回值 

```go
//	return 
		1. 语句返回时，值列表的顺序需要与函数声明的返回值类型一致 
		2. 显示返回，每个表达式必须是单值的 
		3. 最外层不可以裸返回，
			// 编译器不知道你具体会在哪里返回，这个要运行时才能确定，
			//  所以，你最外面没有返回，编译器就认为你错了，语法不通过 

// 括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。
func typedTwoValues() (int, int) {
    return 1, 2
}

//  纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。  
```

#### 2.带有变量名的返回值

*    支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型 

    ```go
    // return 
    	1. return 可以返回空。这些返回类型参数就像本地变量一样,可以裸返回
    	2. 函数最外层可以直接裸返回,
    	   内层的省略会出错，需显式返回(待确认)
    	3. 所有的结果值在函数的开始时都被初始化为它们的零值
    
    
    func complexF3() (re float64, im float64) {
    	re = 7.0
    	im = 4.0
    	return	// 没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。
    }
    
    func f(n int) (res int, err error) {
    	if _, err := f(n-1); err != nil {
    		return  0, err// 省略会出现，invalid return statement: err is shadowed ,编译器不允许返回空
    	}
    	return  // 最外层，可以裸返回
    }
    
    // 注意
        func (devnull) Write(p []byte) (n int, _ error) {
            n = len(p)
            return
        }
    ```

#### 3.混用

```go
以上两种返回方式  不可以混用！不可以混用！不可以混用
```



## 6.函数调用

### 1.调用格式

```go
返回值变量列表 := 函数名(参数列表)

    函数名：需要调用的函数名。
    参数列表：参数变量以逗号分隔，尾部无须以分号结尾。
    返回值变量列表：多个返回值使用逗号分隔。
	:=  在其他函数中，返回值参数变量表的变量是第一次使用，故用这个，也可以用 = 
```



### 2.调用机制

```go
栈区：基本数据类型分配单栈区，编译器存在一个逃逸分析

堆区：引用类型数据分配到堆区，编译器存在一个逃逸分析

1. 在调用一个函数时，会给该函数分配一个新的空间（栈），编译器会通过自身的处理让这个新的空间和其它的栈的空间区分开来
2. 在每个函数对应的栈中，数据空间是独立的，不会混淆
3. 当一个函数调用完毕(执行完毕)后，程序会销毁这个函数对应的栈空间。
```

### 3.调用过程

```go
1.函数在定义之后，皆可调用
2.可以通过调用的方式,让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。
3.函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失。
```



## 7.特殊函数

### 1、递归函数

*   介绍

    *   一个函数体内又调用了自身，称之为递归函数。

*   使用条件

    ```go
    1)执行一个函数时，就创建一个新的受保护的独立空间(新函数栈、压栈)
    
    2)函数的局部变量是独立的，不会相互影响
    
    3)递归必须向退出递归的条件逼近，否则就是无限递归，死龟了:)
    
    4)当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或者返回时，该函数本身也会被系统销毁
    
    //-------------------------------
    
    1. 一个问题可以被拆分成多个子问题；
    2.拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；
    3.不能无限制的调用本身，子问题需要有退出递归状态的条件。
    4.编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。
    ```

*   例子

    *   斐波那契数列

        ```go
        func  recursion{
            recursio
        }
        
        斐波那契数列
        
        func fibonacci (n,int)int{
        	if n < 2{
        	return  n
        	}
        	return fibonacci(n-2) + fibonacci(n-1)
        }
           
        ```



使用

1.分析结果

​		从外层开始向最里层进行数值递归，一致递归到最底层，利用树状图对每个部分进行往下递归

​		找到最底层的函数的返回值，然后一层一层往上面进行计算，在算到顶层

2.编写递归循环

​		1.找到最底层的函数值，来进行最初值进行迭代的最初值

​		2.找到迭代的表达式

​		3.找到迭代终止的迭代条件,

### 2、init 函数

* init 函数会在所有程序调用前被调用，即在包被初始化时被 Go 调用，完成初始化（全局变量的初始化？？？）
* 不需要任何参数也不返回任何值。
* Go 隐式调用，因此你无法从任何地方引用它，
* 但可以使用func init() 这样来调用它。 主要是将在全局代码中无法初始化的全局变量初始化。  

```go
1.如果一个文件同时包含全局变量定义，init函数 和 main函数 ，执行的流程
		全局变量定义  > init 函数  > main 函数
2.每个包可以有多个 init 函数，所有被编译器识别的 init 函数都会在main 函数之前被调用， 通常被用来注册一个程序需要使用的依赖，如mysql注册，配置文件加载等 


初始化导入的包
	导入的包  （因为编译的时候会检查先导入的包） 
    	1   变量的定义
     	2   init函数      
	main包  （main 包总是被最后一个初始化，因为它总是依赖别的包）
    	3   变量定义
     	4   init函数
     	5   main函数
     	
1. 同一个go文件      init()调用顺序是从上到下的。
2. 同一个package    不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。
3.不同的package     按照main包中"先import的先调用"的顺序调用其包中的init()
```

### 3、匿名函数

*   介绍
    *   即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体 
    *    匿名函数也往往以变量方式传递 
    *    支持随时在代码里定义匿名函数 

*   定义格式

    ```go
    // 匿名函数就是没有名字的普通函数
    
    func(参数列表)(返回参数列表){
        函数体
    }
    ```

*   调用

    1.  定义的时候进行调用

        ```go
        1. 这种匿名方式只能调用一次
        //--------------------------------------------------------
        a := func （n1 int,n2 int）int(){
        		return n1 + n2
        }(10,20)  // (10,20) 即为对函数的调用，传入的参数是 (10,20)
        ```

        

    2.  匿名函数赋值给变量

        ```go
        1.实现多次调用
        2.将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数
        3.全局匿名函数
        	将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序中有效
        
        //-------------------------------------------------------
        func （n1 int,n2 int）int(){
        		return n1 + n2
        }
        var a func()
        a = 
         a（10 ， 20） // a 调用匿名函数
        
        
        // 全局匿名函数
        
        var (
            FUN1 := func （n1 int,n2 int）int(){
        		return n1 + n2  }
        )
    res := FUN1(10 ,20)
        ```
        
        

* 使用
  
  *   匿名函数作为回调函数
    
      ```go
        //  回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
        // 回调方法 是 任何一个 被 以该回调方法为其第一个参数 的 其它方法 调用 的方法。很多时候，回调是一个当某些事件发生时被调用的方法。
        
        
        // 使用 visit() 函数将整个遍历过程进行封装，
        // 当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。
        
        func visit (list []int, f func(int)) {
            // // 遍历切片的每个元素, 通过给定函数进行元素访问
            for _, v := range list{
                f(v)
            }
        }
        
        func main(){
            // 使用匿名函数打印切片内容
            visit([]int{1,2,3,4},func(v int)){
                // 定义了一个匿名函数，作用是将遍历的每个值打印出来。
                fmt.Println(v)
            }
        }
      ```
  
  *   匿名函数实现封装
  
      ```go
      //
      
      // 定义命令行参数 skill，从命令行输入 --skill 可以将 = 后的字符串传入 skillParam 指针变量。
      var skillParam = flag.String("skill","","skill to perform")
      
      func main(){
          
          // 解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值
          flag.Parse()
          
          // 定义一个从字符串映射到 func() 的 map，然后填充这个 map . 
          // 初始化 map 的键值对，值为匿名函数
          var skill = map[string]func(){
              "fire" : func() {
                  fmt.Println("chicken fire")
              },
              
              "run" ： func() {
                  fmt.Println("soldier run")
              },
              
              "fly" : func(){
                  fmt.Println("angel fly")
              },
          }
          
          // skillParam 是一个 *string 类型的指针变量，
          // 使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。
          if f,ok := skill[*skillParam]; ok {
              f()
          } else {
              fmt.Println("skill not found")
          }
      }
      
      // 运行
      go run main.go --skill=fly  // angel fly
      ```
  
      
  
  ​      

### 4、defer 函数

*   介绍

    ```go
    2.在defer将语句放入到栈时，也会将相关的值拷贝同时入栈。
    	defer fmt.Println( " ok3 res= " , res)    //ok3   res =  32
    ```

*   多个 defer 调用顺序

    ```go
    当程序执行到defer语句的时候，暂时不执行，将会把 defer 后面（同一行）的语句压入独立的 defer 栈，
    	在 defer 归属的函数即将返回时，
    	将延迟处理的语句按 defer 的逆序进行执行（从 defer 栈，按照 先入后出 的方式出栈执行。）
    	先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。
    	最后 return
    //---------------------------------------------------------------
    
    func main() {
        fmt.Println("defer begin")
        // 将defer放入延迟调用栈
        defer fmt.Println(1)
        defer fmt.Println(2)
        // 最后一个放入, 位于栈顶, 最先调用
        defer fmt.Println(3)
        
        fmt.Println("defer end")
    }
    // 结果如下
    defer begin
    defer end
    3
    2
    1
    ```

*    defer 实时解析

    ```go
    // 当 defer 被声明时，其参数就会被事实解析
    var i int = 1
    defer fmt.Printf("result = %d ", i)
    i++		
    // 执行出来，result = 1，而不是 2
    ```

*   defer 读取返回值

    ```go
    // defer 可以读取有名返回值，也就是可以改变有名返回参数的值
    
    1. go 中 return 不是原子操作，最先是所有的加涅果汁在进入函数时都会初始化为其类型的零值，然后执行 defer 命令，最后才是 return 操作
    
    2. 如果有名返回值，返回值变量其实可以视为是引用赋值，可以被 defer 修改
    3. 如果是匿名返回值，给 ret 的值相当于拷贝赋值，defer 命令是不能直接修改
    ```

    

```go

-----------------------------------------------------------
1.通常创建资源后，执行defer file.Close() defer connext.Close()
2. 在defer后，可以继续使用创建资源.
3. 当函数完毕后，系统会依次从defer栈中，取出语句，关闭资源.
4. 这种机制，非常简洁，程序员不用再为在什么时机关闭资源而烦心

```

* 使用

  ```go
// 创建资源(比如:数据库连接、文件句柄、锁等)，为了在函数执行完(延时机制)，及时的释放资源，
  
  1. 关闭文件资源, 使用延迟释放文件句柄
      file = operation（文件名）
    defer  file.Close()
  
  2. 释放数据库资源
       connect = openDatabse()
     defer connect.close()
    3. 延迟并发解锁
  	    func readValue(key string) int {
            
            valueByKeyGuard.Lock()
            // defer后面的语句不会马上调用, 而是延迟到函数结束时调用
            defer valueByKeyGuard.Unlock()
            return valueByKey[key]
    }
  ```
### 6、哈希函数

  ```go
提供了 MD5、SHA-1 等几种哈希函数,参见哈希函数
  ```





### 7、内置函数

​    Golang设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为Go的内置函数。

```go
文档:https: //studygolang. com/pkgdoc一>builtin
```





## 6.命名

* 遵循标识符命名规则

​		首字母不能是数字，首字母大写该函数可以被本包文件和其它包文件使用，类似public，首字母小写，只能被本包文件使用，其它包文件不能使用，类似privat

* 对返回值命名

  ```go
  func test(n1 int,n2 int)(sum int,sub int){
  sub = n1 - n2
  sum = n1 + n2
  return
  }
  a,b := test(1,2)
  fmt.Printf("a=%v b=%v\n",a,b)
  ```

  

   

## 7.函数变量 

*   函数作为一种数据类型
    *   函数是一种数据类型，可以赋值给一个变量，则改变量就是一个函数，通过该函数可以对函数调用

### 1. 把函数赋值给变量

*    函数也是一种类型，可以和其他类型一样保存在变量中 

```go
// go 中函数也是一种数据类型，可以赋值给一个变量，
// 该变量就是一个函数，通过该函数可以对函数进行调用

// 定义了一个函数变量 f，并将一个函数名为getsum() 的函数赋给函数变量 f，
// 这样调用函数变量 f 时，实际调用的就是 getsum() 函数

func getsum (n1 int ,n2 int)int{
	return  n1 + n2
}
var f func()
f := getsum
res := f( 10 , 20 )

```

### 2. 函数作为形参 - 回调

```go
// 函数是一种数据类型，
// 所以可以做为参数进行传递，然后再其他函数内执行调用
// 作为主调函数的形参的类型，即传递一个指向函数的指针

func myfun (getsum(n1 int,n2 int) , n3 int)
res := myfun(getsum,50,60)

//------------------------------------

 
//提供一个接口，让外部去实现
func test(x, y int, callbackfunc (x, y int) int) int {
  return callback(x, y)
}
 
func add(x, y int) int {
  return x + y
}
 
func main() {
  x, y := 6, 7
  z := test(x, y, add)	
  fmt.Printf("z = %d",z)
}
```



### 3.函数作为返回参数

```go
func complexF2() (re float64, im float64) {
    return complexF1()
}
```



* 函数中的变量是局部的，函数外不生效

* 基本数据类型和数组默认都是值传递的，即进行值拷贝。在函数内修改，不会影响到原来的值。

  函数中和函数外部的变量可以一样，他们不互相影响，但是不建议这样做

* 如果希望函数内的变量能修改函数外的变量(指的是默认以值传递的方式的数据类型)，可以传入变量的地址&，函数内以指针的方式操作变量。从效果上看类似引用。

  ```go
  func test(b1 *int){
      *n1 = *n1 + 10
      fmt.Print("test() n1="*n1) // test() n1=30
  }
  
  func mian(){
      num := 20
      test(&num)
      fmt.Println("main() num=",num) //main() num=30
  }
  //
  ```

  



## 9.自定义函数类型 - 实现接口

1. 自定义函数类型

   ```go
   type  自定义数据类型名字   数据类型 
   
   // 此时 myfun 就是 func(int,int)int类型
   type myfun func(int,int)int
   
   // 函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，
   // 当类型方法被调用时，还需要调用函数本体。 
   func (this *myfunc) call(){
       fmt.Println("6666")
   }
   
   func test(funvar myfun,num int)
   int{}
   
   // 参见   变量 起别名
   ```

## 10 函数执行时间

### 方法

*    函数执行之前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间 
*    计算机 CPU 及一些其他因素的影响，在获取函数运行时间时每次的结果都有些许不同，属于正常现象。 

### 使用

#### time.since

```go
start := time.Now() // 获取当前时间
执行测试函数
Duration := time.Since(start)
fmt.Println("该函数执行完成耗时：", Duration)
```

####  time.Now().Sub() 

```go
start := time.Now() // 获取当前时间
执行测试函数
Duration := time.Now().Sub(start)
fmt.Println("该函数执行完成耗时：", Duration )

/* 
 end := time.Now()
 delta := end.Sub(start)
*/
```

## 牵连其他内容



### 1.常用函数

```
看标准库就行
```

### 2.重载

*   看面向对象

### 3.闭包

*   看面向对象

