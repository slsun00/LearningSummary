[toc]

## 1.类型

* 注意，只有下面这几种类型

  ```go
  1.数值类型： 整数型、浮点型、复数
  2.布尔类型	  
  3.字符串类型
  ```


## 2.声明

* 常量在定义的时候，就必须要初始化 
* 常量设置以后不能修改

    ```go
     定义格式： const name [type] = value
        显示类型     const b string = "abc" 
        隐式类型     const b        = "abc"   //省略type, 编译器可以根据变量的值来推断其类型。 
        批量声明     const（）
                        const (
                            a = 1
                            b
                            c = 2
                            d
                        )
                        fmt.Println(a, b, c, d) // "1 1 2 2"
    // 注意
    1. 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。
    ```

## 3.特点

* 用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此， 由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。
* 常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化 
* 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量 
* 变量的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度： 

    ```go
    // 用在有长度限制的地方，下表什么的
    const IPv4Len = 4
    func parseIPv4(s string) IP {           // parseIPv4 解析一个 IPv4 地址 (d.d.d.d).
        var p [IPv4Len]byte				  // IPv4Len 用来限制 P 的字节长度
        ......
    }
    ```

## 4.iota常量生成器

### 1.声明

* 一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值， 生成每次增加 1 的枚举值  
*  iota 的起始值为 0，一般情况下也是建议枚举从 0 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。 

    ```go
    type Weekday int
    const (
        //第一个声明的变量所在行，iota被设置为0，然后在每个有常量声明的行加1(空行也加1) ： 
        // 注意空行也加1
        // 注意第一个 iota 所在行设置为 0 ，iota 就像类型标志一样
        // 注意是每一行加 1 ，一行内有多个 iota ,那么这一行的数字都是一样的，
        Sunday Weekday = iota    
                                 // 空行
        Monday                      //iota  = 2
        Tuesday                     //iota = 3
        Wednesday                   //iota = 4
        Thursday
        Friday
        Saturday
    )
    ```

### 2.用途

* iota常量生成器初始化，用于生成一组相似规则初始化常量，不用每一行都写一遍初始化表达。一般称为枚举类型
* iota 来做一些强大的枚举常量值生成器， 编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错 

### 3.枚举类型

* 枚举类型的本质是一个 int 类型。

    ```go
    // go语言没有枚举类型
    // 利用const  和  iota连用，可以实现枚举
    // 一般情况下也是建议枚举从 0 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。

    type Weapon int          //将 int 定义为 Weapon 类型，就像别名
    const (
            // 开始生成枚举值, 默认为0 ，将常量 Arrow 的类型标识为 Weapon，这样标识后，const 下方的常量可以使用 Weapon 作为默认类型。
         Arrow Weapon = iota    
         Shuriken
         SniperRifle
         Rifle
         Blower
        )

    fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)   // 输出所有枚举值

    var weapon Weapon = Blower                                  // 使用枚举类型并赋初值
    fmt.Println(weapon)
    ```

*   将枚举值变成字符串，是通过函数封装(你自己设计函数)，利用case,将 int 转化输出为特定的字符串

    ```go
    // 声明芯片类型
    type ChipType int
    const (
        None ChipType = iota
        CPU    // 中央处理器
        GPU    // 图形处理器
    )
    func (c ChipType) String() string {
        switch c {
        case None:
            return "None"
        case CPU:
            return "CPU"
        case GPU:
            return "GPU"
        }
        return "N/A"
    }
    func main() {
        // 输出CPU的值并以整型格式显示
        fmt.Printf("%s %d", CPU, CPU)	// CPU 1
    }
    ```

*   变形

    ```go
    const (
        //  iota 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。
        FlagNone = 1 << iota    // 1
        FlagRed				   // 2
        FlagGreen			   // 4
        FlagBlue			   // 6
    )
    ```

    

## 5.无类型常量

### 1.声明

* 没有明确基本类型的常量，编译器为期提供比基础类型更高精度的算数运算，可认为至少有256bit的运算精度
*  通过延迟明确常量的具体类型，可提供更高的运算精度，直接用于更多的表达式而不需要显式的类型转换。


```go
//math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方,
如果 math.Pi 被确定为特定类型，
	比如float64，那么结果精度可能会不一样，同时对于需要 float32 或 complex128 类型值的地方则需要	一个明确的强制类型转换：
const Pi64 float64 = math.Pi  
var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)

```



### 2.未明确类型的常量模型

```go
就是常量的类型
无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
```



## 6.面值

*    不同的写法可能会对应不同的类型 
    *    字符串面值常量是无类型的字符串类型。 
    *    true 和 false 也是无类型的布尔类型 
    *    0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符 

## 7.访问范围

```go
// go 中没有常量需要字母全部大写的规范
// 仍然通过首字母的大写来控制访问范围
```

## 跳转
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)
* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
