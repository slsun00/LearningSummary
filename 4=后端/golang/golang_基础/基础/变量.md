[toc]

# 前言

* 少做文字粘贴者，多做灵感总结
* 嗯，看的文章很杂很乱，然后基本上都忘记写参考文章了，抱歉！

# go中的类型传递

*   都是值传递
    *   值传递 ： 就是内存传递，将内存中值复制一份传递出去
    *   引用传递 ： 地址传递

# 1.变量

*   variable

* 变量相当于内存中一个数据存储空间的表示

  数据存在存储空间中，则这个存储空间的名字叫变量（可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间（数据在房间里），同样，通过变量名可以访问到变量(值)。）

* 变量表示内存中的一个存储区域，该区域有自己的名称(变量名)和类型(数据类型)

```go
数学概念--->  没有固定值且可改变的数
计算机实现--> 一段或者多段用来储存数据的内存

```

* go语言在编译的时候，会检查每个变量是否使用过，对于没有使用过的变量，会报编译错误

# 2.类型

*   不同的标准分类就不一样，详细看类型分类

## 注意

```go
所有的语法中
	// 只是方便记录，用于文档书写
	Type  表示 go 中的所有数据类型，就是下面基础+复杂数据结构中的类型

```

## 分类

### 基础数据类型

```go
// 数值 
    整数(IntegerType)
        int int8 int16 int32 int64 
        uint uint8 uint16 uint32 uint64
    浮点(floatType)  
        float32 float64
    复数(complexType)
        complex32 complex64
// 文本
    字符型		
		byte
    字符串 ：中英文字        
		string 
// 布尔
    布尔型：真假            
        bool
// 注意
	uint8别称        byte          强调数值是一个原始的数据而不是一个小的整数
    int32别名        rune          Unicode字符  
```

### 复杂数据类型

```go
// 面向对象(代码块在{})
	函数		func
	结构体		struct
	接口		interface
// 并发
	通道/管道(channel)	chan Type

// 其他类型
    指针		*Type
    数组       []Type                
    切片		[size]Type
    集合		map[]Type      
```

## 类型转换

```go
注意
	Go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：
语法
    // 将 类型 A 的值转换为类型 B 的值
	Type_B = Type_B(Type1_A_variable)
	Type_B = Type_B(Type1_A_value)
	// 注释
		Type 和 Type1 ：表示go中的任意两种变量，Type1不同于Type
		Type_B  : 一种类型的变量
		Type1_A_variable：一种类型的变量的字面值


//注意
1.类型转换可以从大范围到小范围，也可以从小范围到大范围
2.被转化的是变量储存的数据（即值）。变量本身的数据类型没有变化
        var i int32 = 100
        var n3 int64 = int64(i) //i 的数据类型没有发生变化，知识它存的值转化为int64,并给了n3
3.小范围转大范围没有问题
  大范围转小范围可能导致数据溢出
        var n1 int32 = 12
        var n3 int8
        var n4 int8
        n3 = int8(n1)+127 // 编译通过，但是结果不是127+12，按照溢出处理
        n4 = int8(n1)+128 //编译不通过？为啥
4.只有相同底层类型的变量之间可以进行相互转换
	int 和 int32
  不同底层类型的变量相互转换时会引发编译错误
	bool 类型转换为 int 类型

5.浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。
```

## 类型别名

```go
// 别名：使用name和string相同。二者仍当做同一种类型运算。
// 别名只在源码中存在，编译完成后，不会有别名类型。

    type name = string // 类型别名（别名）,这是1.9版本之后的写法
    var myName name    // 变量声明使用 （%T,myName) ——>  string

// ---------------------------
1.注意 这里有等号
```



## 自定义数据类型

### 介绍

*   所有的数据类型都可以进行自定义类型

### 自定义类型

*    Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题 
*    Go语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。

```go
// 声明：将name定义为一个新的类型，该类型拥有和string一样的特性
    type name string   // 类型定义（声明）
    var myName name    // 变量声明使用  (%T,myName)  ——>  main.name	
    但是两者是不用的类型，不可用+进行拼接等运算。
注意
	所有数据类型均支持自定义数据类型
	与起别名不一样的地方 就是这里没有等号
    // 1.函数是一种数据类型，所以也可以自定义数据类型使用
    type  myFunType  func( int ,int ) int
   
```

## 方法绑定

*   方法绑定

    ```go
    类型起的别名 、 自定义类型均支持绑定方法
    	// go 中的数据类型均实现了空接口 ，相当于结构体 ， 可以绑定方法
    ```

*   非本地类型不能定义方法

    ```go
    介绍
    	 能够给各种类型起名字,但是不意味着可以在自己的包里为这些类型添加方法，
    	 就是在其他包中定义过了，不能在自己的包里重复定义
    例子
    	package main
        import ("time")
             // 定义time.Duration的别名为MyDuration,起别名
        type MyDuration = time.Duration	
            // 为MyDuration添加一个函数，为这个别名添加一个方法。
        func (m MyDuration) EasySet(a string) {}
        func main() {}
    
        * 编译出现错误
        cannot define new methods on non-local type time.Duration
    
        * 分析
        编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法，
    
        // 非本地类型指的就是 time.Duration 不是在 main 包中定义的，而是在 time 包中定义的，与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。
    
        !!!
        // 就是在其他包中定义过了，不能重复定义
        * 更正
        1.将 type MyDuration = time.Duration 修改为 type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型；
        2.将 MyDuration 的别名定义放在 time 包中。
    ```




## 特点

*   起别名和自定义类型区别

    ```go
    // 形式上在于有没有等号
    type name = string // 类型别名（别名）,这是1.9版本之后的写法
    type name string   // 类型定义（声明）
    ```



# 3.声明/赋值

## 介绍

*   go语言是静态类语言，因此变量必须有明确的类型，编译器就会检查变量的正确性

*   注意

    ```js
    初始化
    	就是一个名词，一个变量声明后，第一次赋值就叫初始化
        
    变量三要素  
    	变量= 变量名 + 值 + 数据类型
    方式 
    	有四种方式
    
    ```

## 方式

```go
1. 先声明后赋值		
	标准形式
	//指定变量类型，声明后不赋值，使用默认值
2. 声明的时赋值
	显式地标明变量的类型，在多变量同时声明时可以用到
3. 简写格式
	// 别名
		简短格式/短变量 
	// 注意
	1. 只能用在函数内部，用于局部变量的声明和初始化，main()函数也算 
	2. 冒号( := )左边的变量必须是没有定义过的变量，若定义过就会编译错误
    3. 定义变量，同时显示初始化，不能提供数据类型
    4. 短变量声明多用于开发中
    5. 多个短变量声明和赋值中，至少要一个新的变量出现在左值中，即便有其他变量可能是重复定义的。编译也不会出错
        conn, err := net.Dial("tcp", "127.0.0.1:8080")
        conn2, err := net.Dial("tcp", "127.0.0.1:8080")
    	上方在一块儿的代码，不会出现err报错
4. 类型推倒
	函数声明的时候，没有写明其类型，
	编译器会自动推倒变量的类型，使用得很少，除非同时声明多个变量	
	go语言为了提高精度，对于浮点型数据会推到位float64类型
// -----------------------
索引类型
	1. 根据省略长度，进行推倒(见数组)
	2. 赋值填充
		1. 键值对填充(根据索引键值对确定)
        2. 值列表
        3. 访问字段名填充
```



## 单个命名

```go
//依赖于数据类型(数据结构)的内部初始化机制，被初始化为默认值

// 先声明后赋值
	var name Type  
	name = 表达式  
// 声明的时候就赋值
	var name  Type = 表达式
// 短变量
	 name  := 表达式 
// 类型推倒
	var name = 表达式 
// 注释
name  : 变量的名字
Type  : 变量的类型, 任意的 go 数据类型
	IntegerType floatType complexType string byte 
//例子
    // 先声明后赋值
        var a int 
        a = 8 
    // 声明的时候就赋值
        var a int = 8
    // 短变量
		a := 8 
    // 类型推倒
        var a = 8
```





## 批量命名

```go
格式
	还是四种格式，只不过变量的个数，由一个变成了多个，对应的值也变为多个
	变量和值的要一一对应
规则
	批量赋值，等到的左值和右值从左到右的顺序赋值
相同类型
	// a=1 b=2 c=3
	var a, b, c, ... int =  1, 2, 3, ...

不同类型
	// a=1 b=true
    var (a int, ..., b bool) = 1,  ..., true

组合式写法
	var (a = 300
         b = 100 )
   
1.用处:在错误处理和函数返回值中大量使用组变量简短格式
```

## 默认值

*   介绍

    ```js
    go 中，数据类型都有一个默认值，当声明时没有赋值，就会使用默认值
    默认值又叫零值
    // 初始默认值就是  ：初始但未引用的值
    注意
    	空接口可以代表任意类型，因为他就收任意类
    ```

*   不同类型数据结构的初始值

    ```go
    //基础类型
    数值
    	整形			均为 0
    	浮点			均为 0  // 有的说是0.0
    	复数			0+0i
    文本
    	字符串		    ""  // 空字符串
    布尔
    	布尔			false
    
    面向对象
    	函数			nil
    	结构体		   默认值根据随结构体内部类型变化而变化
    	接口			nil
    并发
        通道			nil
    
    高级类型
    	数组			默认值根据数组类型变化而变化，如 [3]int 为 [0,0,0]	
    	切片			nil  // 有争议，我运行出来是 空的切片
    	字典			nil
    	指针			nil	 // 结构体指针也是有点儿问题，是内部每个来说的
    
    ```

*   注意

    ```go
    // 结构体  
    	// 默认值根据随结构体内部类型变化而变化
    	// 结构体指针跟这个是一样的	
            type Person struct {
                Name string
                Age  int
            }  		//默认值为{ 0} 即 Name为"" Age为0
    	    var a *Person = &Person{}   a 就是上面的初始默认值
    // 切片
        // 初始化但是未使用
        var strList [3]string
        fmt.Println(strList)  // [   ]
    ```

    





*    

```go

```





# 4.匿名变量

* 编码过程中遇到的没有名字的变量、类型和方法。

```go
// 匿名变量使用：只需要在变量声明的地方使用下划线“_”
	a，b := 100,200
	a，_ := 100,200

// 空白标识符
它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算
```

* 优点：不占用内存空间，不分配内存，匿名变量和匿名变量之间也不会因为多次声明而无法使用

# 5.变量作用域

## 1.作用域

```go
// 变量在同一个作用域(在一个函数或者在代码块)内不能重名
一个变量（常量、类型和函数）在程序中有一定的作用范围
var i int = 20 
i := 10 
//注意上面是完整的，声明赋值
```

## 2.分类

### 	1.局部变量

```go
// 函数内部的变量
	函数内声明的变量。作用域在函数体内，局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。

// 形式参数
1.定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。
2.形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
3.在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。
4.形式参数会作为函数的局部变量来使用。

```

### 	2.全局变量

```go
1.函数外声明的变量。
2.只需要在源文件中定义,就可以在所有源文件中使用。
3.不包含这个全局变量的源文件需要用import引入全局变量说正在文件夹之后才能使用这个全局变量
4.注意：1.全局变量的声明必须用var关键字开头
 	   2.在外部包使用全局的全局变量的首字母必须大写
 	   3.全局变量和局部变量的名称可以相同，但是函数体内的局部变量会优先考虑
	   4.在go函数外部定义变量就是全局变量
```

### 3.同一区域内变量

* 该区域年内的数据值可以在同一类型内不断变化（重点）

```go
func main(){
    var i int
    i = 30  //可以
    i = 10  //可以
    i = 50  //以上连写可以
    i = 1.2  //不可以，因为i的数据 类型只能是int
}
```



# 6.变量的生命周转期 

* 变量的作用周期和作用域有关系
*  Go语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们任然需要了解变量的声明周期 
    *    如果将局部变量赋值给全局变量，将会阻止 GC 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。 

1. 全局变量：生命周期和整个程序的运行周期是一致的

2. 局部变量：声明周期是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止

    *   全局变量和局部变量同名的情况下，局部变量生效。 

    *   形式参数和函数返回值：属于局部变量，函数被调用时创建，函数调用结束后被销毁

3.  堆（heap）：

    *   用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。
    *   当进程调用 malloc 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。
    *   当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）； 

4.  栈(stack)：

    *   又称堆栈， 
    *   用来存放程序暂时创建的局部变量，也就是我们函数的大括号`{ }`中定义的局部变量。 

5.  程序的编译阶段，

    *   编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。  

6. 逃逸分析

    *    实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。
    *    之前的golang逃逸机制是会拷贝，现在是直接丢过去了 

```go
var global *int
func f() {
    var x int
    x = 1
    global = &x
}
//函数 f 里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的。用Go语言的术语说，这个局部变量 x 从函数 f 中逃逸了。
func g() {
    y := new(int)
    *y = 1
}
//函数 g 返回时，变量 *y 不再被使用，也就是说可以马上被回收的。因此，*y 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 *y 的存储空间，也可以选择在堆上分配，然后由Go语言的 GC（垃圾回收机制）回收这个变量的内存空间。

```







# 11 .动静类型

*   参见接口的类型
*   动态类型
*   静态类型



# 跳转

* [golang知识库总结](https://www.cnblogs.com/shulei/p/13426361.html)
* [golang 数据类型](https://www.cnblogs.com/shulei/p/13425813.html)