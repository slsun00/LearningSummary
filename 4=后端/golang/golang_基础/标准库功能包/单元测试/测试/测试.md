*    一个项目保证工程质量最有效并且投资回报率最高的方法之一 
*    单元测试应该是稳定的并且不依赖任何的外部项目，它只是对项目中函数和方法的测试 
*    每一个单元测试都表示一个可能发生的情况，**单元测试就是业务逻辑**。 
*    静态语言的 Golang，想要写出覆盖率足够（最少覆盖核心逻辑）的单元测试本身就比较困难 ，  因为我们不能像动态语言一样**随意**修改函数和方法的行为 
*    写出抽象良好的接口并通过接口隔离依赖能够帮助我们有效地提升项目的质量和可测试性 
*    如果项目中没有单元测试，我们很难在不改变已有业务逻辑的情况对项目进行重构，一些业务的边界情况很可能会在重构的过程中丢失 
*    我们能够在重构中相信的东西其实只有当前的代码逻辑（很可能是错误的）以及单元测试（很可能是没有的） 
*    单元测试的缺失不仅会意味着较低的工程质量，而且意味着重构的难以进行，一个有单元测试的项目尚且不能够保证重构前后的逻辑完全相同，一个没有单元测试的项目很可能本身的项目质量就堪忧，更不用说**如何在不丢失业务逻辑的情况下进行重构了**。 

## 可测试

*    写代码并不是一件多困难的事情，不过想要在项目中写出可以测试的代码并不容易 

*    对于测试的理解就是控制变量，在我们隔离了待测试方法中一些依赖之后，当函数的入参确定时，就应该得到期望的返回值。 

*   重要的地方

    *    如何控制待测试方法中依赖的模块 

    *    控制依赖也就是对目标函数的依赖进行 `Mock` 消灭不确定性

    *   为了减少每一个单元测试的复杂度 ，需要

        ```go
        1.单元测试的执行不应该依赖于任何的外部模块，无论是调用外部的 HTTP 请求还是数据库中的数据
        2.应该想尽办法模拟可能出现的情况
        //因为单元测试不是集成测试的，它的运行不应该依赖除项目代码外的其他任何系统。
        ```



## 接口

*    完全不使用接口，是写不出易于测试的代码的 
*    只有我们使用接口才能脱离依赖具体实现的窘境，接口的使用能够为我们带来更清晰的抽象，帮助我们思考如何对代码进行设计，也能让我们更方便地对依赖进行 `Mock`。 
*    如果你不知道应不应该使用接口对外提供服务，这时就应该无脑地使用上述模式对外暴露方法了， ？？？？？



## 函数简单

*    不止是指功能上的简单、单一，还意味着函数容易理解并且命名能够自解释。 
*    Ruby 社区中的 Rubocop 对于函数的长度和理解复杂度都有着非常严格的限制，在默认情况下函数的行数不能超过 `10` 行，理解复杂度也不能超过 `7` 

## 组织方式

*    Golang 中的单元测试文件和代码都是与源代码放在同一个目录下按照 `package` 进行组织的，`server.go` 文件对应的测试代码应该放在同一目录下的 `server_test.go` 文件中。 



### test

*    最常见以及默认组织方式就是写在以 `_test.go` 结尾的文件中，所有的测试方法也都是以 `Test` 开头并且只接受一个 `testing.T` 类型的参数： 

     *    将一个函数相关的测试分散到多个 `Test` 方法 

          ```go
          // 给函数名为 Add 的方法写单元测试，那么对应的测试方法一般会被写成 TestAdd，为了同时测试多个分支的内容，我们可以通过以下的方式组织 Add 函数相关的测试：
          
          // 通常会在测试代码比较简单时适用此种方法
          
          func TestAdd(t *testing.T) {
              assert.Equal(t, 5, Add(2, 3))
          }
          
          func TestAddWithNegativeNumber(t *testing.T) {
              assert.Equal(t, -2, Add(-1, -1))
          }
          ```

          

     *    我们可以使用 `for` 循环来减少重复的测试代码，这在逻辑比较复杂的测试中会非常好用，能够减少大量的重复代码，不过也需要我们小心地进行设计： 

          ```go
          // 在依赖较多、函数功能较为复杂时使用
          
          func TestAdd(t *testing.T) {
              tests := []struct{
                  name     string
                  first    int64
                  second   int64
                  expected int64
              } {
                  {
                      name:     "HappyPath":
                      first:    2,
                      second:   3,
                      expected: 5,
                  },
                  {
                      name:     "NegativeNumber":
                      first:    -1,
                      second:   -1,
                      expected: -2,
                  },
              }
              for _, test := range tests {
                  t.Run(test.name, func(t *testing.T) {
                      assert.Equal(t, test.expected, Add(test.first, test.second))
                  }
              }
          }
          ```

### Suite

*    按照簇进行组织 

*    Go 语言默认的测试方式进行简单的封装，我们可以使用 [stretchr/testify](https://link.zhihu.com/?target=https%3A//github.com/stretchr/testify) 中的 `suite` 包对测试进行组织 

*    我们可以使用 `suite` 包，以结构体的方式对测试簇进行组织，

     *   `suite` 提供的`SetupTest`/`SetupSuite` 和 `TearDownTest`/`TearDownSuite` 是执行测试前后以及执行测试簇前后的钩子方法，我们能在其中完成一些共享资源的初始化，减少测试中的初始化代码。 

     ```go
     import (
         "testing"
         "github.com/stretchr/testify/suite"
     )
     
     type ExampleTestSuite struct {
         suite.Suite
         VariableThatShouldStartAtFive int
     }
     
     func (suite *ExampleTestSuite) SetupTest() {
         suite.VariableThatShouldStartAtFive = 5
     }
     
     func (suite *ExampleTestSuite) TestExample() {
         suite.Equal(suite.VariableThatShouldStartAtFive, 5)
     }
     
     func TestExampleTestSuite(t *testing.T) {
         suite.Run(t, new(ExampleTestSuite))
     }
     ```

### BDD

*    [ginkgo](https://link.zhihu.com/?target=https%3A//github.com/onsi/ginkgo) 就是 Golang 社区最常见的 BDD 框架

*    行为驱动开发（BDD）和测试驱动开发（TDD）都是一种保证工程质量的方法论 

*    先通过写单元测试或者行为测试约定方法的 Spec，再实现方法让我们的测试通过， 

*    不一定要使用 BDD/TDD 的思想对项目进行开发，但是却可以**使用 BDD 的风格方式**组织非常易读的测试代码： 

*   内容

    ```go
    一般都包含 Describe、Context 以及 It 等代码块，
    	Describe 的作用是描述代码的独立行为、
    	Context 是在一个独立行为中的多个不同上下文，
    	It 用于描述期望的行为，这些代码块最终都构成了类似『描述......，当......时，它应该......』的句式帮助我们快速地理解测试代码。
    //------------------------------------------------------------------------------------
    var _ = Describe("Book", func() {
        var (
            book Book
            err error
        )
    
        BeforeEach(func() {
            book, err = NewBookFromJSON(`{
                "title":"Les Miserables",
                "author":"Victor Hugo",
                "pages":1488
            }`)
        })
        
        Describe("loading from JSON", func() {
            Context("when the JSON fails to parse", func() {
                BeforeEach(func() {
                    book, err = NewBookFromJSON(`{
                        "title":"Les Miserables",
                        "author":"Victor Hugo",
                        "pages":1488oops
                    }`)
                })
    
                It("should return the zero-value for the book", func() {
                    Expect(book).To(BeZero())
                })
    
                It("should error", func() {
                    Expect(err).To(HaveOccurred())
                })
            })
        })
    }) 
    ```

## Mock 方法

*    对所有的第三方的不稳定依赖进行 Mock，也就是模拟这些第三方服务的接口 
*    为了简化一次单元测试的上下文，在同一个项目中我们也会对其他模块进行 Mock，模拟这些依赖模块的返回值 
*    Go 语言作为一个静态语言提供了比较少的运行时特性，这也让我们在 Go 语言中 Mock 依赖变得非常困难 

### 作用

*    保证待测试方法依赖的上下文固定，在这时无论我们对当前方法运行多少次单元测试，如果业务逻辑不改变，它都应该返回完全相同的结果

### 常见的依赖 

1.  接口

    *    能够对接口进行 Mock 的 [golang/mock](https://link.zhihu.com/?target=https%3A//github.com/golang/mock) 框架，它能够根据接口生成 Mock 实现 

    ```go
       1. 在 test/mocks 目录中放置所有的 Mock 实现，子目录与接口所在文件的二级目录相同，在这里源文件的位置在 pkg/blog/blog.go，它的二级目录就是 blog/，所以对应的 Mock 实现会被生成到 test/mocks/blog/ 目录中；
        2.指定 package 为 mxxx，默认的 mock_xxx 看起来非常冗余，上述 blog 包对应的 Mock 包也就是 mblog；
        3.mockgen 命令放置到 Makefile 中的 mock 下统一管理，减少祖传命令的出现；
        ```bash mock： rm -rf test/mocks
        mkdir -p test/mocks/blog mockgen -package=mblog -source=pkg/blog/blog.go > test/mocks/blog/blog.go
    ```

2.  数据库

    *    在遇到数据库的依赖时，我们一般都会使用[sqlmock](https://link.zhihu.com/?target=https%3A//github.com/DATA-DOG/go-sqlmock) 来模拟数据库的连接 

    *    先阅读相关的 [文档](https://link.zhihu.com/?target=https%3A//github.com/DATA-DOG/go-sqlmock) 再尝试使用。 

         ```go
         ExpectQuery 和 ExpectExec，前者主要用于模拟 SQL 的查询语句，后者用于模拟 SQL 的增删，
         ```

         

3.  HTTP 请求

    *    [httpmock](https://link.zhihu.com/?target=https%3A//github.com/jarcoal/httpmock) 就是一个用于 Mock 所有 HTTP 依赖的包，它使用模式匹配的方式匹配 HTTP 请求的 URL，在匹配到特定的请求时就会返回预先设置好的响应。 
    *    模拟依赖的 HTTP 请求。 

4.  Redis、缓存以及其他依赖

### 猴子补丁

*    [bouk/monkey](https://link.zhihu.com/?target=https%3A//github.com/bouk/monkey) 能够通过替换函数指针的方式修改**任意函数**的实现 
*    用于 内联编译 
*    比较 hack 的方法 Mock 依赖 
*    这种方法的使用其实有一些限制，由于它是在运行时替换了函数的指针，所以如果遇到一些简单的函数，例如 `rand.Int63n` 和 `time.Now`，编译器可能会直接将这种函数内联到调用实际发生的代码处并不会调用原有的方法，所以使用这种方式往往需要我们在测试时额外指定 `-gcflags=-l` 禁止编译器的内联优化。 
*    **不要在单元测试之外的地方使用猴子补丁**，我们应该只在必要的时候使用这种方法 
     *    如依赖的第三方库没有提供 `interface` 或者修改 `time.Now` 以及 `rand.Int63n` 等内置函数的返回值用于测试时。 
*    通过猴子补丁这种方式我们能够在运行时 Mock Go 语言中的一切函数，这也为我们提供了单元测试 Mock 依赖的最终解决方案。 

## 断言

*    辅助单元测试的 [assert](https://link.zhihu.com/?target=https%3A//github.com/stretchr/testify) 包，它提供了非常多的断言方法帮助我们快速对期望的返回值进行测试，减少我们的工作量： 

##  核心 

*    隔离依赖并验证输入和输出的正确性 

## 总结

*    每一个单元测试都表示一个业务逻辑，每次提交时执行单元测试就能够帮助我们确定新的代码大概率上不会影响已有的业务逻辑，能够明显地降低重构的风险以及线上事故的数量 

*   在这篇文章中我们从三个方面分别介绍了如何写优雅的 Go 语言代码，作者尽可能地给出了最容易操作和最有效的方法：

    -   代码规范：使用辅助工具帮助我们在每次提交 PR 时自动化地对代码进行检查，减少工程师人工审查的工作量；

    -   最佳实践

    -   -   目录结构：遵循 Go 语言社区中被广泛达成共识的 [目录结构](https://link.zhihu.com/?target=https%3A//github.com/golang-standards/project-layout)，减少项目的沟通成本；
        -   模块拆分：按照职责对不同的模块进行拆分，Go 语言的项目中也不应该出现`model`、`controller` 这种违反语言顶层设计思路的包名；
        -   显示与隐式：尽可能地消灭项目中的 `init` 函数，保证显式地进行方法的调用以及错误的处理；
        -   面向接口：面向接口是 Go 语言鼓励的开发方式，也能够为我们写单元测试提供方便，我们应该遵循固定的模式对外提供功能；

    1.  使用大写的 `Service` 对外暴露方法；
    2.  使用小写的 `service` 实现接口中定义的方法；
    3.  通过 `func NewService(...) (Service, error)` 函数初始化 `Service` 接口；

    -   单元测试：保证项目工程质量的最有效办法；

    -   -   可测试：意味着面向接口编程以及减少单个函数中包含的逻辑，使用『小方法』；

        -   组织方式：使用 Go 语言默认的 Test 框架、开源的 `suite` 或者 BDD 的风格对单元测试进行合理组织；

        -   Mock 方法：四种不同的单元测试 Mock 方法；

        -   -   [gomock](https://link.zhihu.com/?target=https%3A//github.com/golang/mock)：最标准的也是最被鼓励的方式；
            -   [sqlmock](https://link.zhihu.com/?target=https%3A//github.com/DATA-DOG/go-sqlmock)：处理依赖的数据库；
            -   [httpmock](https://link.zhihu.com/?target=https%3A//github.com/jarcoal/httpmock)：处理依赖的 HTTP 请求；
            -   [monkey](https://link.zhihu.com/?target=https%3A//github.com/bouk/monkey)：万能的方法，但是只在万不得已时使用，类似的代码写起来非常冗长而且不直观；

    -   -   断言：使用社区的 [testify](https://link.zhihu.com/?target=https%3A//github.com/stretchr/testify) 快速验证方法的返回值；

## 参考

*   https://zhuanlan.zhihu.com/p/69445822









































































































































































































































































































































































