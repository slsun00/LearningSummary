



## 修饰符

```go
I	
	ignore - 大小写敏感(默认关闭)
	搜索时不区分大小写: A 和 a 没有区别。
U
	贪婪的：交换x*和x*?、x+和x+?……的含义（默认关闭）
m	
	multi line - 多行匹配	
	^和$在匹配文本开始和结尾之外，还可以匹配行首和行尾（默认开启）
	使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。
s	
	让.可以匹配\n（默认关闭） 
	是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。0
```

## 字符族

### 普通

```js
x              单个字符
A-Z            字符范围（方括号内部才可以用）
\d             Perl字符族
[:foo:]        ASCII字符族
\pF            单字符名的Unicode字符族
\p{Foo}        完整字符名的Unicode字符族
```

### 预定义 字符族

```js
[\d]           == \d
[^\d]          == \D
[\D]           == \D
[^\D]          == \d
[[:name:]]     == [:name:]
[^[:name:]]    == [:^name:]
[\p{Name}]     == \p{Name}
[^\p{Name}]    == \P{Name}
```

### Perl 字符族

```js
        \d             == [0-9]
        \D             == [^0-9]
        \s             == [\t\n\f\r ]
        \S             == [^\t\n\f\r ]
        \w             == [0-9A-Za-z_]
        \W             == [^0-9A-Za-z_]
```

### ASCII 字符族

```js
        [:alnum:]      == [0-9A-Za-z]
        [:alpha:]      == [A-Za-z]
        [:ascii:]      == [\x00-\x7F]
        [:blank:]      == [\t ]
        [:cntrl:]      == [\x00-\x1F\x7F]
        [:digit:]      == [0-9]
        [:graph:]      == [!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~]
        [:lower:]      == [a-z]
        [:print:]      == [ -~] == [ [:graph:]]
        [:punct:]      == [!-/:-@[-`{-~]
        [:space:]      == [\t\n\v\f\r ]
        [:upper:]      == [A-Z]
        [:word:]       == [0-9A-Za-z_]
        [:xdigit:]     == [0-9A-Fa-f]
```



## 元字符

### 总结

```js
[]  
	匹配括号中任意一个字符
-
    在 [ ] 括号内表示字符串的范围
^
    匹配除方括号中的字符以外的任意一个字符
[[:xxx:]]
	grep 工具预定义的一些命名字符
\   
	元字符  PERL 风格
    将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
```



### 单个字符与数字

```js
// 字符族（预定义字符族之外，方括号内部）的语法

.	
	匹配除换行符之外的任意字符
     任意字符（标志s==true时还包括换行符）
x 
	单个字符
a-z
	字符范围(方括号才可使用)
x|y	
	匹配 x 或 y ,优先匹配 x
    'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"

[xyz]		
	// 匹配方括号中含有的包含的字符,字符族
	[abc0-9]' 可以匹配 "plain3" 中的 'a'、'3'
[^xyz]    
	// 匹配方括号中没有包含的字符, 反向字符族
	 [^abc] 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。

[foo|bar|baz]  // 匹配任何指定的备选方案

	匹配在方括号中的任意字符
[^a-z0-9]	匹配不在方括号中的任意字符
\d		
	// Perl预定义字符族
	数字(digit) ， 等价于 [0-9]
\D	
	// 反向Perl预定义字符族
	非数字， 等价于 [^0-9]
\w			
	匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'
\W			
	匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'
```



### 空白字符、转义

```js
[\b]		  回退(并删除)一个字符（Backspace键）
\f             换页符(换纸符，进纸符)（\014）
\n             换行符（\012
\r             回车符（\015）
\t             水平制表符（\011）
\v             垂直制表符（\013）
\b			  空格
\s			  空白字符,包括：空格、制表符、换行符等等，等价于 [ \f\n\r\t\v]。
\S			  非空白字符。等价于 [^ \f\n\r\t\v]



\a             响铃符（\007）
\123           八进制表示的字符码（最多三个数字）
\x7F           十六进制表示的字符码（必须两个数字）
\x{10FFFF}     十六进制表示的字符码
\*             字面值'*'
\Q...\E        反斜线后面的字符的字面值
```

### 定位符

```go
^   
	匹配输入字符串的开始位置，标志m为真时，还匹配行首
	如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
$   
	行尾匹配，匹配输入字符串的结束位置，标志m为真时，还匹配行尾
	如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置

p$   匹配任何结尾是 p 的字符串

分行匹配模式（？m）：许多表达式都不支持？m
?m 是个前缀，但是其对 \A \Z无影响


\A             匹配文本(字符串)开始
\z             匹配文本(字符串)结尾



\b
	单词边界，也就是指单词和空格间的位置
	er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'
		
			（单词的开头或结尾，限定一个单词要两个一起用）
			（一边字符属于\w，另一边为文首、文尾、行首、行尾或属于\W）
\B
	匹配非单词边界。
	'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'
```



### 重复

* 重复使用的的元字符不要放进 [ ] 中，否则就变成了普通字符
* x 要是字符集合, 只匹配其前面最近的字符或者字符组

```go
贪婪匹配
	默认的贪婪模式则尽可能多的匹配所搜索的字符串
*
	// 等价于{0,}
	x* ---> 匹配前面的子表达式零次或多次, ，越多越好（优先重复匹配x）
	zo* 能匹配 "z" 以及 "zoo"。* 。
+
	// 价于 {1,}。
	x+ --->  匹配前面的子表达式一次或多次。
	x+  重复>=1次匹配x，越多越好（优先重复匹配x,一个字符或者字符集）
?
	//  等价于 {0,1} , 贪婪方式，优先匹配 出现 1 次的（最多次数）
	 x? ---> 匹配前面的子表达式0 个或1个，优先1次
	e(ye)? 匹配 e 、eye , 优先匹配 eye
	        
x{n,m}         n到m次匹配x，越多越好（优先重复匹配x）贪婪方式
x{n,}          x片段出现m到无限多次，（优先重复匹配x）
x{n}           精确重复n次匹配x

// ---------------------------------------------------------------
非贪婪匹配 ：
	非贪婪模式尽可能少的匹配所搜索的字符串
	限制符 (*, +, ?, {n}, {n,}, {n,m})后面加了个 ？


x*?            重复>=0次匹配x，越少越好（优先跳出重复）
x+?            重复>=1次匹配x，越少越好（优先跳出重复）
x??            0或1次匹配x，优先0次
x{n,m}?        n到m次匹配x，越少越好（优先跳出重复）
x{n,}?         重复>=n次匹配x，越少越好（优先跳出重复）
x{n}?          重复n次匹配x
```



### 分组

*   子表达式

```go
子表达式可以嵌套，理论上没有限制，但是实际上适可而止（3层以内）

(re)           
	// 编号的捕获分组
	括号内的是一组，一个整体，
(?P<name>re)   
	命名并编号的捕获分组
(?:x)		  
	匹配 x 但是不记录匹配结果， 是一个非获取匹配，不进行存储供以后使用
(?flags)       
	设置当前所在分组的标志，不捕获也不匹配
(?flags:re)    
	设置re段的标志，不捕获的分组
```







## 优先级

* 介绍

    ```js
    正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
    相同优先级的从左到右进行运算，不同优先级的运算先高后低
    ```

    | \                           | 转义符                                                       |
    | --------------------------- | ------------------------------------------------------------ |
    | (), (?:), (?=), []          | 圆括号和方括号                                               |
    | *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |
    | ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |
    | \|                          | 替换，"或"操作  字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |

# 常用匹配

```js
[a-z]
	匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[0-9] 匹配字符串中含有的数字
```

