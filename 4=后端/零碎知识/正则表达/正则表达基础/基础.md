



## 修饰符

```go
i	
	ignore - 不区分大小写	将匹配设置为不区分大小写
	搜索时不区分大小写: A 和 a 没有区别。
g	
	global - 全局匹配,查找所有的匹配项。
m	
	multi line - 多行匹配	
	使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。
s	
	特殊字符圆点 . 中包含换行符 \n	默认情况下的圆点 . 
	是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。0
```

## 元字符

### 总结

```js
[]  用来查找一系列的字符
\   
	元字符  PERL 风格
    将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
```



### 单个字符与数字

```js
.	匹配除换行符之外的任意字符
x|y	
	匹配 x 或 y
    'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"

[xyz]		
	// 匹配方括号中含有的包含的字符
	[abc]' 可以匹配 "plain" 中的 'a'
[^xyz]    
	// 匹配方括号中没有包含的字符
	 [^abc] 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。

[foo|bar|baz]  // 匹配任何指定的备选方案

	匹配在方括号中的任意字符
[^a-z0-9]	匹配不在方括号中的任意字符
\d			数字(digit) ， 等价于 [0-9]
\D			非数字， 等价于 [^0-9]
\w			匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'
\W			匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'
```



### 空白字符、转义

```js
[\b]		  回退(并删除)一个字符（Backspace键）
\f             匹配一个换页符(换纸符，进纸符)。等价于 \x0c 和 \cL（\014）
\n             匹配一个换行符。 等价于 \x0a 和 \cJ。（\012
\r             匹配一个回车符。 等价于 \x0d 和 \cM（\015）
\t             水平制表符， 等价于 \x09 和 \cI（\011）
\v             垂直制表符， 等价于 \x0b 和 \cK（\013）
\b			  空格
\s			  空白字符,包括：空格、制表符、换行符等等，等价于 [ \f\n\r\t\v]。
\S			  非空白字符。等价于 [^ \f\n\r\t\v]



\a             响铃符（\007）
\123           八进制表示的字符码（最多三个数字）
\x7F           十六进制表示的字符码（必须两个数字）
\x{10FFFF}     十六进制表示的字符码
\*             字面值'*'
\Q...\E        反斜线后面的字符的字面值
```

### 定位符

```go
^   
	匹配输入字符串的开始位置。
	如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
$   
	行尾匹配，匹配输入字符串的结束位置。
	如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置

p$   匹配任何结尾是 p 的字符串

分行匹配模式（？m）：许多表达式都不支持？m
?m 是个前缀，但是其对 \A \Z无影响


\A             匹配文本(字符串)开始
\z             匹配文本(字符串)结尾
\Z 			  字符串结束，行尾 ，如果存在换行，只匹配到换行前的结束字符串
\G			  最后匹配完成的位置

\b
	单词边界，也就是指单词和空格间的位置
	er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'
		
			（单词的开头或结尾，限定一个单词要两个一起用）
			（一边字符属于\w，另一边为文首、文尾、行首、行尾或属于\W）
\B
	匹配非单词边界。
	'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'
```



### 重复

* 重复使用的的元字符不要放进 [ ] 中，否则就变成了普通字符
* x 要是字符集合, 只匹配其前面最近的字符或者字符组

```go
贪婪匹配
	默认的贪婪模式则尽可能多的匹配所搜索的字符串
*
	// 等价于{0,}
	x* ---> 匹配前面的子表达式零次或多次, ，越多越好（优先重复匹配x）
	zo* 能匹配 "z" 以及 "zoo"。* 。
+
	// 价于 {1,}。
	x+ --->  匹配前面的子表达式一次或多次。
	x+  重复>=1次匹配x，越多越好（优先重复匹配x,一个字符或者字符集）
?
	//  等价于 {0,1} , 贪婪方式，优先匹配 出现 1 次的（最多次数）
	 x? ---> 匹配前面的子表达式0 个或1个，优先1次
	e(ye)? 匹配 e 、eye , 优先匹配 eye
	        
x{n,m}         n到m次匹配x，越多越好（优先重复匹配x）贪婪方式
x{n,}          x片段出现m到无限多次，（优先重复匹配x）
x{n}           精确重复n次匹配x

// ---------------------------------------------------------------
非贪婪匹配 ：
	非贪婪模式尽可能少的匹配所搜索的字符串
	限制符 (*, +, ?, {n}, {n,}, {n,m})后面加了个 ？


x*?            重复>=0次匹配x，越少越好（优先跳出重复）
x+?            重复>=1次匹配x，越少越好（优先跳出重复）
x??            0或1次匹配x，优先0次
x{n,m}?        n到m次匹配x，越少越好（优先跳出重复）
x{n,}?         重复>=n次匹配x，越少越好（优先跳出重复）
x{n}?          重复n次匹配x
```

### 引用

```go
（...）\n     代表模式里第 n 个子表达式,属于相对位置引用
			给子表达式起一个唯一的名字，属于命名捕获（named capture）
------------------------------------------------------------------------
（...）$n 	跨模式使用第一个模式里的第 n 个子表达式



* 模式的后半部分引用前半部分中定义的子表达式
* 只能引用子表达式，还可以被引用多次
* 可以跨模式使用，在第一个模式里被匹配到的子表达式可以用在第二个模式里
* 第0个匹配（\0）用来代表整个正则表达式


* 对文本进行重新排版的时候，可以把文本分解成多个子表达式，可以更精准控制排版效果

​```python
# 替换模式需要两个正则表达式
搜索模式
替换模式
​```

 不同语言的形式不一样
```



### 分组

*   子表达式

```go
子表达式可以嵌套，理论上没有限制，但是实际上适可而止（3层以内）

(re)           括号内的是一组，一个整体，
(?:x)		  匹配 x 但是不记录匹配结果， 是一个非获取匹配，不进行存储供以后使用

x(?=y)		  
	// 正向肯定预查（look ahead positive assert）
	当 x 后接 y 时匹配 x
x(?!y)		  
	// 正向否定预查(negative assert)
	当 x 后不接 y 时匹配 y


( ?=  x)			
	// 正向肯定预查（look ahead positive assert）
	前查：查找 x 并输出x之前的内容。模块长度可变
( ?<=  x)			
	// 反向(look behind)肯定预查
	后查：查找 x 并输出x之后的内容。模块长度固定

(?!x)				
	// 正向否定预查(negative assert)
	负向前查询: 查找不与给定模块相匹配的文本
(?<! x)				
	// 反向否定预查
	负向后查询: 查找不与给定模块相匹配的文本
```



## 特殊

```js
\cx
	// x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
	匹配由 x 指明的控制字符。
    例如， \cM 匹配一个 Control-M 或回车符。
\xn
	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。
    例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。

    
\num 	

匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
\n 	

标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm 	

标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml 	

如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un 	

匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
```





## 优先级

* 介绍

    ```js
    正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
    相同优先级的从左到右进行运算，不同优先级的运算先高后低
    ```

    | \                           | 转义符                                                       |
    | --------------------------- | ------------------------------------------------------------ |
    | (), (?:), (?=), []          | 圆括号和方括号                                               |
    | *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |
    | ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |
    | \|                          | 替换，"或"操作  字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |



## 待整理

```go
1
* 分行模式匹配
    * 把行分隔符当成一个字符串分割符来对待


* 本质就是子表达式
* 只需要找到自己想要的，不需要检索出来没必要的信息，就不包括在结果中
* 向前查找、向后查找是指与被查文本的相对位置而言的，左 为 前
* 两种查找匹配自身，结果的字节长度永远是0，也称为零宽度（zero-width）匹配操作

1.向前查找

* 指定了一个必须匹配但不在结果中返回的模式

* 向前查找模式的长度是可变的，可以包含 + . 之类的

* 一些文本的术语

```

    消费 consume : 匹配和返回文本
    不消费       ：被匹配的文本不包含在最终的返回结果里
    ```

2.向后查找

* 只能是固定长度  ——  这是一条几乎所有的正则表达式实现都遵守的规则

3.前后查找结合

4.对前后查询取非


正向前、正向后查找： 通过指定匹配结果的前后必须是那些文本
正 ：寻找匹配的事实

负向前、负向后查找：查找不与给定模块相匹配的文本



# 常用匹配

```js
[a-z]
	匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[0-9] 匹配字符串中含有的数字
```

