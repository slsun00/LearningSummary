## 总结

```js
|  或的意思
[]  用来查找一系列的字符，里面的内容是 或 的关系
\   元字符  PERL 风格
```



## 单个字符与数字

```js
.	匹配除换行符之外的任意字符

[a-z0-9]	匹配在方括号中的任意字符
[^a-z0-9]	匹配不在方括号中的任意字符
\d			数字
\D			非数字
\w			字母
\W			非字母
```



## 空白字符、转义

```js
[\b]		  回退(并删除)一个字符（Backspace键）
\f             换纸符，换页符，进纸符（\014）
\n             换行符（\012
\r             回车符（\015）
\t             水平制表符（\011）
\v             垂直制表符（\013）
\b			  空格
\s			  空白字符、空格、制表符、换行符
\S			  非空白字符
\.  		  单个点
\\ 			  \



\a             响铃符（\007）
\123           八进制表示的字符码（最多三个数字）
\x7F           十六进制表示的字符码（必须两个数字）
\x{10FFFF}     十六进制表示的字符码
\*             字面值'*'
\Q...\E        反斜线后面的字符的字面值
```

## 定位符

```go
^             行首匹配 ，匹配文本开始，标志m为真时（换行符后面开始的位置）
$             行位匹配， 匹配文本结尾，有标志?m（换行符后面结束的位置）

^P   匹配以 p 结尾 的字符串
p$   匹配任何结尾是 p 的字符串

分行匹配模式（？m）：许多表达式都不支持？m
?m 是个前缀，但是其对 \A \Z无影响


\A             匹配文本(字符串)开始
\z             匹配文本(字符串)结尾
\Z 			  字符串结束，行尾 ，如果存在换行，只匹配到换行前的结束字符串
\G			  最后匹配完成的位置

\b             单词边界 词在 [] 内无效
			（单词的开头或结尾，限定一个单词要两个一起用）
			（一边字符属于\w，另一边为文首、文尾、行首、行尾或属于\W）
\B             非单词边界
```



## 重复

* 重复使用的的元字符不要放进 [ ] 中，否则就变成了普通字符
* x 要是字符集合

```go
贪婪匹配

x*             0个或任意个 x ，越多越好（优先重复匹配x）
x+             重复>=1次匹配x，越多越好（优先重复匹配x,一个字符或者字符集）
x?             0 个或1个x，优先1次，贪婪方式
x{n,m}         n到m次匹配x，越多越好（优先重复匹配x）贪婪方式
x{n,}          x片段出现m到无限多次，（优先重复匹配x）
x{n}           精确匹配重复出现 n 此

---------------------------------------------------------------
非贪婪匹配 ：就是加了个 ？


x*?            重复>=0次匹配x，越少越好（优先跳出重复）
x+?            重复>=1次匹配x，越少越好（优先跳出重复）
x??            0或1次匹配x，优先0次
x{n,m}?        n到m次匹配x，越少越好（优先跳出重复）
x{n,}?         重复>=n次匹配x，越少越好（优先跳出重复）
x{n}?          重复n次匹配x
```

## 引用

```go
（...）\n     代表模式里第 n 个子表达式,属于相对位置引用
			给子表达式起一个唯一的名字，属于命名捕获（named capture）
------------------------------------------------------------------------
（...）$n 	跨模式使用第一个模式里的第 n 个子表达式



* 模式的后半部分引用前半部分中定义的子表达式
* 只能引用子表达式，还可以被引用多次
* 可以跨模式使用，在第一个模式里被匹配到的子表达式可以用在第二个模式里
* 第0个匹配（\0）用来代表整个正则表达式


* 对文本进行重新排版的时候，可以把文本分解成多个子表达式，可以更精准控制排版效果

​```python
# 替换模式需要两个正则表达式
搜索模式
替换模式
​```

 不同语言的形式不一样
```



## 分组

*   子表达式

```go
子表达式可以嵌套，理论上没有限制，但是实际上适可而止（3层以内）

(re)           括号内的是一组，一个整体，
(?:x)		  匹配 x 但是不记录匹配结果
x(?=y)		  当 x 后接 y 时匹配 x
x(?!y)		  当 x 后不接 y 时匹配 y


( ?=  x)			前查：查找 x 并输出x之前的内容。模块长度可变
( ?<=  x)			后查：查找 x 并输出x之后的内容。模块长度固定

(?!x)				负向前查询: 查找不与给定模块相匹配的文本
(?<! x)				负向后查询: 查找不与给定模块相匹配的文本
```

## 其他

```js
[aeiou]		//匹配一个在给定集合内的字符
[^aeiou]    // 匹配一个不在指定集合内的字符
[foo|bar|baz]  // 匹配任何指定的备选方案
```



## 待整理

```go

* 分行模式匹配
    * 把行分隔符当成一个字符串分割符来对待


* 本质就是子表达式
* 只需要找到自己想要的，不需要检索出来没必要的信息，就不包括在结果中
* 向前查找、向后查找是指与被查文本的相对位置而言的，左 为 前
* 两种查找匹配自身，结果的字节长度永远是0，也称为零宽度（zero-width）匹配操作

1.向前查找

* 指定了一个必须匹配但不在结果中返回的模式

* 向前查找模式的长度是可变的，可以包含 + . 之类的

* 一些文本的术语

```

    消费 consume : 匹配和返回文本
    不消费       ：被匹配的文本不包含在最终的返回结果里
    ```

2.向后查找

* 只能是固定长度  ——  这是一条几乎所有的正则表达式实现都遵守的规则

3.前后查找结合

4.对前后查询取非


正向前、正向后查找： 通过指定匹配结果的前后必须是那些文本
正 ：寻找匹配的事实

负向前、负向后查找：查找不与给定模块相匹配的文本

