##  1.概念

*   一个由固定长度的   特定类型   元素组成的序列 ，元素个数>=0，长度固定，所以很少使用
*   数组就是一个集合 、容器，里面存放了相同元素的数据元素
*   特点
    *   数组中的每个数据元素都是相同的数据类型
    *   数组是由连续的内存位置构成的
    *   最低的地址对应第一个元素，最高的地址对应最后一个元素。
    *   程序运行期间， 数组长度不能改变
*   优点
    *   使用数组来解决问题，程序的可维护性增加。而且方法代码更加清晰，也容易扩展。

## 格式

## 2.声明赋值

### 介绍

```c++
注意
	数组是多个相同类型数据的组合，
    一旦声明/定义了，其长度是固定的，不能动态变化，否则就会报越界
    数组名是常量， 不允许进行赋值修改
        int[] arr = new int[3];
        arr = 10;  // 出错
	所以数组赋值只能在初始化的时候赋值，然后就是一个下表索引一赋值
        
数组名
      // 数组名是一个指向数组中第一个元素的常量指针
	查看内存布局 --  数组指针

声明赋值
    先声明后赋值
    声明的时候赋值
赋值初始化
    new
        动态初始化 ： 指定长度
        静态初始化 ： 指定内容 ，会根据大括号中的内容确定数组长度
    简化
        声明的时候赋值(初始化)
```



### 1.单维数组

#### 声明格式

```java
格式
    
声明
	标准格式
        // new 开辟
        数据类型[] 数组名 = new 数据类型[数组长度]{}；
    	
    省略格式
        数据类型[] 数组名 = {元素1， 元素2， 元素3，...}=
注意
    也可以写成 int a[]; 但是不推荐
    int[]  更能体现：int型数组
```

#### new

```java
声明赋值
    // 先声明后赋值
        // 长度固定
        int[] arr = new int[3];
        a[0] = 3; a[1]=2; a[2]=3;  // 单个赋值
        // 内容固定
        int[] arr2;
        arr2 = new int[]{1,2,3}   // 批量赋值
    // 声明的时候赋值
        // 内容确定 ， 不能使用 长度固定
        int[] arr = new int[]{1, 2, 3}
```

#### 简化

```java
声明赋值
// 声明的时候赋值
    int[] arr2 = arr1;  // arr1 已经确定是一个数组
	int[] arr2 = {1, 2, 3}
// 声明之后赋值
	// 不能进行声明后赋值
	int[] arr;  arr = {1, 2, 3};  // 这样子是错误的
    原因是 ：
        数组名不是一个变量，是个常量 ，值代表第一个数据元素的地址
        直接打印数组名称得到的是数组对应的内存地址哈希值
		// 不能对数组赋值，只能对数组元素初始化或赋值。
```

#### 扩展

```java
// 数组对象 
	Person[] pAll = new Person[3];
	Person one = new Person("lili");
	// 将 one 当中的地址赋值到数组 0 号元素位置
	pAll[0] = one;
	pAll[1].name; // lili
```



### 2.多维数组

````go
方式
	参看变量的声明赋值四种形式

// 先声明后赋值
	数据类型 数组名[ 行数 ][ 列数 ]；
	int arr[2][2];
	arr[1][1] = 3;
// 声明的时候赋值
	数据类型 数组名[ 行数 ][ 列数 ] = 
		{ 
            {0行0列数据1，0行1列数据2,...},  // 一行一个一维数组
            {1行0列数据1，1行1列数据2,...},
            ...
        };
// 数量推倒 ，这种先在一行填充满列数 ，然后再进行下一行的填充，不够的部分使用默认值，多余的舍去
数据类型 数组名[ 行数 ][ 列数 ] = {数据1 ，数据2， 数据3， 数据4，...};
数据类型 数组名[      ][ 列数 ] = {数据1 ，数据2， 数据3， 数据4，...};


````



### 3.默认值

```js
介绍
	对数组中元素初始化，而没有初始化的元素在默认的情况下会用数值0填充，
    代表的是空字符(NULL或\0)

注意
	一个数组，没有对其初始化，那么其输出的数据会是垃圾数据，而不是没有值
    
声明的时候，没有进行初始化赋值的部分就用类型的(默认值)填充了
  
越界的数组访问也使用默认值

// 单维数组
   int a[3] = {1,2}
    a[2] 的值就是 0

// 多维数组
	new int[4][3]
	内层元素：地址值
    外层元素：和一维数组的方式相同
    
	new int[4][]
	内层元素：null
    外层元素： 不能调用，否则报错   
```

## 方法

### 常用方法

```java
int[] arr
    
arr.length  // 数组长度    
```



### api 方法

## 注意

* ArrayList 替代了 vector
* HashMap 替代了 Hashtable



## == 工具类 ==

## Arrays

### 介绍

* 是一个与数组有关的工具类
* 提供了大量的静态方法， 实现数组常见的操作

### 使用

```java
// 直接调用相关方法 ， 不用new 


// 将数组变成字符串 ，按照默认格式 [元素1， 元素2， 元素3]
public static String toString(数组名)
    
// 将数组进行升序排列
public static void sort(数组)；
    数值按照大小， 字符串按照字母升序， 自定义类型需要 comParable 或者 comparator 接口支持
```



### 方法

```java
// Arrays.asList
介绍    
	是 Array 中的⼀个静态⽅法，它能够实现把数组转换成为 List 序列
注意
    1. 转换完成后的 List 不能再进⾏结构化的修改： 不能再进⾏任何 List 元素的增加或者减少的操作。
    2. Arrays.asList 不⽀持基础类型的转换
       Java 中的基础数据类型（byte,short,int,long,float,double,boolean）是
       不⽀持使⽤ Arrays.asList ⽅法去转换的
原因
    // 这是 java.util.Arrays 的内部类，⽽不是 java.util.ArrayList
    private static class ArrayList<E> extends AbstractList<E>
     implements RandomAccess, java.io.Serializable
        
	继承 AbstractList 中对 add、remove、set ⽅法是直接抛异常的，
     也就是说如果继承的⼦类没有去重写
	这些⽅法，那么⼦类的实例去调⽤这些⽅法是会直接抛异常的        
```









# // ===

## 内存布局



### 占用空间+长度

* 介绍

    ```c++
    首地址
    	数组地址 = 数组首地址 = 数组第一行首地址 = 数组第一行第一个元素的地址 = 数值指针 = 函数名
        数组第 n 行首地址 = 第 n 行第一个元素首地址
    ```

    

* 单维数组

    ```c++
    1. 可以统计整个数组在内存中的长度
        数组占用内存长度   sizeof(a)
        数组元素占用内存长度 sizeof(a[0])
        数组长度 len = sizeof(a) / sizeof(a[0])
    2. 获取数组在内存中的首地址
        // 第一个元素的地址就是数组在内存中的首地址
        直接输入 (int)a 就可以得到
        sizeof(a[0])
    ```

* 多维数组

    ```c++
    3. 数组第一行
        占用的内存	sizeof(arr[0])
        首地址(第一个元素)    (int)a[0]
        
    第二行首地址 (int)arr[1]
        
    4. 数组
        首地址
           // 第一个元素的地址就是数组在内存中的首地址
            直接输入 (int)arr 就可以得到
            (int)&arr[0][0]
        占用内存长度   sizeof(arr)
        元素占用内存长度 sizeof(arr[0][0])
        长度 len = sizeof(a) / sizeof(a[0])
        行数  row = sizeof(a) / sizeof(a[0])
        列数	col = sizeof(a[0]) / sizeof(a[0][0])
    ```

* 数组元素地址

    ```c++
    cout << "方法一：" << endl;
    	for(int i = 0; i != ArraySize; i++)
    	cout << "&arr[" << i << "] = " << &arr[i] << endl;
    cout << "方法二：" << endl;
    	for(int i = 0; i != ArraySize; i++)
        cout << "[arr+" << i << "] = " << arr+i << endl;
    cout << "方法三：" << endl;
    	for(int i = 0,*p = arr; p != (arr+ArraySize) && i != ArraySize; i++,p++)
        cout << "p -[" << i << "]= " << p << endl;
    ```

    

### 数组指针

```css
数组名
      // 数组名是一个指向数组中第一个元素的常量指针
      数组名本身不是变量，所以它不占用存储空间，也不能用来存储数据
      它只是代表一个数据，作为值时，它代表数组中第一个数据元素的地址

数组空指针
	int[] arr = NULL;
	arr[0] // NULL_pointer_exception 异常

注意
	1.数组名作为常量指针是合法的，反之亦然。因此
        *(balance + 4) 是一种访问 balance[4] 数据的合法方式
    2. 编译器在编译时对数组中的方括号做了相应的变换：（两边都是相互等价的）
        arr[i] <=> *(arr+i)
        *(arr+i) <=> *(i+arr)
        *(i+arr) <=> i[arr]
        arr[i] <=> i[arr]
        i 是偏移量，表示偏移第一个元素的元素个数

例子
    double *p;
    double balance[10] = {1, 2, 3, 4, 5};
    p = balance;  // 可以
	// 以下三种结构都是一样的
    for ( i = 0; i < 5; i++ ) {
        cout << *(p + i) << endl;
    }
    for ( i = 0; i < 5; i++ ) {
        cout << *(balance + i) << endl;
    }
    for ( i = 0; i < 5; i++ ) {
        cout << balance[i] << endl;
    }
```







## 数组操作

### 访问数组元素 

* 介绍

    ```c++
    *   数组的每个元素都可以通过索引下标来访问，索引下标范围
        	开始 ：从 0 
        	结束 ：数组长度减 1 的位置 
    
    注意
        不允许越界访问 ， 否则会抛出错误
    缺点
        每次数组访问的时候，都要进行边界检查，造成时间和代码上的开销，这是无法避免的，是值得的
        可以从其他地方弥补
        
        int[] arr = {1, 2}；
    	arr[3] // 抛出异常
    ```
    
* 单维数组

    ```c++
    数组名 [ 下标 ]  
        int[] arr = {1, 2}；
    	arr[0] // 1
    ```

* 多维数组

    ```js
    水泥管子
    ```



### 数组长度

```java
语法
    数组名称.length
例子
    int[] arr = new int[3]
    int len = arr.length; // 3
```



### 遍历

```c++ 
// for 循环
    使用 for 循环进行循环遍历打印
       int[] arr = {300, 350, 200, 400, 250}; 
       for (int i = 0; i<=(arr.length - 1); i++) {
            cout << arr[i] <<" ";
        }
        cout << endl;
        return 0;
    }
---------------------------------------------------------------

编译器在编译时对数组中的方括号做了相应的变换：（两边都是相互等价的）
    arr[i] <=> *(arr+i)
    *(arr+i) <=> *(i+arr)
    *(i+arr) <=> i[arr]
    arr[i] <=> i[arr]
    i 是偏移量，表示偏移第一个元素的元素个数
    
for(int i = 0; i != ArraySize; i++)
    // 方法一
    cout << arr[i] << ' ';
    // 方法二
    cout << *(arr+i) << ' ';
    // 方法三
    cout << i[arr] << ' ';
	
// 方法四
	// 指针每自增一个值，就移动到一个元素的位置
	指针自增遍历
 		{ int* p = arr; cout <<  p; p++; }
    指针自减遍历
		{ int* p = arr[ArraySize-1]; cout <<  p; p--; }
 

 //越界访问数组中的数据元素
 cout << "越界访问的后果！" << endl;
 int iNum = 123,iLen = 90;
 int array[7] = {10,3,6,8,5,9,7};
 
 //越界访问数据可能会访问到无法与之的数据
 for(int i = -2; i != 9; i++)
  cout << array[i] << ' ';
 cout << endl;
 
 cout << iNum << "---" << iLen << endl;

 //越界存放数据可能会影响其它变量的值，甚至可能会导致程序崩溃（没有发生这种情况，怪哉！！！）
 for(int i = -2; i != 7; i++)
  cin >> array[i];
 for(int i = 0; i != 7; i++)
  cout << array[i] << ' ';
 cout << endl;
 cout << iNum << "---" << iLen << endl;
 return 0;
}
```

### 复制

```c
直接赋值
    // 其实就是引用赋值
	int[] arr1 = {1, 2};
	int[] arr2 = arr1;  // arr2 = {1, 2}
	解释
        arr2 此时并没有开辟新的空间， arr1 指向的内存地址，复制给 arr2
        arr2 就和 arr1 指向同一块内存地址
        此时对 arr2 进行操作， 就会引起 arr1 的变化
	原因
        就是不要对数组名做除了内存测量之外的操作，详情见介绍中的数组名
```

### 修改

```java
介绍
    数组一旦创建 ， 在程序运行期间， 长度不可以改变
注意
    new 创建一个数组就是开辟一个新的内存空间 
 例子
    []int arr = new int[3];
	arr = new int[5];  // 这种是可以改的 ，并没有改变
```

### 翻转

```java
介绍
    让数据元素位置互换
	{1， 2， 3， 4}  ==》  {4， 3， 2， 1}
例子
    
```





## 4.内存布局

### 1.单维数组

1. 数据的地址可以通过数组名来获取    ： &a
2. 数组的第一个元素的地址，就是数组的首地址
3. 数组的各个元素的地址间隔是依据数组的类型的决定的 ：比如int64 - 》8

### 2.多维数组

```go
1. 先创建一个数组的地址，第一个元素的地址和整个数组的地址是一样的，但是第二个元素的地址是在第一个元素的地址的基础上加上第二个元素相应的数据类型的字节数，就是第二个元素的地址，以此类推
2. [size1]...[sizen]第二个元素和第一个元素之间的地址相差的字节数正好是第一个元素的所有数据的字节数
3. 地址都是在最左边标记的，所以第一个元素和第二个元素之间的地址空间就是第一个元素的数组的数据站的字节数，就可以推到出来第一个元素的数组的第一个元素的地址，（记住地址是在方格的最左边标记的）
```



## 6.使用

### 综述

```c++
1. 作为函数参数
    小括号进行传参， 实际上传递的是数组的地址值
2. 作为函数返回值
    // 详情见函数中 参数  、 返回值
    数组的值， 可以是变量
   C 语言不允许传入/返回一个完整的数组作为函数的参数 
    通过指定不带索引的数组名来传入/返回一个指向数组的指针
```





## -------

