## java 变量

### 介绍

```java
数学区分
    数学概念--->  没有固定值且可改变的数
	计算机实现--> 一段或者多段用来储存数据的内存
含义
    变量相当于内存中一个数据存储空间的表示
    该区域(存储空间)有自己的名称(变量名)和类型(数据类型)
```



### 本质

*   都是值传递
    *   值传递 ： 就是内存传递，将内存中值复制一份传递出去
    *   引用传递 ： 地址传递
*   强类型
    *   变量必须确定类型





## 2.声明/初始化

### 介绍

```c++
变量声明
    // 变量必须先声明， 随后才能使用
    向编译器保证变量以指定的类型和名称存在
    这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译
    
使用
    变量有作用域， 超过作用域就没有作用
    不可以重复定义
初始化
	就是一个名词，一个变量声明后，第一次赋值就叫初始化
    
变量三要素  
	变量= 变量名 + 值 + 数据类型
概念
 	int a;创造了一个变量 a，我们把这个过程叫做 //变量定义。
    a=123;把 123 交给了变量 a，我们把这个过程叫做给 //变量赋值；
    	又因为是第一次赋值，也称 //变量的初始化、赋初值。
注意
     变量没有赋值不能使用 ，没有定义不能使用
```

### 声明语法

```go
基础类型
	声明 赋值
对象
	// 声明 定义 赋值， java 中没有定义
	声明 赋值

1. 先声明后赋值  ---- > // 运行时	
	标准形式
	//指定变量类型，声明后不赋值，使用默认值
2. 声明的时赋值  ---- > // 编译时
	显式地标明变量的类型，在多变量同时声明时可以用到

// -----------------------
索引类型
	1. 根据省略长度，进行推倒(见数组)
	2. 赋值填充
		1. 键值对填充(根据索引键值对确定)
        2. 值列表
        3. 访问字段名填充
```



### 赋值初始化

#### 初始化顺序

```java
介绍
    初始化： 就是变量声明的时候赋值
顺序
    普通成员
        取决于变量定义的先后顺序，
        变量先于方法初始化：即变量在方法调用之前得到初始化
    静态成员
    总顺序
        静态对象 --- 非静态对象
```



#### new 赋值

```java
    2. 构造器初始化
        Person p = new Person();
```



#### 单个赋值

```c++
先声明后赋值
    变量类型 变量名；
    int a;
	a = 1;
声明的时候赋值
    数据类型 变量名 = 变量初始值；
    int a = 1;
```





#### 批量赋值

```go
规则
	批量赋值，等到的左值和右值从左到右的顺序赋值(不提倡使用)
相同类型
	// 先声明后赋值
	int a, b, c;
	a = 1; b = 2; c = 3;
	a=b=c=0;
	// 声明的时候赋值
	int a = 1, b = 2 ,c = 3
	i
不同类型
	// 应该无法同时声明
```



### 默认初始化

```JAVA
介绍

    数据类型都有一个默认值，当声明时没有赋值，就会使用默认值
    默认值又叫零值
    // 初始默认值就是  ：初始但未引用的值
    
规则
    成员变量
        // 静态变量 、非静态变量
        声明的时候没有赋值， 会使用默认值
    局部变量
        不会使用默认值， // 所以局部变量必须自行对其初始化。

具体默认值

    //基础类型
    数值
        整形		int short long  long long  均为 0
        浮点		float double 0.0 
    文本
        字符串_类		     // 空字符串 , 啥也没有 ，输出为空
        字符				[ ]
    布尔
        布尔			false

    -----------------------------------------------------------------
    其他引用类型
            null

    
```

## 3.变量类型

### 分类

#### 介绍

```js
变量类型和数据类型是一样的，只不过看的角度不一样而已

基本类型
	我们将 char、int、float 等由语言本身支持的类型称为
聚合类型（高级类型，复杂类型）    
	将数组、结构体、类（对象）等由基本类型组合而成的类型
	（在讲解结构体时也曾使用复杂类型、构造类型这两种说法）。
    
```

#### 基础类型

```java
// 数值 
    整数(IntegerType)
		byte int short  long
    浮点(floatType)  
        float32 float64
// 文本
    字符型		
		char(单引号的)
    字符串 ：  
		String(双引号的)  // 注意这个是 ： 引用类型
// 布尔
    布尔型：          
        bool
// 注意
   基础类型可以通过 包装类 转化为引用类型
```

#### 引用类型

```js
// 除了基础类型之外的都是引用类型
// 面向对象(代码块在{})
	方法		 通过接口定义类型（jdk8）
	类          class 类名称
    接口
// 除了基本类型外，全部是引用类型，包括自定义类型   
```

#### 区别

| 类型     |                             作用                             | 内存分配 |                                                              |
| -------- | :----------------------------------------------------------: | -------- | ------------------------------------------------------------ |
| 值类型   |      变量直接存储值，<br>都有对应的指针类型(*数据类型)       | 栈中分配 | 数值型      字符型      布尔型                               |
| 引用类型 | 变量存储的是一个地址，这个地址<br/>对应的空间才真正存储数据(值)，<br/>内存通常在。当没有任何变量引用这个地址时，<br/>该地址对应的数据空间就成为一个垃圾，由GC来回收 | 堆上分配 | 字符串<br>数组<br>结构体     指针  slice   map(映射)   chan    interface 函数 |



### 类型转换

#### 隐式扩展转换

```java
特点
	java 自动转换
    规则 ： 数据范围有小到大
    特点 ： 代码不需要进行特殊处理， 自动转换
// 对一个值自动匹配对应的类型
    System.out.println(100);  // 100 默认是整型
    System.out.println("a");  // a 是字符串
    System.out.println(3.13);  // 3.14 默认是 double 类型

// 数据范围有小到大转换
	long a = 100 ;  // 隐式将 int 类型转换为 long 类型
	int num = 100L; // 出错，大范围转为小范围会出现错误
```

#### 强制显示转换

```go
语法
    // 将 类型 A 的值转换为类型 B 的值 ，可以对值和变量类型进行转换
	Type_B = Type_B(Type1_A_variable)
	Type_B = Type_B(Type1_A_value)
	int a = 100L;
	// 注释
		Type 和 Type1 ：表示go中的任意两种变量，Type1不同于Type
		Type_B  : 一种类型的变量
		Type1_A_variable：一种类型的变量的字面值


//注意
1.类型转换可以从大范围到小范围，也可以从小范围到大范围
2.被转化的是变量储存的数据（即值）。变量本身的数据类型没有变化
        long a = 100L;
		int b = int(a) // a 的数据类型没有发生变化，知识它存的值转化为int,并给了b
3.小范围转大范围没有问题
4.大范围转小范围可能导致数据溢出
	long b = 600000000L;
	int a = int(b); // int 最大数值也就是 2 的 32 次方
4.只有相同底层类型的变量之间可以进行相互转换
	int a = int(3.9)  // 会造成精度损失 ， 所有小数位都被删除
	int 和 int32
  不同底层类型的变量相互转换时会引发编译错误
	bool 类型转换为 int 类型

5.浮点数在转换为整型时
	默认：截尾， 会将小数部分去掉，只保留整数部分。29.8 =》 29
	改变 ：舍入， 使用 java.lang.Math 中的 round()方法
```

### 类型自动提升

#### 介绍

```java
byte、char、short -->  int  --> short --> long --> float --> double
```



#### 比 int 小

```java
介绍
    只要类型比 int 小的在运算之前都会转变为 int,
	得到的结果也是  int 
    值得是 ：   byte char short 
表达式 
    1. 右侧赋值没有超过返回，编译器会自动补上强制转换 , 超过了就报错
    	byte a = 40;  // 编译器执行 byte a = byte(a)
    2. 进行数学运算，都会首先被提升为一个 int 类型， 会转化为位一个数字
        byte a1 = 40;
        byte a2 = 50;	
        // // 出错 ，a1 a2 会被提升为 int 类型 ，其结果也是 int 类型，转换出现数值损失
        byte sum = a1 + a2 ;  
	3. 右侧均为数字常量， 是没有提升的 , 编译器的优化，
        byte sum = 8 + 5 ; // byte sum = 13;
	
```

#### 比 int 大

```java
// 通常表达式中最大的数据类型决定了表达式最终结果的数据类型
// 结果跟最大的类型一致， 自动提升为容量大的类型

float + double = double

// 自动转换

int i = 1;
i *= 0.1;  // 复合运算符不能改变变量自身的类型，否则编译失败
System.out.println(i);    // 0
```

### 注意

```java
布尔类型的不能转化为非布尔类型
```

## 4. 作用域

### 作用域

```java
介绍
	作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问
	从变量定义的那一行 到 直接所属大括号结束为止
变量可以声明的地方
	函数或块内部的局部变量
	所有函数外部的全局变量
	形式参数的函数参数定义中
```



### 变量分类(作用域规则)

```java
总分类
    
    // static 修饰实例,因为 static 不修饰局部变量
    静态：	static 修饰的变量，也叫作类变量
    
    非静态
    	实例变量： 类字段
    	局部变量： 方法内变量、for中的变量、参数
总结
    类变量
    实例变量
    	从属于类由类生成对象时，才分配存储空间，
	    各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。
    局部变量
    
改变
    1. 
```



### 使用

#### 	1.局部变量

```go
介绍
	某个函数或块的内部声明的变量称为局部变量
特点
	它们只能被该函数或该代码块内部的语句使用。
	局部变量在函数外部是不可知的

// 函数内部的变量
	函数内声明的变量。
	作用域在函数体内，局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。

// 形式参数
	形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用
    2.形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
    3.在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值，在函数调用时才分配内存
	4. 调用结束后，形参被释放掉，实参保留原值（单向传值）
    
```

#### 	2.全局变量

```go
介绍
	定义在函数外部，通常是在程序的顶部
	全局变量在声明后整个程序中都是可用的

特点
	全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。


2.只需要在源文件中定义,就可以在所有源文件中使用。

注意：
	程序中，局部变量和全局变量的名称可以相同，
	但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用
 

```

#### 区别

|          | 成员变量                                     | 局部变量                               |
| -------- | -------------------------------------------- | -------------------------------------- |
| 定义位置 | 在方法外部， 直接写在类中                    | 在方法内部 + 形式参数                  |
| 作用范围 | 整个类可以通用                               | 只有在方法中才能使用，出了方法无法使用 |
| 默认值   | 有默认值                                     | 没有默认值，不赋值不能用               |
| 内存位置 | 堆内存                                       | 栈内存                                 |
| 声明周期 | 随着对象创建而创建，随着对象被垃圾回收而消失 | 随着方法创建而创建，随着方法出栈而消失 |



### 作用域冲突

```java
1. 不能重复声明
    // 变量在同一个作用域(在一个函数或者在代码块)内不能重名
	// 一个变量（常量、类型和函数）在程序中有一定的作用范围
    int a = 2;
	int a = 5; // Variable 'a' is already defined in the scope
2. 同一变量后面的值，会覆盖前面的值
    int a = 2;
	a = 3;  // a就变成了3
```





## 扩展知识

### 表达式

```java
种类
    左值
    右值
 左值表达式
    指向内存位置的表达式被称为左值（lvalue）表达式。
    左值可以出现在赋值号的左边或右边
右值表达式
    存储在内存中某些地址的数值。
    右值是不能对其进行赋值的表达式
    右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
    
例子
    // 变量是左值，因此可以出现在赋值号的左边。
    // 数值型的字面值是右值，因此不能被赋值
    int a = 10;
```











