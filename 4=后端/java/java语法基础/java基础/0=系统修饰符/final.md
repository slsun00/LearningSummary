## final

### 介绍

```java
修饰符
	final
含义
    最终的， 最后的， 下面就没有了
特点
    一个永远不改变的编译时常量
    一个在运行时被初始化的值，而你不希望改变他
    // final 修饰符和 Java 程序性能优化没有必然联系
```

### 修饰使用

#### 修饰变量

```java
类型
    // 常量
    基本数据类型：
    	则其数值一旦在初始化之后便不能更改
    引用类型： 
    	// 即指向的地址值不能变化， 但是其内容值可以变化
    	则在对其初始化之后便不能再让其指向另一个对象。
    	但是对象内部的属性可以被修改
    	引用恒定不变
           // 保存对象的地址， 这个地址不能改变
           final int[] a = new int[]{1, 3};
            a 中保存着数组 [1,3] 的地址， a 中保存的值，即这个地址不能改变， 
             但是对象可修改， 只要它还在那个地址
语法
	修饰符 final 变量类型 变量名 = 数值
                
声明赋值
    // 先声明后赋值 , 但是必须要保证使用前必须进行初始化
    private final int i;
	//声明的时候赋值
	private final int i = 1;

赋值初始化
    成员变量：必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了
    局部变量：只需要保证在使用之前被初始化赋值即可
赋值的位置
    显式初始化
    代码块中初始化
    构造器中初始化
注意
    匿名内部类中使用的外部局部变量只能是final变量
    可以⽤来保护只读数据，尤其是在并发编程中
	    因为明确的不能再为 final 变量进⾏赋值，有利于减少额外的同步开销
    


```



#### 局部变量

```java
位置
    方法的参数
    方法中的变量
    代码块中的变量
```



#### 修饰方法

##### 修饰参数

```java
介绍
    //     参数使用 final 修饰， 意味着在方法中不能更改参数指向的对象
    表明次形参是一个常量，当我们调用此方法时， 给常量形参赋值一个实参
    一旦复制以后，只能在方法体内使用，但是不能重新赋值

    
使用
    // 你可以读参数，但是不可以修改参数引用地址，不能修改
    使用在匿名内部类之间传递数据

例子
class Person{
    public void name(){};
}
class FinalPerson {
   void get(final Person p){
       // 你可以读参数，但是不可以修改参数地址
       //  p = new Person ,非法， g 是 final ,不能赋予新的地址
   }
}
```

##### 修饰方法

```java
语法格式
    private final 返回值 方法名（参数类表）{}；
    
特点    
    // final 修饰的⽅法不能被重写。override
    1. 明确该方法在继承的时候：不允许被覆盖
	2. 性能（不用考虑这个，可以进行性能测试进行调优，没必要通过 fianl 来调节）
使用
    如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的
	类的private方法会隐式地被指定为final方法。  
原因
    //  private 属于 final 方法 
    类中的所有 private 方法，都隐式被指定为 final
        因为无法调用 private 方法，也就无法覆盖了，
        private final 无意义的，
         
```



#### 修饰类

```java
语法格式
    修饰词 final class  类名 {}

特点
    // 禁止继承使用， 所有成员都隐式指定为 final
    //  private final 无意义的，
    修饰一个类时，表明这个类不能被继承，类中的所有成员方法都会被隐式地指定为final方法  
    
    
使用场景   
    处于设计考虑，该类以后不会设计任何子类，也不想别人设置子类，可以使用
    
```



## 参看常量