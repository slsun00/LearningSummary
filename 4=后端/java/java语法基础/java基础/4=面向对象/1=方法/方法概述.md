## 方法公民

### 介绍

```java
有所属函数
	和类深度绑定的函数， 即写的方法肯定属于一个类
 完成封装
	为完成某一功能的程序指令(语句)的集合，
	将一段经常使用的代码封装起来，减少重复代码
```

### 类型

```java
// 主要是利用函数对象 ， 详情看使用
参数
返回值
赋值给变量
```



### 分类

* 函数的类型被称为函数的标识符 

* 分类

    ```go
    1.	普通的带名字的函数
    2.	匿名函数
            又称： lambda 函数
    3.	方法
    ```

* 常见样式

    ```c++
    有返回值
        有参数
        无参数
    无返回值
       	有参数
        无参数
    ```

    

### 相关概念

```java
   
方法重载
   同一个类中，参数不同，
    
方法覆盖重写 // 参看类中方法
   类继承， 有一个 @override

方法实现  // 参看接口中的方法
    接口实现， 类实现接口的中的方法
```













## 5. 函数体

### 函数变量

### return

```java
作用
    停止当前方法， 将后面返回值还给调用处
    return 后面跟的返回值， 必须和方法前面的返回值类型保持对应
```



## 7.调用

### 本文件调用

```c++
语法
    // 函数名(参数)；
分类
    有返回值
        赋值调用  打印调用	 
    无返回值
    	单独调用
注意
    函数名：需要调用的函数名。
    参数列表：参数变量以逗号分隔，尾部无须逗号结尾。
    返回值变量列表：多个返回值使用逗号分隔
    
语法例子
    public static int add(int a, int b) {
		int res = a + b;
		return res;
	}
    
有返回值(赋值调用)
    // 赋值调用 ：需要返回值，要有变量接收 
        int b = add(3,4)；
        add(3,4)；
   // 打印调用 ： 直接打印返回值
        System.out.println(add(2,3));
无返回值(直接调用)
    // 直接调用 ， 不需要返回值就不用变量接收
    // 无返回值不能使用 打印调用
    int a=1,b=2;
    swap(a, b)；
 

```





### 2.调用机制

```go
当程序调用函数时，程序控制权会转移给被调用的函数。
被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。
----------------------------------------------------------------------------
1. 在调用一个函数时，会给该函数分配一个新的空间（栈），编译器会通过自身的处理让这个新的空间和其它的栈的空间区分开来
2. 在每个函数对应的栈中，数据空间是独立的，不会混淆
3. 当一个函数调用完毕(执行完毕)后，程序会销毁这个函数对应的栈空间。
```

### 3.调用过程

```go
1.函数在定义之后，皆可调用
2.可以通过调用的方式,让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。
3.函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失。
```



## 特殊函数

### 回调函数

```java
原因
    先理解怎么运行回调函数，可能会较好理解函数作为参数使用
 例子
    // 函数 A  作为参数传入函数 B ， 当 B 中的代码执行完会调用 A  ， A 就是回调函数
	// 即函数主体执行完，才执行的函数

	// 定义回调机制 ，这里没有定义 函数 A
        void B(int b, A){
            b++;
            A(b);
        }
	// 实现回调函数 A
        void A(int a) {
            a+=a
        }
	// 调用
		B(3,A)
	// 过程分析
        1. 函数 B 传入一个 参数 3 和一个 函数 A
         2. 函数 B 执行完 3++ ，就开始调用函数 A （此题中给 A 传可一个参数）
        总结
        // 这就是为什么，你使用一个别人提供的 Api , 定义一个函数就可以实现对数据的处理，调用在内部完成
```



## 8. 使用

### 函数对象

```java
介绍
    // 通过一个类去传递/使用一个方法
     java 中函数并不是一种数据类型，需要通过匿名类， 来完成函数的传递
     定义一个只有方法而没有数据的类，然后把这个类的对象传递给别的方法，这时传递的这个对象就是一个函数对象。
    通过对这个类对象达到方法的调用
例子
    
// 一个类，其中定义了一个方法
public class OperAdd {
    public int operation(int a, int b) {
        return a + b ;
    }
}

class  All {
	// 声明了函数对象 f
    // 定义了函数对象传进来，该怎么工作
    public static void doit (int a, int b, OperAdd f) {
        int c = f.operation(a, b);
        System.out.println(c);
    }
	// 实现调用 ,使用匿名内部类
    public static void main(String[] args) {
        doit(1,2,new OperAdd());
    }
}
```



### 参数

```java
介绍
   
// jdk1.1+
	匿名类
 // jdk8
	函数接口  Lambda
// 例子
    // 函数对象介绍了使用类来规定函数，这里使用接口来规定函数
public interface TestMath {
    public static void Add(int a, int b);
}

class Test{
    // 这里只是声明了一个 函数接口， 没有方法实现
    // 只是规定了，该怎么运行
	public void a_Add(int a,int b, TestMath t){
        t.Add(a,b);
    }
    public static void main(String[] args){
		a_Add(1,3,new TestMath(){
            @Override
            Add(int a, int b){
                int c = a+b;
                System.out.print(c);
            }
        })
    }
}
```



### 返回值

```java
// 还是返回了一个函数对象，一个对象 
```



### 赋值给变量

```java
// 返回一个函数对象，这个对象赋值给变量
```



## 方法重载

### 介绍

```c++
作用
    函数名相同，提高复用性
满足条件
    1. 同一个作用域下
    2. 函数名称相同
    3. 函数参数的类型、个数 、顺序不同（这个是重点）
无关条件
    参数名称无关 
    函数返回值无关，没有有返回值都行
    跟限定词无关
作用
    记住一个方法名称 ，可以实现多个功能
 注意
	1.不要使用参数顺序不同来构成重载
```

### 重载提升

```java
// 基本类型的重载
形参类型是一个比较大的类型 ： int
实参类型是一个比较小的类型 ： char
// 形参类型 > 实参类型
    会自动出现类型提升
// 形参类型 < 实参类型
    需要提前进行窄化转换（进行类型转换）， 否则报错
```



### 例子

```c++
// 条件1
    1. 同一个作用域下
    2. 函数名称相同
    3. 函数参数的类型、或者个数 、或者顺序不同
 例子
    void fun() { cout<<"test1"<<endl;}
    void fun(int num1) { cout<<"test2"<<endl; }
    void fun(double num2)   { cout<<"test3"<<endl; }

    int main() {
        fun();  // test1
        fun(1);  // test2
        fun(1.1);  // test3
    }

// 条件2 
	引用作为函数重载的条件
例子
    void fun() { cout<<"test1"<<endl;}
    void fun(int &num1) { cout<<"test2"<<endl; }
    void fun(const int &num1)   { cout<<"test3"<<endl; }

    int main() {
        // a 可读可写，所以调用 test2
        int a = 10;
        fun(a);  // test2

        // int &num1 = 10 不合法，所以不会调用 test2
        fun(10);  // test3 
    }

条件3
    函数重载碰到默认参数
    void fun() { cout<<"test1"<<endl;}
    void fun(int num1, int num2=10) { cout<<"test2"<<endl; }
    void fun(int num1)   { cout<<"test3"<<endl; }

    int main() {
        fun();  // test1
        // 编译器出现二义性，会报错，应该尽量避免使用
        fun(10);  
    }
```





## 内存引用

### this

```JAVA
介绍
    this  指向被调用的成员方法所属的对象
    this 不需要定义，直接使用即可
    
使用
    只能在方法体内使用
    方法体内获取当前对象的引用
    
用途
    // 解决命名冲突
    方法的局部变量和成员变量重名的时候， 根据就近原则， 优先使用局部变量 ，访问类变量就需要用 this
    当形参和成员变量同名时， 可用 this 指针来区分
    //  返回对象本身
    在类的非静态成员函数返回对象本身， 可使用 return this

    
 语法
    this.成员

 省略
    // 为了语义明确，我感觉最好还是加上 this ，
    方法体内调用同一个类中的其他方法不需要加上，编译器会自动加上
 语法例子
    pulic class Person {
        String name;
        // this 指的就是 Person
        public void sayHello(String name) {
            system.out.println(this.name )
        }
    }
```





## -------

## 7.特殊方法

### 构造函数

```c++
详情见 class 中的方法
```

### 析构函数

```c++
详情见 class 中的方法
```



### 递归函数

```c++
详情见 数据算法与结构  递归函数 + 树
```



### 回调函数

```c++
介绍

    一个函数的参数是函数，函数在调用的时候，会调用这个函数参数
    参数函数就叫回调函数 ，主函数就叫回调实现者
阐述
    // 函数 a 的参数是一个参数 b ，
    // 函数 a 调动的时候会调用函数 b ， 即 a 执行函数的时候，会后头调用 函数 b 
    // 函数 b 就叫回调函数 ，函数 a 是回调实现者

注意
    函数做参数，使用的是函数指针，调用者可以传递一个函数的地址给实现者，让实现者去调用它
    关于函数指针的，看函数指针
    
语法例子
    // 回调实现者 func1 ，回调函数 f2
    void func1(int arg, void (*f2)(int)) {
    	cout <<  "接收到参数 arg ," << arg << endl;
    	// 调用参数函数
    	f2(arg);
	}
    
	void hello(int a) {
        cout << "这里是 hello" << endl;
        cout << "回调成功, 传入 " << a << endl;
    }
	int main() {
        // 注意 hello 函数并没有写参数 ，具体看函数指针
        func1(666, hello);
        // 接收到参数 arg ,666
        // 这里是 hello
        // 回调成功, 传入 666
        return 0;
    }
```



### 3、匿名函数

*   介绍
    *   即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体 
    *    匿名函数也往往以变量方式传递 
    *    支持随时在代码里定义匿名函数 

*   定义格式

    ```go
    // 匿名函数就是没有名字的普通函数
    
    func(参数列表)(返回参数列表){
        函数体
    }
    ```

*   调用

    1.  定义的时候进行调用

        ```go
        1. 这种匿名方式只能调用一次
        //--------------------------------------------------------
        a := func （n1 int,n2 int）int(){
        		return n1 + n2
        }(10,20)  // (10,20) 即为对函数的调用，传入的参数是 (10,20)
        ```

        

    2.  匿名函数赋值给变量

        ```go
        1.实现多次调用
        2.将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数
        3.全局匿名函数
        	将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序中有效
        
        //-------------------------------------------------------
        func （n1 int,n2 int）int(){
        		return n1 + n2
        }
        var a func()
        a = 
         a（10 ， 20） // a 调用匿名函数
        
        
        // 全局匿名函数
        
        var (
            FUN1 := func （n1 int,n2 int）int(){
        		return n1 + n2  }
        )
        res := FUN1(10 ,20)
        ```
        
        

* 使用
  
  *   匿名函数作为回调函数
    
      ```go
        //  回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
        // 回调方法 是 任何一个 被 以该回调方法为其第一个参数 的 其它方法 调用 的方法。很多时候，回调是一个当某些事件发生时被调用的方法。
        
        
        // 使用 visit() 函数将整个遍历过程进行封装，
        // 当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。
        
        func visit (list []int, f func(int)) {
            // // 遍历切片的每个元素, 通过给定函数进行元素访问
            for _, v := range list{
                f(v)
            }
        }
        
        func main(){
            // 使用匿名函数打印切片内容
            visit([]int{1,2,3,4},func(v int)){
                // 定义了一个匿名函数，作用是将遍历的每个值打印出来。
                fmt.Println(v)
            }
        }
      ```
  
  *   匿名函数实现封装
  
      ```go
      //
      
      // 定义命令行参数 skill，从命令行输入 --skill 可以将 = 后的字符串传入 skillParam 指针变量。
      var skillParam = flag.String("skill","","skill to perform")
      
      func main(){
          
          // 解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值
          flag.Parse()
          
          // 定义一个从字符串映射到 func() 的 map，然后填充这个 map . 
          // 初始化 map 的键值对，值为匿名函数
          var skill = map[string]func(){
              "fire" : func() {
                  fmt.Println("chicken fire")
              },
              
              "run" ： func() {
                  fmt.Println("soldier run")
              },
              
              "fly" : func(){
                  fmt.Println("angel fly")
              },
          }
          
          // skillParam 是一个 *string 类型的指针变量，
          // 使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。
          if f,ok := skill[*skillParam]; ok {
              f()
          } else {
              fmt.Println("skill not found")
          }
      }
      
      // 运行
      go run main.go --skill=fly  // angel fly
      ```
  
      
  
  ​      



## 函数操作

### 相同函数

```c++
相同类型

*    如果两个函数形式参数列表和返回值列表中的变量类型一一对应，
*    这两个函数被认为有相同的类型和标识符，
*    形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。 
```






## 函数签名

```go
函数签名就是函数的声明信息，包括参数、返回值

参数 	 ：	类型 个数 顺序
返回值	：  类型 个数  
异常   ：
这个众说纷纭，貌似没啥统一的
```



## 成员方法

