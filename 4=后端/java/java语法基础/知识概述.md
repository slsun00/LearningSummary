## 高阶阶段

*   字符串 ""
*   数组  
    *   基础数组
        *   []
    *   高级数组 
        *   collection
            *   List 接口
                *   vector 
                *   Arraylist 	
                *   LinkedList
            *   Set 接口
                *   TreeSet
                *   HashSet
                *   LinkedHashSet
            *   queue 接口
*   双值集合  { value, value}
    *   map
        *   hashMap
        *   treeMap

## 字符串 “”

## 对象

```java
// 集合 {}
单值:{value}
	collection
双值:{key: value}
	map
```



## 数组 [value]

[ ]

## 集合 { key:value }

*   collection

    *   单列集合

*   map

    *   ###### 双列集合

        *   ###### 键和值一一映射，针对键有效，跟值无关

# 区别

### ArrayList 、LinkedList    和    Vector 

```java
arrayList
    动态数组
    遍历访问⾮常快，但是增删⽐较慢，因为会涉及到数组的拷⻉
    是⼀个⾮线程安全的容器，在并发场景会造成问题
    如果想使⽤线程安全的容器的话，
    	推荐使⽤Collections.synchronizedList ；ArrayList 在扩容时会增加 50% 的容量
LinkedList
    是双向链表
    增加和删除⾮常快，  遍历⽐较慢
    ⾮线程安全的容器，推荐使⽤ Collections.synchronizedList
vector
	最早的集合结构  
    ⼀个线程安全的容器，
    它的每个⽅法都粗暴的加上了 synchronized 锁，所以它的增删、遍历效率都很低
```



# 遍历

## == for ===

## 介绍

* 增强 for 是在 jdk1.5 之后出来的
* 名称 ：foreach 语法

## 作用

* 专门遍历数组、集合
* 内部原理就是一个 Iterator 迭代器， 遍历过程中， 不能对集合进行增删操作 , 简化迭代器书写

## 格式

```java
for (元素的数据类型 变量：Collection集合或者数组) {
	// 操作代码
}

// 底层
	// 所有单列集合都可以使用增强 for
	Interface Collection<E>  All Superinterfaces: Iterable <E> 
     实现此接口允许对象成为“for-each loop”语句的目标。 见For-each Loop
// 例子

int[] arr = {1, 3, 4};
for (int a:arr){
    Systerm.out.println(a);
}
```



## == 迭代器 ==

## 实现

```java
迭代器是一个接口， 实现方式比较特殊，
利用 Collection 接口中有一个方法叫 iterator() 方法返回的就是迭代器的实现类对象
 // 使用
 集合页中的方法 itrator() 获取迭代器的实现类，多态使用 Iterator // 集合是什么类型，迭代器就是什么类型
    hasNext 判断有无下一个元素， 
    next 取出下一个元素
```



## 方法

```java
hasNext()
next
```

## 例子

```java
Collection<string> coll = new ArrayList<>();
Iterator <String> it = coll.iterator();
while (it.hasNext()){
    String e = it.next();
    System.out.print(e);
}
```



## 实现原理









