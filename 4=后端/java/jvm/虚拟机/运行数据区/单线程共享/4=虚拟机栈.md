## 虚拟机栈

## 特点

* 就是数据结构的栈

## 介绍

* java virtual machine stacks  java虚拟机栈
* 方法运行的地方， 方法调用会压栈进行运行

```java
// 概念区分
栈
    每个线程运行时所需要的内存空间
栈帧
    // 方法含有的 ： 参数。局部变量，返回地址
    线程中方法运行时所需要的内存空间
    
活动栈帧
    线程正在执行的方法
    
关系
    每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存
    每个线程只能有一个活动栈帧， 对应着当前正在执行那个方法
```

## 大小

```java
介绍
    linux mac oracle  1M
	win 根据虚拟机内存来决定
 
 大小问题
    物理内存大小是固定的， 你为每个线程的栈设置的内存越大，你能开启的线程数就越少
    所以并不是虚拟机栈并不是越大越好，采用系统默认的就可以了
```

## 线程安全

```java
// 方法内的变量是否是线程安全 : 分情况
局部变量
	因为栈是私有的，每开启一个线程，对应开启一个栈帧，
    // 重要看 变量作用域范围 ：
    没有逃离方法体  // 安全
    	栈帧对应一个自己私有的局部变量，线程间对局部变量的操作互不影响
    逃离了方法体    // 有危险，要保护
    	就是不安全的，能在进入方法体之前、逃出方法体之后被其他线程修改


静态方法体中的
    静态方法中的语句、变量，都是在虚拟机栈中，是私有的，
    所以不存在两个线程同时访问方法体中的内容
    
方法的参数
    不是安全的，因为是从其他的地方传进来的
    所以传进来之前是可以被其他线程共同访问的，是线程共享的
方法的返回值
    到哪个返回一个对象，
    其他线程就可能拿到这个返回结果，进行修改，也是不安全的

```



## 栈内存溢出

```java
// 虚拟机栈大小是有默认值的，
错误提示
    java.lang.StackOverflowError
问题产生
    // 有时候不是你的原因，可能是别人的愿意，，，，
	栈帧过多，占用内存超过默认值： 递归调用
    栈帧过大，方法中的参数超级多，一个栈帧就超过了栈的大小 ： 很少出现
```

## 线程运行诊断

```java
// cpu 占用过多
	// liunix
	top 定位哪个线程对 cpu 占有过高
    ps H -eo pid,tid,%cpu|grep 进程id ; 进一步定位哪个线程引起的
    jstack 进程id;   显示线程
        tid 十进制  uid 十六进制， 注意
// 程序长时间运行没有结果
```



## IDEA 对应使用

### 介绍

```java
debugger
	Frames  --> 虚拟机栈  
```

## 问题

* 垃圾回收是否涉及栈内存

    ```java
    1. 栈中是涉及的栈帧， 方法调用结束，栈帧就会被弹出虚拟机栈， 不需要垃圾回收管理
    ```

* 

    ```java
    
    ```

    
    
    